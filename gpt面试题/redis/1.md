好的！下面这份 Redis 面试复习指南，覆盖“核心原理 → 业务场景 → 高频题 → 代码范式/最佳实践 → 踩坑与优化”，尽量通俗+全面。你可以把它当成面试前的“一站式提纲”。

---

# 1）核心概念与数据结构（配场景）

## 1.1 键空间与过期

* **KV 存储**：所有 key 位于全局字典中（哈希表，渐进式 rehash）。
* **过期**：惰性删除（访问时发现过期才删）+ 定期删除（后台采样）；支持 TTL、PTTL。
* **通知**：`notify-keyspace-events` 可发布过期/删除事件。

**场景**：登录态/验证码设置 `EX/PEX`；结合 Keyspace Notifications 做“订单关闭提醒”。

---

## 1.2 Strings（底层 SDS）

* 常用：`GET/SET/INCRBY/DECRBY/APPEND/GETSET/SETEX/SETNX`
* **位图**（BITMAP）：`SETBIT/GETBIT/BITCOUNT` 适合打卡、活跃天统计。
* **HyperLogLog**：`PFADD/PFCOUNT`，超大规模 UV 近似去重。
* **优点**：简单、O(1) 自增。
* **坑**：大 value（bigkey）影响网络与阻塞；`INCR` 64 位有界。

**场景**：验证码次数限流、PV/UV 统计、配置开关、分布式序列号。

---

## 1.3 Hash（对象字段聚合）

* 操作：`HGET/HSET/HMGET/HINCRBY/HDEL/HSCAN`
* **编码**：小对象用紧凑结构（listpack/ziplist），大了转字典。
* **优点**：合理分字段，节省内存；字段级自增。
* **坑**：字段过多也会“bigkey”。

**场景**：购物车（`HSET cart:{uid} sku -> cnt`），用户画像、配置模板。

---

## 1.4 List（有序队列）

* 操作：`LPUSH/RPUSH/LPOP/RPOP/LRANGE/BLPOP/BRPOP`
* 新消息队列建议用 **Stream**（见下），List 适合简单栈/队列。
* **坑**：`LRANGE 0 -1` O(n)；不要拿 List 做“全部分页”。

**场景**：简单任务队列、评论最新 N 条（但分页不友好）。

---

## 1.5 Set / Sorted Set（去重与排行）

* Set：`SADD/SREM/SISMEMBER/SINTER/SCARD`，集合运算高效。
* ZSet：`ZADD/ZINCRBY/ZREVRANGE/ZRANGEBYSCORE`，底层跳表+字典，按分值排序。
* **坑**：大规模交集会阻塞；ZSet 的范围查询是强项但写入比 String 重。

**场景**：去重（已点赞用户）、标签交集检索；排行榜/热度榜（ZSet）。

---

## 1.6 Streams（日志型队列，支持消费组）

* 核心：`XADD/XREAD/XREADGROUP/XACK/XCLAIM/XPENDING`
* **特性**：持久化、消费组、确认机制（至少一次），保留策略（`MAXLEN`）。
* **坑**：不是分区型（与 Kafka 对比），并行度由消费组成员决定；大消息/慢消费者会积压。

**场景**：订单状态流转、异步发送短信/邮件、用户行为埋点。

---

## 1.7 GEO / 布隆等模块

* **GEO**：`GEOADD/GEORADIUS/GEOSEARCH`，附近门店/骑手就近派单。
* **RedisBloom**：布隆/布谷、Count-Min Sketch/Top-K（防穿透、热门词统计）。
* **RedisJSON/RediSearch**：结构化 JSON + 全文检索（做轻量搜索/聚合）。

---

# 2）持久化与数据安全

## 2.1 RDB（快照）

* 触发：`SAVE/BGSAVE` 或配置 `save 900 1` 等。
* **优点**：恢复快、体积小；**缺点**：崩溃丢最近数据。
* 适合：冷备、非强一致读多写少。

## 2.2 AOF（追加日志）

* 模式：`appendfsync always/everysec/no`（常用 everysec）。
* **重写**：`BGREWRITEAOF` 压缩文件；AOF 可配合 RDB 混合写。
* **优点**：更少数据丢失；**缺点**：体积大、写放大。

**面试点**：如何权衡？

* **强一致**更偏 AOF(always/everysec)，**性能与容量**偏 RDB。
* 生产常配：AOF everysec + 定期 RDB 快照 + 异地备份。

---

# 3）复制、高可用与分片

## 3.1 主从复制（异步）

* 初次全量、后续部分重同步（复制积压缓冲区）。
* **磁盘/无盘复制**可选；网络抖动触发部分/全量。
* **读写分离**：只在可以容忍**过期读**时使用从库。

## 3.2 Sentinel（哨兵）

* 职责：监控、通知、自动故障转移（投票选主）。
* 关键参数：`down-after-milliseconds`、`failover-timeout`。
* **客户端侧**：拿到新主地址后自动重连（Jedis/Lettuce/Redisson 都支持）。

## 3.3 Cluster（分片集群）

* **16384 槽**；key 按槽分布。多 key 操作需在**同槽**（用哈希标签 `{}`）。
* **MOVED/ASK** 重定向；在线扩缩容 `reshard`。
* **限制**：Lua、事务、跨槽多 key 受限；不能用多 key 跨槽事务。

**业务思路**：将“强一致多 key”数据建模为**同槽**（如 `order:{123}` 前缀聚合）。

---

# 4）缓存设计与典型问题

## 4.1 四种写策略

* **Cache Aside（旁路）**：先读缓存，miss 再读 DB 回填；写 DB 后**删除缓存**（推荐）。
* **Read/Write Through**：由缓存层代理 DB（需要中间件）。
* **Write Back/Behind**：先写缓存再异步落库（有丢数据风险，配合队列与落库监控）。

**面试延伸**：**写 DB 后“删缓存” vs “更新缓存”**

* 删除更简单，避免并发下“旧值覆盖新值”；必要时配**延迟双删**+消息通知。

## 4.2 三大故障

* **穿透**：查必不存在 → 直接打 DB
  方案：**缓存空值**（短 TTL）、**Bloom**、**参数校验**。
* **击穿**：单热点 key 过期瞬时大量并发
  方案：**互斥锁**（SET NX PX，Lua 保证原子）、**永不过期+异步刷新**、**随机 TTL**。
* **雪崩**：大量 key 同时过期
  方案：TTL 加随机、分批预热、限流降级、热点隔离。

## 4.3 热点与 bigkey

* **热点**：监控 `hotkey` 功能/慢查询；在代理或客户端**多副本读**；ZSet/Hash 拆分分片。
* **bigkey**：用 `SCAN` + `MEMORY USAGE`/`DEBUG OBJECT` 排查；拆分键或分页字段；避免一次性 `DEL`，优先**异步 lazyfree** 或分批删除。

---

# 5）并发控制与一致性

## 5.1 事务 & 乐观锁

* `MULTI/WATCH/EXEC`：典型库存扣减（先 `WATCH` 库存键，读检查，`MULTI` 扣减，`EXEC` 提交；失败重试）。
* **注意**：非隔离，仅保证队列化执行；失败需要**幂等补偿**。

## 5.2 Lua 原子脚本

* 将“读-判-写”合并为一次原子执行；避免 `WATCH` 重试开销。
* **适合**：限流、扣减、分布式队列确认。

## 5.3 分布式锁

* **最小正确性**：`SET key value NX PX ttl` + **释放时校验 value**（Lua：只删自己的锁）。
* **故障**：主从切换导致“锁丢/幽灵锁”。**严肃场景**建议：

  * 锁 + **fencing token**（递增版本号，资源方校验版本）；
  * 或用成熟实现（Redisson）/共识存储（如 etcd/ZK）。
* **不要**用 `DEL` 直接释放；不要无限 TTL。

**加分点**：谈谈 RedLock 争议与实践保守策略（多数节点法 vs 业务补偿）。

---

# 6）限流、延时任务、去重

## 6.1 限流

* **固定窗口**：`INCR` 第一次设置过期；简单但边界效应大。
* **滑动窗口**（ZSet 存时间戳，移除窗口外成员，`ZCARD` 判断）。
* **令牌桶**：ZSet 或脚本按时间补充令牌；或用 `CL.THROTTLE`（Redis Cell 模块）。

## 6.2 延时/定时任务

* **ZSet**：score=执行时间戳，轮询取到期任务执行（配分布式锁/原子 `ZPOPMIN`）。
* **Stream**：自然积压与消费组，更易做重试/死信。

## 6.3 幂等与去重

* **去重**：`SETNX`/`SADD`/布隆；**幂等号**（业务 ID）设计。
* **支付/回调**：落幂等表 + Redis 快速判重，过期清理。

---

# 7）运维与性能优化

## 7.1 内存与淘汰

* **策略**：`noeviction`、`volatile-*`、`allkeys-*`（LRU/LFU/TTL/随机）。
  **生产常用**：`allkeys-lfu`（更稳）或 `allkeys-lru`。
* **LFU 细节**：使用 8-bit 计数近似，访问频率“衰减”。
* **碎片**：跟踪 `mem_fragmentation_ratio`；适度重启/重写；避免小对象过度切换编码。

## 7.2 慢查询与阻塞

* 观察：`SLOWLOG`、`latency doctor`、`INFO` 指标；避免大键/全量扫描；禁止 `KEYS *`。
* **网络**：开启**pipeline** 合并 RTT；批量接口优先。
* **后台任务**：BGSAVE/BGREWRITEAOF 可能抖动，留意 `stop-writes-on-bgsave-error`。

## 7.3 系统参数（Linux）

* `vm.overcommit_memory=1`、关闭 THP、`net.core.somaxconn` 调大；禁用 swap；合理 `tcp-keepalive`。
* **持久化磁盘**：AOF 用 SSD，留足 IOPS；隔离数据与日志。

## 7.4 安全

* 不暴露公网；**ACL** 限权（禁用 `FLUSHALL`、`CONFIG`）；`protected-mode yes`；只绑定内网 IP；开启 TLS（需要编译/镜像支持）。

---

# 8）典型业务建模模板（拿去即用）

1. **排行榜**（ZSet）

* 写：`ZINCRBY rank:{game} 1 {uid}`
* 读：`ZREVRANGE rank:{game} 0 99 WITHSCORES`
* 扩展：分维度维护多个榜；TOP N + `ZREVRANK` 查个人排名。

2. **库存秒杀**（Lua 原子）

```lua
-- KEYS[1]=stock_key, ARGV[1]=num
local stock = redis.call('GET', KEYS[1])
if not stock then return -1 end
stock = tonumber(stock)
local num = tonumber(ARGV[1])
if stock >= num then
  redis.call('DECRBY', KEYS[1], num)
  return 1
else
  return 0
end
```

* 失败返回 0，成功 1，不存在 -1。外围再做订单落库/消息可靠投递。

3. **延时关单**（ZSet）

* 投递：`ZADD order:close ts orderNo`
* 轮询：`ZPOPMIN order:close 100` 取到期批量处理；失败重试回写。

4. **滑动窗口限流**（ZSet）

* `key = rl:{uid}`，score=毫秒时间戳；步骤：`ZREMRANGEBYSCORE key 0 now-window` → `ZADD key now uuid` → `ZCARD key` 判断 → 设置 TTL 防漏。

5. **Session/验证码**（String + TTL）

* `SETEX sms:{mobile} 60 code`；加入“错误次数”键。

6. **地理围栏派单**（GEO）

* `GEOADD riders:city lng lat riderId` → `GEOSEARCH BYRADIUS` 找最近。

7. **去重 UV**（HLL）

* `PFADD uv:{date} {uid}` → `PFCOUNT uv:{date}`；跨日合并 `PFMERGE`。

8. **消息异步化**（Streams）

* Producer：`XADD mail:stream * to "a@b.com" body "..."`
* Consumer Group：`XGROUP CREATE mail:stream g1 0 MKSTREAM`
* 消费：`XREADGROUP GROUP g1 c1 COUNT 50 BLOCK 2000 STREAMS mail:stream >`
* 成功后 `XACK`，失败重投 `XCLAIM`。

---

# 9）代码与客户端实践（Java & Node）

## 9.1 Java（Lettuce/Redisson）

* **连接池**：选择线程安全客户端（Lettuce 默认 netty NIO）。
* **缓存旁路（Spring）**：

```java
@Cacheable(cacheNames="user", key="#id", unless="#result == null")
public User findById(Long id) { ... }
```

* **分布式锁（Redisson）**：

```java
RLock lock = redisson.getLock("lock:order:" + orderId);
if (lock.tryLock(0, 10, TimeUnit.SECONDS)) {
  try { /* 业务 */ }
  finally { lock.unlock(); }
}
```

> 更严格：业务层引入 **fencing token**（数据库自增版本），资源方仅接受更大 token。

## 9.2 Node.js（ioredis）

* **Pipeline**：

```js
const pipeline = redis.pipeline();
ids.forEach(id => pipeline.get(`user:${id}`));
const results = await pipeline.exec();
```

* **限流脚本**：把“增计数+设置过期”打包 Lua，避免第一次 `INCR` 后异常未 `EXPIRE`。

---

# 10）高频面试问答速记

1. **缓存双写一致**怎么做？
   写 DB 成功后**删缓存**，必要时“延迟双删”（间隔 300ms\~1s 再删一次），或用消息通知刷新；强一致用 **同槽多 key + Lua**。

2. **缓存穿透/击穿/雪崩**？
   穿透：空值/Bloom；击穿：互斥锁/永不过期+异步刷新；雪崩：随机 TTL、预热、限流降级。

3. **RDB vs AOF**？
   RDB 恢复快/可能丢最近；AOF 更安全/体积大。常见组合：AOF everysec + 定期 RDB。

4. **主从复制原理**？
   全量 + 部分同步（复制积压缓冲区）；异步复制，可能**过期读**。

5. **Cluster 跨槽多 key 怎么办**？
   **哈希标签** `{}` 放同槽，或改造为单 key 模型；否则功能受限。

6. **分布式锁正确释放**？
   `SET NX PX` + Lua 校验 value；考虑主从切换问题，关键场景引入 **fencing token**。

7. **限流实现**？
   固定窗口（INCR+EXPIRE），滑动窗口（ZSet），令牌桶（脚本/模块）。

8. **为什么避免 bigkey**？
   传输阻塞、删除阻塞；用拆分/分页、异步删除。

9. **如何排查“抖动/高延迟”**？
   先看网络与 QPS → `SLOWLOG`/`latency doctor` → bigkey → 后台任务（BGSAVE/AOF 重写）→ 磁盘 I/O。

10. **Streams vs Kafka**？
    Streams 单实例/集群槽内，轻量易用；Kafka 分区可横向扩展。企业级日志/高吞吐选 Kafka；业务内异步、可靠小流量选 Streams。

---

# 11）答题模板（拿来即说）

* **“设计一个商品详情缓存系统”**

  * 策略：Cache Aside；Key：`item:{id}`；TTL 随机 5–10 分钟；
  * 热点：永不过期 + 后台刷新；
  * 一致：写 DB 后删缓存；
  * 防护：布隆 + 空值；
  * 观测：命中率、回源率、慢查、bigkey；
  * 预案：降级开关（返回核心字段）。

* **“高并发扣库存”**

  * Redis 只做**扣减前置校验**（原子 Lua），订单落库以 DB 为准；
  * 幂等：业务单号；
  * 严格一致：同槽建模 + Lua；
  * 防穿透：活动白名单、限流；
  * 失败补偿：死信/重试队列（Streams）。

* **“分布式限流”**

  * 用户维度：`rl:{uid}` 滑动窗口 ZSet；
  * 网关维度：本地漏桶 + Redis 全局令牌桶；
  * 运维：动态阈值、熔断、黑白名单。

---

# 12）易错点清单

* 在生产中直接使用 `KEYS *`、`FLUSHALL`（必须禁用/限权）。
* 大量 `LRANGE 0 -1` 当分页。
* `INCR` 做限流忘记首次 `EXPIRE` 设置的原子性（需 Lua 或 `SET` 组合）。
* 删除 bigkey 直接 `DEL` 造成阻塞（应分批或 `UNLINK` lazyfree）。
* 锁无 TTL / 释放未校验持有者。
* 从库**读一致性**假设（有延迟）。
* Cluster 下忘记哈希标签导致多 key 失败。
* AOF everysec + 磁盘 I/O 饱和（监控 fsync 延迟）。

---

# 13）最后一页速查表（记住这 10 条就能顶住大多数问答）

1. 选 **Cache Aside**，写 DB 后**删缓存**，必要时“延迟双删”。
2. 防穿透：**布隆 + 空值**；防击穿：**互斥锁/永不过期+刷新**；防雪崩：**TTL 随机化**。
3. **LFU 淘汰** 在热点更稳。
4. **限流**优先脚本化，**滑动窗口**更平滑。
5. **库存/余额**用 **Lua 原子** + 幂等单号 + 失败补偿。
6. **分布式锁**要 **SET NX PX + 校验释放**，关键场景加 **fencing token**。
7. **Cluster** 用 `{tag}` 保证同槽多 key；跨槽别做事务。
8. **监控**：命中率、回源率、慢查询、AOF fsync、复制延迟、内存碎片率。
9. **持久化**：AOF everysec + RDB 定期快照 + 异地备份。
10. **不要**把 Redis 当数据库的“真相源”；强一致写入还是落 DB/消息队列。

---

如果你愿意，我可以把上述内容拆成 **“章节式打卡题 + 代码练习（Java/Go/Node 三套）”** 的面试刷题包，或针对**你的目标岗位/项目**定制一套“高频追问脚本”。
