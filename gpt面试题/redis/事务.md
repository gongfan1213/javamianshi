Redis 的 **事务（Transaction）** 是一种**一次性、顺序性、排他性执行一组命令**的机制，但它与传统关系型数据库事务有明显差异。下面我会帮你**系统复习**，包括**原理、特点、命令流程、注意事项、业务场景、面试陷阱**，再结合实际例子让你彻底掌握。

---

## ✅ **1. Redis 事务的定义**

* **作用**：将多个命令打包，按顺序执行。
* **核心特点**：

  * **顺序性**：所有命令按发送顺序执行。
  * **不被打断**：执行过程中不会被其他客户端命令插入。
  * **无回滚**：即使其中一个命令失败，也不会回滚之前的命令。
* **关键点**：**Redis 事务不是严格意义的事务**，因为缺少**隔离级别**和**回滚机制**。

---

## ✅ **2. 事务的基本命令**

Redis 事务主要涉及 3 个命令：

1. **`MULTI`**：开启事务。
2. **`EXEC`**：提交事务（执行队列中的所有命令）。
3. **`DISCARD`**：取消事务。
4. **（可选）`WATCH`**：实现乐观锁，监控一个或多个 key，防止并发修改。

---

### **事务执行流程**

```text
> MULTI
OK
> SET name "Alice"
QUEUED
> INCR age
QUEUED
> EXEC
1) OK
2) (integer) 1
```

**解释**：

* `MULTI` 开启事务，后续命令进入**队列**（不是立即执行）。
* `EXEC` 执行队列中的命令，保证顺序执行。

---

## ✅ **3. 事务特性**

| 特性      | Redis 支持吗？    |
| ------- | ------------- |
| **原子性** | ❌（命令不会回滚）     |
| **一致性** | ✅（执行顺序一致）     |
| **隔离性** | ✅（事务执行时不会被打断） |
| **持久性** | ✅（依赖 RDB/AOF） |

**重点**：Redis 事务只是**命令批量打包**，不是严格 ACID。

---

## ✅ **4. WATCH 实现乐观锁**

`WATCH` 可以**监控一个或多个 key**，如果事务提交时 key 被修改，则事务失败（返回 nil）。

```text
> WATCH product_stock
OK
> MULTI
> DECR product_stock
QUEUED
> EXEC
(nil)   # 如果 product_stock 在 EXEC 前被修改
```

**业务场景**：防止超卖。

* **流程**：

  1. `WATCH stock` 监控库存。
  2. 检查库存是否 > 0。
  3. 如果是，`MULTI` 开启事务，`DECR stock`。
  4. 如果 `stock` 在 EXEC 前被改，事务失败，重试。

---

## ✅ **5. 事务中的错误处理**

Redis 事务有两种错误情况：

1. **语法错误（在 MULTI 阶段发现）**

   * 直接 `EXEC` 时，整个事务不会执行。

   ```text
   > MULTI
   > SET key value
   > INCR wrong_key value   # 参数错误
   > EXEC
   (error) EXECABORT Transaction discarded because of previous errors.
   ```

2. **运行错误（在 EXEC 阶段发现）**

   * 错误命令不会回滚，其他命令继续执行。

   ```text
   > MULTI
   > SET a 1
   > INCR a
   > INCR b   # b 不是整数
   > EXEC
   1) OK
   2) (integer) 2
   3) (error) ERR value is not an integer
   ```

---

## ✅ **6. 事务 VS Pipeline**

| 特性      | 事务 MULTI/EXEC | Pipeline  |
| ------- | ------------- | --------- |
| **作用**  | 保证顺序执行        | 减少 RTT    |
| **原子性** | 部分（无回滚）       | ❌         |
| **隔离性** | ✅             | ❌         |
| **场景**  | 库存扣减、账户转账     | 大量读写、批量导入 |

---

## ✅ **7. 实际业务场景**

**库存扣减（防止超卖）**

```lua
WATCH stock
if stock > 0 then
  MULTI
  DECR stock
  EXEC
else
  # 库存不足
```

**账户转账**

```lua
WATCH account:A account:B
if A_balance >= 100 then
  MULTI
  DECRBY account:A 100
  INCRBY account:B 100
  EXEC
else
  # 余额不足
```

---

## ✅ **8. 事务的缺点**

* **没有回滚**：一个命令失败不会影响其他命令。
* **不支持跨实例**：事务只在单个 Redis 节点有效。
* **性能不如 Pipeline**：因为事务要排队执行，不能并发。

---

## ✅ **9. 面试高频问题**

**Q1：Redis 事务是否支持回滚？**

* 不支持，原因是：

  * Redis 命令大部分 O(1)，回滚成本高。
  * 错误大多是编程问题，重试更合适。

**Q2：WATCH 实现分布式锁了吗？**

* 不是分布式锁，只是乐观锁机制。

**Q3：Redis 事务和数据库事务的最大区别？**

* Redis 事务没有隔离级别和回滚。

**Q4：WATCH 会监控多久？**

* 直到 `EXEC` 或 `DISCARD`，或者客户端断开。

---

要不要我再帮你**画一张事务执行流程图（包含 WATCH 机制）**，并整理**事务 vs Pipeline vs Lua 脚本对比表**？
这个表和图在面试里超加分，因为很多人只会说命令，不会深入到机制对比。
