# 配置中心实现

## 🎯 配置中心概述

配置中心是分布式系统中的重要组件，用于集中管理配置信息，支持配置的动态更新和实时同步。

### 1. 配置中心的优势
- **集中管理**：所有配置集中存储，便于管理
- **动态更新**：配置修改后实时生效，无需重启
- **版本控制**：支持配置的版本管理和回滚
- **环境隔离**：支持不同环境的配置隔离

### 2. ZooKeeper实现配置中心的优势
- **实时通知**：Watcher机制支持配置变化实时通知
- **强一致性**：ZAB协议保证配置数据一致性
- **高可用性**：集群部署保证服务可用性
- **权限控制**：ACL机制支持细粒度权限控制

## 🏗️ 基础配置中心实现

### 1. 配置节点结构
```
/config
├── app1/
│   ├── database.properties
│   ├── redis.properties
│   └── application.yml
├── app2/
│   ├── database.properties
│   └── application.yml
└── global/
    ├── system.properties
    └── feature-flags.properties
```

### 2. 配置管理器
```java
public class ConfigurationManager {
    private ZooKeeper zk;
    private String configRootPath;
    private Map<String, String> localCache = new ConcurrentHashMap<>();
    private Map<String, List<ConfigurationChangeListener>> listeners = new ConcurrentHashMap<>();
    
    public ConfigurationManager(ZooKeeper zk, String configRootPath) {
        this.zk = zk;
        this.configRootPath = configRootPath;
        initializeConfigRoot();
    }
    
    // 初始化配置根目录
    private void initializeConfigRoot() {
        try {
            if (zk.exists(configRootPath, false) == null) {
                zk.create(configRootPath, "config-root".getBytes(),
                          ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    // 设置配置
    public void setConfig(String appName, String configName, String value) throws Exception {
        String path = configRootPath + "/" + appName + "/" + configName;
        
        // 确保父目录存在
        ensureParentExists(path);
        
        // 创建或更新配置节点
        if (zk.exists(path, false) == null) {
            zk.create(path, value.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        } else {
            zk.setData(path, value.getBytes(), -1);
        }
        
        // 更新本地缓存
        localCache.put(path, value);
        
        // 通知监听器
        notifyListeners(path, value);
    }
    
    // 获取配置
    public String getConfig(String appName, String configName) throws Exception {
        String path = configRootPath + "/" + appName + "/" + configName;
        
        // 先从本地缓存获取
        String cachedValue = localCache.get(path);
        if (cachedValue != null) {
            return cachedValue;
        }
        
        // 从ZooKeeper获取
        try {
            byte[] data = zk.getData(path, false, null);
            String value = new String(data);
            
            // 更新本地缓存
            localCache.put(path, value);
            
            // 注册监听器
            registerWatcher(path);
            
            return value;
        } catch (KeeperException.NoNodeException e) {
            return null; // 配置不存在
        }
    }
    
    // 删除配置
    public void deleteConfig(String appName, String configName) throws Exception {
        String path = configRootPath + "/" + appName + "/" + configName;
        
        try {
            zk.delete(path, -1);
            
            // 从本地缓存移除
            localCache.remove(path);
            
            // 通知监听器
            notifyListeners(path, null);
        } catch (KeeperException.NoNodeException e) {
            // 配置不存在，忽略异常
        }
    }
    
    // 获取应用的所有配置
    public Map<String, String> getAllConfigs(String appName) throws Exception {
        Map<String, String> configs = new HashMap<>();
        String appPath = configRootPath + "/" + appName;
        
        try {
            List<String> configNames = zk.getChildren(appPath, false);
            
            for (String configName : configNames) {
                String value = getConfig(appName, configName);
                if (value != null) {
                    configs.put(configName, value);
                }
            }
        } catch (KeeperException.NoNodeException e) {
            // 应用目录不存在
        }
        
        return configs;
    }
    
    // 确保父目录存在
    private void ensureParentExists(String path) throws Exception {
        String parentPath = path.substring(0, path.lastIndexOf("/"));
        
        if (zk.exists(parentPath, false) == null) {
            ensureParentExists(parentPath);
            zk.create(parentPath, "".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        }
    }
    
    // 注册监听器
    private void registerWatcher(String path) throws Exception {
        zk.getData(path, new Watcher() {
            @Override
            public void process(WatchedEvent event) {
                if (event.getType() == Event.EventType.NodeDataChanged) {
                    try {
                        // 重新获取数据
                        byte[] data = zk.getData(path, this, null);
                        String newValue = new String(data);
                        
                        // 更新本地缓存
                        localCache.put(path, newValue);
                        
                        // 通知监听器
                        notifyListeners(path, newValue);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }, null);
    }
    
    // 添加配置变化监听器
    public void addListener(String appName, String configName, ConfigurationChangeListener listener) {
        String path = configRootPath + "/" + appName + "/" + configName;
        listeners.computeIfAbsent(path, k -> new ArrayList<>()).add(listener);
    }
    
    // 移除配置变化监听器
    public void removeListener(String appName, String configName, ConfigurationChangeListener listener) {
        String path = configRootPath + "/" + appName + "/" + configName;
        List<ConfigurationChangeListener> listenerList = listeners.get(path);
        if (listenerList != null) {
            listenerList.remove(listener);
        }
    }
    
    // 通知监听器
    private void notifyListeners(String path, String newValue) {
        List<ConfigurationChangeListener> listenerList = listeners.get(path);
        if (listenerList != null) {
            for (ConfigurationChangeListener listener : listenerList) {
                try {
                    listener.onConfigurationChange(path, newValue);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

// 配置变化监听器接口
public interface ConfigurationChangeListener {
    void onConfigurationChange(String path, String newValue);
}
```

## 🚀 高级配置中心功能

### 1. 配置版本管理
```java
public class VersionedConfigurationManager extends ConfigurationManager {
    private static final String VERSION_SUFFIX = "_version";
    
    public VersionedConfigurationManager(ZooKeeper zk, String configRootPath) {
        super(zk, configRootPath);
    }
    
    // 设置配置（带版本）
    public void setConfigWithVersion(String appName, String configName, String value, int expectedVersion) throws Exception {
        String path = configRootPath + "/" + appName + "/" + configName;
        String versionPath = path + VERSION_SUFFIX;
        
        try {
            // 检查版本
            Stat stat = zk.exists(path, false);
            if (stat != null && stat.getVersion() != expectedVersion) {
                throw new RuntimeException("版本冲突，配置已被其他客户端修改");
            }
            
            // 更新配置
            if (stat == null) {
                zk.create(path, value.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
            } else {
                zk.setData(path, value.getBytes(), expectedVersion);
            }
            
            // 更新版本信息
            String versionInfo = String.format("version=%d,updateTime=%d,updateBy=%s", 
                                             expectedVersion + 1, System.currentTimeMillis(), "client");
            if (zk.exists(versionPath, false) == null) {
                zk.create(versionPath, versionInfo.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
            } else {
                zk.setData(versionPath, versionInfo.getBytes(), -1);
            }
            
        } catch (KeeperException.BadVersionException e) {
            throw new RuntimeException("版本冲突，配置已被其他客户端修改");
        }
    }
    
    // 获取配置版本
    public int getConfigVersion(String appName, String configName) throws Exception {
        String path = configRootPath + "/" + appName + "/" + configName;
        
        try {
            Stat stat = zk.exists(path, false);
            return stat != null ? stat.getVersion() : -1;
        } catch (Exception e) {
            return -1;
        }
    }
    
    // 获取配置历史版本
    public List<String> getConfigHistory(String appName, String configName) throws Exception {
        String path = configRootPath + "/" + appName + "/" + configName;
        String versionPath = path + VERSION_SUFFIX;
        
        try {
            byte[] data = zk.getData(versionPath, false, null);
            return Arrays.asList(new String(data).split(","));
        } catch (KeeperException.NoNodeException e) {
            return new ArrayList<>();
        }
    }
}
```

### 2. 配置加密
```java
public class EncryptedConfigurationManager extends ConfigurationManager {
    private String encryptionKey;
    
    public EncryptedConfigurationManager(ZooKeeper zk, String configRootPath, String encryptionKey) {
        super(zk, configRootPath);
        this.encryptionKey = encryptionKey;
    }
    
    // 加密数据
    private String encrypt(String data) throws Exception {
        // 这里使用简单的Base64编码，实际项目中应该使用更安全的加密算法
        return Base64.getEncoder().encodeToString(data.getBytes());
    }
    
    // 解密数据
    private String decrypt(String encryptedData) throws Exception {
        byte[] decoded = Base64.getDecoder().decode(encryptedData);
        return new String(decoded);
    }
    
    // 设置加密配置
    public void setEncryptedConfig(String appName, String configName, String value) throws Exception {
        String encryptedValue = encrypt(value);
        super.setConfig(appName, configName, encryptedValue);
    }
    
    // 获取解密配置
    public String getDecryptedConfig(String appName, String configName) throws Exception {
        String encryptedValue = super.getConfig(appName, configName);
        if (encryptedValue != null) {
            return decrypt(encryptedValue);
        }
        return null;
    }
}
```

### 3. 配置模板管理
```java
public class ConfigurationTemplateManager {
    private ZooKeeper zk;
    private String templateRootPath;
    
    public ConfigurationTemplateManager(ZooKeeper zk, String templateRootPath) {
        this.zk = zk;
        this.templateRootPath = templateRootPath;
        initializeTemplateRoot();
    }
    
    // 初始化模板根目录
    private void initializeTemplateRoot() {
        try {
            if (zk.exists(templateRootPath, false) == null) {
                zk.create(templateRootPath, "template-root".getBytes(),
                          ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    // 创建配置模板
    public void createTemplate(String templateName, Map<String, String> configs) throws Exception {
        String templatePath = templateRootPath + "/" + templateName;
        
        // 创建模板目录
        if (zk.exists(templatePath, false) == null) {
            zk.create(templatePath, "template".getBytes(),
                      ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        }
        
        // 创建配置项
        for (Map.Entry<String, String> entry : configs.entrySet()) {
            String configPath = templatePath + "/" + entry.getKey();
            if (zk.exists(configPath, false) == null) {
                zk.create(configPath, entry.getValue().getBytes(),
                          ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
            } else {
                zk.setData(configPath, entry.getValue().getBytes(), -1);
            }
        }
    }
    
    // 应用模板到应用
    public void applyTemplate(String templateName, String appName, ConfigurationManager configManager) throws Exception {
        String templatePath = templateRootPath + "/" + templateName;
        
        try {
            List<String> configNames = zk.getChildren(templatePath, false);
            
            for (String configName : configNames) {
                if (!configName.equals("metadata")) { // 跳过元数据
                    byte[] data = zk.getData(templatePath + "/" + configName, false, null);
                    String value = new String(data);
                    
                    // 应用配置到目标应用
                    configManager.setConfig(appName, configName, value);
                }
            }
        } catch (KeeperException.NoNodeException e) {
            throw new RuntimeException("模板不存在: " + templateName);
        }
    }
    
    // 获取模板列表
    public List<String> getTemplateList() throws Exception {
        try {
            return zk.getChildren(templateRootPath, false);
        } catch (Exception e) {
            return new ArrayList<>();
        }
    }
}
```

## 💡 使用示例

### 1. 基本使用
```java
public class ConfigurationExample {
    public static void main(String[] args) {
        try {
            ZooKeeper zk = new ZooKeeper("localhost:2181", 5000, null);
            ConfigurationManager configManager = new ConfigurationManager(zk, "/config");
            
            // 设置配置
            configManager.setConfig("app1", "database.url", "jdbc:mysql://localhost:3306/mydb");
            configManager.setConfig("app1", "database.username", "root");
            configManager.setConfig("app1", "database.password", "password");
            
            // 获取配置
            String dbUrl = configManager.getConfig("app1", "database.url");
            System.out.println("数据库URL: " + dbUrl);
            
            // 添加配置变化监听器
            configManager.addListener("app1", "database.url", new ConfigurationChangeListener() {
                @Override
                public void onConfigurationChange(String path, String newValue) {
                    System.out.println("配置发生变化: " + path + " = " + newValue);
                    // 重新加载数据库连接
                    reloadDatabaseConnection(newValue);
                }
            });
            
            // 修改配置（会触发监听器）
            configManager.setConfig("app1", "database.url", "jdbc:mysql://localhost:3306/newdb");
            
            Thread.sleep(5000); // 等待监听器执行
            
            zk.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    private static void reloadDatabaseConnection(String newUrl) {
        System.out.println("重新加载数据库连接: " + newUrl);
        // 实现数据库连接重载逻辑
    }
}
```

### 2. 配置热更新
```java
public class HotReloadExample {
    public static void main(String[] args) {
        try {
            ZooKeeper zk = new ZooKeeper("localhost:2181", 5000, null);
            ConfigurationManager configManager = new ConfigurationManager(zk, "/config");
            
            // 模拟应用启动时加载配置
            AppConfig appConfig = new AppConfig(configManager);
            appConfig.loadConfig("app1");
            
            // 配置变化时自动重新加载
            configManager.addListener("app1", "database.url", 
                (path, newValue) -> appConfig.reloadDatabaseConfig(newValue));
            
            configManager.addListener("app1", "redis.host", 
                (path, newValue) -> appConfig.reloadRedisConfig(newValue));
            
            // 模拟配置更新
            Thread.sleep(2000);
            configManager.setConfig("app1", "database.url", "jdbc:mysql://newhost:3306/mydb");
            
            Thread.sleep(2000);
            configManager.setConfig("app1", "redis.host", "new-redis-host");
            
            Thread.sleep(5000);
            zk.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

// 应用配置类
class AppConfig {
    private ConfigurationManager configManager;
    private String databaseUrl;
    private String redisHost;
    
    public AppConfig(ConfigurationManager configManager) {
        this.configManager = configManager;
    }
    
    public void loadConfig(String appName) throws Exception {
        Map<String, String> configs = configManager.getAllConfigs(appName);
        
        databaseUrl = configs.get("database.url");
        redisHost = configs.get("redis.host");
        
        System.out.println("配置加载完成:");
        System.out.println("数据库URL: " + databaseUrl);
        System.out.println("Redis主机: " + redisHost);
    }
    
    public void reloadDatabaseConfig(String newUrl) {
        this.databaseUrl = newUrl;
        System.out.println("数据库配置已重新加载: " + newUrl);
        // 实现数据库连接重载逻辑
    }
    
    public void reloadRedisConfig(String newHost) {
        this.redisHost = newHost;
        System.out.println("Redis配置已重新加载: " + newHost);
        // 实现Redis连接重载逻辑
    }
}
```

### 3. 配置模板使用
```java
public class TemplateExample {
    public static void main(String[] args) {
        try {
            ZooKeeper zk = new ZooKeeper("localhost:2181", 5000, null);
            ConfigurationManager configManager = new ConfigurationManager(zk, "/config");
            ConfigurationTemplateManager templateManager = new ConfigurationTemplateManager(zk, "/templates");
            
            // 创建数据库配置模板
            Map<String, String> dbTemplate = new HashMap<>();
            dbTemplate.put("database.url", "jdbc:mysql://localhost:3306/${dbname}");
            dbTemplate.put("database.username", "root");
            dbTemplate.put("database.password", "password");
            dbTemplate.put("database.pool.size", "10");
            
            templateManager.createTemplate("database", dbTemplate);
            
            // 应用模板到不同应用
            templateManager.applyTemplate("database", "app1", configManager);
            templateManager.applyTemplate("database", "app2", configManager);
            
            // 查看应用配置
            Map<String, String> app1Configs = configManager.getAllConfigs("app1");
            System.out.println("App1配置: " + app1Configs);
            
            Map<String, String> app2Configs = configManager.getAllConfigs("app2");
            System.out.println("App2配置: " + app2Configs);
            
            zk.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## 🔧 配置中心管理工具

### 1. 配置导入导出
```java
public class ConfigurationExporter {
    private ConfigurationManager configManager;
    
    public ConfigurationExporter(ConfigurationManager configManager) {
        this.configManager = configManager;
    }
    
    // 导出配置到文件
    public void exportToFile(String appName, String filePath) throws Exception {
        Map<String, String> configs = configManager.getAllConfigs(appName);
        
        Properties props = new Properties();
        for (Map.Entry<String, String> entry : configs.entrySet()) {
            props.setProperty(entry.getKey(), entry.getValue());
        }
        
        try (FileOutputStream out = new FileOutputStream(filePath)) {
            props.store(out, "Configuration for " + appName);
        }
    }
    
    // 从文件导入配置
    public void importFromFile(String appName, String filePath) throws Exception {
        Properties props = new Properties();
        
        try (FileInputStream in = new FileInputStream(filePath)) {
            props.load(in);
        }
        
        for (String key : props.stringPropertyNames()) {
            String value = props.getProperty(key);
            configManager.setConfig(appName, key, value);
        }
    }
}
```

### 2. 配置验证
```java
public class ConfigurationValidator {
    
    // 验证配置完整性
    public static boolean validateConfig(Map<String, String> configs, List<String> requiredKeys) {
        for (String key : requiredKeys) {
            if (!configs.containsKey(key) || configs.get(key) == null || configs.get(key).trim().isEmpty()) {
                System.out.println("缺少必需配置: " + key);
                return false;
            }
        }
        return true;
    }
    
    // 验证配置格式
    public static boolean validateConfigFormat(String key, String value, String pattern) {
        if (value == null || !value.matches(pattern)) {
            System.out.println("配置格式错误: " + key + " = " + value);
            return false;
        }
        return true;
    }
}
```

## 🚨 注意事项

### 1. 配置安全性
- **敏感信息加密**：密码等敏感信息应该加密存储
- **权限控制**：使用ACL控制配置的访问权限
- **审计日志**：记录配置的修改历史

### 2. 性能优化
- **本地缓存**：减少ZooKeeper的访问次数
- **批量操作**：批量读取和更新配置
- **异步处理**：配置变化通知使用异步处理

### 3. 容错处理
- **连接重试**：ZooKeeper连接失败时自动重试
- **降级策略**：配置中心不可用时使用本地配置
- **监控告警**：监控配置中心的健康状态

## 🔗 下一步学习

- [服务发现实现](./09.服务发现实现.md) - 学习服务发现
- [面试题集锦](./10.面试题集锦.md) - 准备面试
- [实战项目](./11.实战项目.md) - 完整项目实践

---

**记住：配置中心是微服务架构的核心，掌握它就能实现配置的动态管理！** 🎯
