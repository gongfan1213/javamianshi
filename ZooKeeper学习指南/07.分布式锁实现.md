# åˆ†å¸ƒå¼é”å®ç°

## ğŸ”’ åˆ†å¸ƒå¼é”æ¦‚è¿°

åˆ†å¸ƒå¼é”æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„é‡è¦ç»„ä»¶ï¼Œç”¨äºåè°ƒå¤šä¸ªè¿›ç¨‹æˆ–æœåŠ¡å¯¹å…±äº«èµ„æºçš„è®¿é—®ã€‚

### 1. åˆ†å¸ƒå¼é”çš„ç‰¹æ€§
- **äº’æ–¥æ€§**ï¼šåŒä¸€æ—¶åˆ»åªèƒ½æœ‰ä¸€ä¸ªå®¢æˆ·ç«¯æŒæœ‰é”
- **é˜²æ­»é”**ï¼šå³ä½¿æŒæœ‰é”çš„å®¢æˆ·ç«¯å´©æºƒï¼Œé”ä¹Ÿèƒ½è¢«é‡Šæ”¾
- **å¯é‡å…¥æ€§**ï¼šåŒä¸€ä¸ªå®¢æˆ·ç«¯å¯ä»¥å¤šæ¬¡è·å–åŒä¸€æŠŠé”
- **å…¬å¹³æ€§**ï¼šæŒ‰ç…§è¯·æ±‚é¡ºåºè·å–é”

### 2. ZooKeeperå®ç°åˆ†å¸ƒå¼é”çš„ä¼˜åŠ¿
- **è‡ªåŠ¨é‡Šæ”¾**ï¼šä¸´æ—¶èŠ‚ç‚¹åœ¨ä¼šè¯ç»“æŸæ—¶è‡ªåŠ¨åˆ é™¤
- **é¡ºåºä¿è¯**ï¼šé¡ºåºèŠ‚ç‚¹ä¿è¯è·å–é”çš„å…¬å¹³æ€§
- **å¼ºä¸€è‡´æ€§**ï¼šZABåè®®ä¿è¯æ•°æ®ä¸€è‡´æ€§
- **é«˜å¯ç”¨æ€§**ï¼šé›†ç¾¤éƒ¨ç½²ä¿è¯æœåŠ¡å¯ç”¨æ€§

## ğŸ—ï¸ åŸºç¡€åˆ†å¸ƒå¼é”å®ç°

### 1. ç®€å•åˆ†å¸ƒå¼é”
```java
public class SimpleDistributedLock {
    private ZooKeeper zk;
    private String lockPath;
    private String lockNode;
    private boolean isLocked = false;
    
    public SimpleDistributedLock(ZooKeeper zk, String lockPath) {
        this.zk = zk;
        this.lockPath = lockPath;
    }
    
    // è·å–é”
    public boolean acquireLock(long timeout) throws Exception {
        long startTime = System.currentTimeMillis();
        
        while (System.currentTimeMillis() - startTime < timeout) {
            try {
                // åˆ›å»ºä¸´æ—¶èŠ‚ç‚¹ä½œä¸ºé”
                lockNode = zk.create(lockPath + "/lock-", "locked".getBytes(),
                                   ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
                isLocked = true;
                System.out.println("æˆåŠŸè·å–é”: " + lockNode);
                return true;
            } catch (KeeperException.NodeExistsException e) {
                // é”å·²è¢«å…¶ä»–å®¢æˆ·ç«¯æŒæœ‰ï¼Œç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•
                Thread.sleep(100);
            }
        }
        
        System.out.println("è·å–é”è¶…æ—¶");
        return false;
    }
    
    // é‡Šæ”¾é”
    public void releaseLock() throws Exception {
        if (isLocked && lockNode != null) {
            try {
                zk.delete(lockNode, -1);
                isLocked = false;
                lockNode = null;
                System.out.println("é”å·²é‡Šæ”¾");
            } catch (KeeperException.NoNodeException e) {
                // èŠ‚ç‚¹å·²è¢«åˆ é™¤ï¼Œå¿½ç•¥å¼‚å¸¸
            }
        }
    }
    
    public boolean isLocked() {
        return isLocked;
    }
}
```

### 2. ä½¿ç”¨ç¤ºä¾‹
```java
public class LockExample {
    public static void main(String[] args) {
        try {
            ZooKeeper zk = new ZooKeeper("localhost:2181", 5000, null);
            SimpleDistributedLock lock = new SimpleDistributedLock(zk, "/locks");
            
            // è·å–é”
            if (lock.acquireLock(5000)) {
                try {
                    System.out.println("æ‰§è¡Œä¸šåŠ¡é€»è¾‘...");
                    Thread.sleep(2000);
                } finally {
                    // é‡Šæ”¾é”
                    lock.releaseLock();
                }
            }
            
            zk.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## ğŸš€ é«˜çº§åˆ†å¸ƒå¼é”å®ç°

### 1. å…¬å¹³åˆ†å¸ƒå¼é”ï¼ˆåŸºäºé¡ºåºèŠ‚ç‚¹ï¼‰
```java
public class FairDistributedLock {
    private ZooKeeper zk;
    private String lockPath;
    private String lockNode;
    private boolean isLocked = false;
    private CountDownLatch lockAcquiredSignal = new CountDownLatch(1);
    
    public FairDistributedLock(ZooKeeper zk, String lockPath) {
        this.zk = zk;
        this.lockPath = lockPath;
    }
    
    // è·å–é”
    public boolean acquireLock(long timeout) throws Exception {
        long startTime = System.currentTimeMillis();
        
        try {
            // åˆ›å»ºä¸´æ—¶é¡ºåºèŠ‚ç‚¹
            lockNode = zk.create(lockPath + "/lock-", "locked".getBytes(),
                               ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
            
            // æ£€æŸ¥æ˜¯å¦è·å¾—é”
            if (checkLockAcquired(lockNode)) {
                isLocked = true;
                System.out.println("æˆåŠŸè·å–é”: " + lockNode);
                return true;
            }
            
            // ç­‰å¾…é”é‡Šæ”¾
            if (waitForLock(lockNode, timeout - (System.currentTimeMillis() - startTime))) {
                isLocked = true;
                System.out.println("æˆåŠŸè·å–é”: " + lockNode);
                return true;
            }
            
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        System.out.println("è·å–é”è¶…æ—¶");
        return false;
    }
    
    // æ£€æŸ¥æ˜¯å¦è·å¾—é”
    private boolean checkLockAcquired(String lockNode) throws Exception {
        List<String> children = zk.getChildren(lockPath, false);
        Collections.sort(children);
        
        // å¦‚æœå½“å‰èŠ‚ç‚¹æ˜¯ç¬¬ä¸€ä¸ªï¼Œåˆ™è·å¾—é”
        String nodeName = lockNode.substring(lockNode.lastIndexOf("/") + 1);
        return children.get(0).equals(nodeName);
    }
    
    // ç­‰å¾…é”é‡Šæ”¾
    private boolean waitForLock(String lockNode, long waitTime) throws Exception {
        if (waitTime <= 0) {
            return false;
        }
        
        List<String> children = zk.getChildren(lockPath, false);
        Collections.sort(children);
        
        String nodeName = lockNode.substring(lockNode.lastIndexOf("/") + 1);
        int index = children.indexOf(nodeName);
        
        if (index <= 0) {
            return true; // å·²ç»æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
        }
        
        // ç›‘å¬å‰ä¸€ä¸ªèŠ‚ç‚¹çš„åˆ é™¤äº‹ä»¶
        String previousNode = lockPath + "/" + children.get(index - 1);
        
        CountDownLatch nodeDeletedSignal = new CountDownLatch(1);
        Watcher watcher = new Watcher() {
            @Override
            public void process(WatchedEvent event) {
                if (event.getType() == Event.EventType.NodeDeleted) {
                    nodeDeletedSignal.countDown();
                }
            }
        };
        
        // æ£€æŸ¥å‰ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦è¿˜å­˜åœ¨
        if (zk.exists(previousNode, watcher) == null) {
            return true; // å‰ä¸€ä¸ªèŠ‚ç‚¹å·²è¢«åˆ é™¤
        }
        
        // ç­‰å¾…å‰ä¸€ä¸ªèŠ‚ç‚¹è¢«åˆ é™¤
        return nodeDeletedSignal.await(waitTime, TimeUnit.MILLISECONDS);
    }
    
    // é‡Šæ”¾é”
    public void releaseLock() throws Exception {
        if (isLocked && lockNode != null) {
            try {
                zk.delete(lockNode, -1);
                isLocked = false;
                lockNode = null;
                System.out.println("é”å·²é‡Šæ”¾");
            } catch (KeeperException.NoNodeException e) {
                // èŠ‚ç‚¹å·²è¢«åˆ é™¤ï¼Œå¿½ç•¥å¼‚å¸¸
            }
        }
    }
    
    public boolean isLocked() {
        return isLocked;
    }
}
```

### 2. å¯é‡å…¥åˆ†å¸ƒå¼é”
```java
public class ReentrantDistributedLock {
    private ZooKeeper zk;
    private String lockPath;
    private String lockNode;
    private ThreadLocal<Integer> lockCount = new ThreadLocal<>();
    private ThreadLocal<String> lockOwner = new ThreadLocal<>();
    
    public ReentrantDistributedLock(ZooKeeper zk, String lockPath) {
        this.zk = zk;
        this.lockPath = lockPath;
    }
    
    // è·å–é”
    public boolean acquireLock(long timeout) throws Exception {
        Thread currentThread = Thread.currentThread();
        
        // æ£€æŸ¥æ˜¯å¦å·²ç»æŒæœ‰é”
        if (currentThread.equals(lockOwner.get())) {
            int count = lockCount.get() != null ? lockCount.get() : 0;
            lockCount.set(count + 1);
            System.out.println("é‡å…¥é”ï¼Œå½“å‰è®¡æ•°: " + (count + 1));
            return true;
        }
        
        long startTime = System.currentTimeMillis();
        
        try {
            // åˆ›å»ºä¸´æ—¶é¡ºåºèŠ‚ç‚¹
            lockNode = zk.create(lockPath + "/lock-", currentThread.getName().getBytes(),
                               ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
            
            // æ£€æŸ¥æ˜¯å¦è·å¾—é”
            if (checkLockAcquired(lockNode)) {
                lockOwner.set(currentThread);
                lockCount.set(1);
                System.out.println("æˆåŠŸè·å–é”: " + lockNode);
                return true;
            }
            
            // ç­‰å¾…é”é‡Šæ”¾
            if (waitForLock(lockNode, timeout - (System.currentTimeMillis() - startTime))) {
                lockOwner.set(currentThread);
                lockCount.set(1);
                System.out.println("æˆåŠŸè·å–é”: " + lockNode);
                return true;
            }
            
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        System.out.println("è·å–é”è¶…æ—¶");
        return false;
    }
    
    // é‡Šæ”¾é”
    public void releaseLock() throws Exception {
        Thread currentThread = Thread.currentThread();
        
        if (!currentThread.equals(lockOwner.get())) {
            throw new IllegalMonitorStateException("å½“å‰çº¿ç¨‹æœªæŒæœ‰é”");
        }
        
        int count = lockCount.get() - 1;
        lockCount.set(count);
        
        if (count == 0) {
            // å®Œå…¨é‡Šæ”¾é”
            try {
                zk.delete(lockNode, -1);
                lockOwner.set(null);
                lockNode = null;
                System.out.println("é”å·²å®Œå…¨é‡Šæ”¾");
            } catch (KeeperException.NoNodeException e) {
                // èŠ‚ç‚¹å·²è¢«åˆ é™¤ï¼Œå¿½ç•¥å¼‚å¸¸
            }
        } else {
            System.out.println("é‡Šæ”¾é‡å…¥é”ï¼Œå‰©ä½™è®¡æ•°: " + count);
        }
    }
    
    // æ£€æŸ¥æ˜¯å¦è·å¾—é”ï¼ˆä¸FairDistributedLockç›¸åŒï¼‰
    private boolean checkLockAcquired(String lockNode) throws Exception {
        List<String> children = zk.getChildren(lockPath, false);
        Collections.sort(children);
        
        String nodeName = lockNode.substring(lockNode.lastIndexOf("/") + 1);
        return children.get(0).equals(nodeName);
    }
    
    // ç­‰å¾…é”é‡Šæ”¾ï¼ˆä¸FairDistributedLockç›¸åŒï¼‰
    private boolean waitForLock(String lockNode, long waitTime) throws Exception {
        // å®ç°ä¸FairDistributedLockç›¸åŒ
        // ... çœç•¥å®ç°ä»£ç 
        return false;
    }
    
    public boolean isLocked() {
        return lockOwner.get() != null;
    }
    
    public boolean isHeldByCurrentThread() {
        return Thread.currentThread().equals(lockOwner.get());
    }
}
```

## ğŸ”§ åˆ†å¸ƒå¼é”å·¥å…·ç±»

### 1. é”ç®¡ç†å™¨
```java
public class DistributedLockManager {
    private ZooKeeper zk;
    private Map<String, DistributedLock> locks = new ConcurrentHashMap<>();
    
    public DistributedLockManager(ZooKeeper zk) {
        this.zk = zk;
    }
    
    // è·å–é”
    public DistributedLock getLock(String lockName) {
        return locks.computeIfAbsent(lockName, name -> 
            new FairDistributedLock(zk, "/locks/" + name));
    }
    
    // é‡Šæ”¾æ‰€æœ‰é”
    public void releaseAllLocks() {
        locks.values().forEach(lock -> {
            try {
                if (lock.isLocked()) {
                    lock.releaseLock();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
        locks.clear();
    }
    
    // å…³é—­ç®¡ç†å™¨
    public void close() {
        releaseAllLocks();
    }
}
```

### 2. é”çš„è‡ªåŠ¨é‡Šæ”¾
```java
public class AutoReleaseLock implements AutoCloseable {
    private DistributedLock lock;
    
    public AutoReleaseLock(DistributedLock lock) {
        this.lock = lock;
    }
    
    @Override
    public void close() throws Exception {
        if (lock.isLocked()) {
            lock.releaseLock();
        }
    }
    
    public DistributedLock getLock() {
        return lock;
    }
}
```

## ğŸ’¡ ä½¿ç”¨ç¤ºä¾‹

### 1. åŸºæœ¬ä½¿ç”¨
```java
public class LockUsageExample {
    public static void main(String[] args) {
        try {
            ZooKeeper zk = new ZooKeeper("localhost:2181", 5000, null);
            DistributedLockManager lockManager = new DistributedLockManager(zk);
            
            // è·å–é”
            DistributedLock lock = lockManager.getLock("order-lock");
            
            if (lock.acquireLock(5000)) {
                try {
                    System.out.println("æ‰§è¡Œä¸šåŠ¡é€»è¾‘...");
                    Thread.sleep(2000);
                } finally {
                    lock.releaseLock();
                }
            }
            
            lockManager.close();
            zk.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 2. ä½¿ç”¨try-with-resources
```java
public class TryWithResourcesExample {
    public static void main(String[] args) {
        try {
            ZooKeeper zk = new ZooKeeper("localhost:2181", 5000, null);
            DistributedLockManager lockManager = new DistributedLockManager(zk);
            
            DistributedLock lock = lockManager.getLock("resource-lock");
            
            // ä½¿ç”¨try-with-resourcesè‡ªåŠ¨é‡Šæ”¾é”
            try (AutoReleaseLock autoLock = new AutoReleaseLock(lock)) {
                if (autoLock.getLock().acquireLock(5000)) {
                    System.out.println("æ‰§è¡Œä¸šåŠ¡é€»è¾‘...");
                    Thread.sleep(2000);
                }
            }
            
            lockManager.close();
            zk.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 3. å¤šé”ä½¿ç”¨
```java
public class MultiLockExample {
    public static void main(String[] args) {
        try {
            ZooKeeper zk = new ZooKeeper("localhost:2181", 5000, null);
            DistributedLockManager lockManager = new DistributedLockManager(zk);
            
            // è·å–å¤šä¸ªé”
            DistributedLock orderLock = lockManager.getLock("order-lock");
            DistributedLock inventoryLock = lockManager.getLock("inventory-lock");
            
            // æŒ‰é¡ºåºè·å–é”ï¼Œé¿å…æ­»é”
            if (orderLock.acquireLock(5000)) {
                try {
                    if (inventoryLock.acquireLock(5000)) {
                        try {
                            System.out.println("æ‰§è¡Œè®¢å•å’Œåº“å­˜æ“ä½œ...");
                            Thread.sleep(2000);
                        } finally {
                            inventoryLock.releaseLock();
                        }
                    }
                } finally {
                    orderLock.releaseLock();
                }
            }
            
            lockManager.close();
            zk.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## ğŸš¨ æ³¨æ„äº‹é¡¹

### 1. é”çš„ç²’åº¦
- **ç»†ç²’åº¦é”**ï¼šæé«˜å¹¶å‘æ€§ï¼Œä½†å¢åŠ é”ç®¡ç†å¤æ‚åº¦
- **ç²—ç²’åº¦é”**ï¼šç®€åŒ–ç®¡ç†ï¼Œä½†é™ä½å¹¶å‘æ€§
- **æ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©åˆé€‚çš„é”ç²’åº¦**

### 2. è¶…æ—¶è®¾ç½®
- **è·å–é”è¶…æ—¶**ï¼šé¿å…æ— é™ç­‰å¾…
- **ä¼šè¯è¶…æ—¶**ï¼šç¡®ä¿é”èƒ½åŠæ—¶é‡Šæ”¾
- **åˆç†è®¾ç½®è¶…æ—¶æ—¶é—´**

### 3. å¼‚å¸¸å¤„ç†
- **ç½‘ç»œå¼‚å¸¸**ï¼šå®ç°é‡è¯•æœºåˆ¶
- **èŠ‚ç‚¹åˆ é™¤å¼‚å¸¸**ï¼šå¿½ç•¥å·²åˆ é™¤èŠ‚ç‚¹çš„å¼‚å¸¸
- **ä¼šè¯è¿‡æœŸ**ï¼šé‡æ–°å»ºç«‹è¿æ¥

### 4. æ€§èƒ½ä¼˜åŒ–
- **å‡å°‘é”ç«äº‰**ï¼šä½¿ç”¨è¯»å†™é”åˆ†ç¦»
- **æ‰¹é‡æ“ä½œ**ï¼šå‡å°‘é”çš„è·å–æ¬¡æ•°
- **å¼‚æ­¥å¤„ç†**ï¼šæé«˜å“åº”æ€§èƒ½

## ğŸ”— ä¸‹ä¸€æ­¥å­¦ä¹ 

- [é…ç½®ä¸­å¿ƒå®ç°](./08.é…ç½®ä¸­å¿ƒå®ç°.md) - å­¦ä¹ é…ç½®ç®¡ç†
- [æœåŠ¡å‘ç°å®ç°](./09.æœåŠ¡å‘ç°å®ç°.md) - å­¦ä¹ æœåŠ¡å‘ç°
- [é¢è¯•é¢˜é›†é”¦](./10.é¢è¯•é¢˜é›†é”¦.md) - å‡†å¤‡é¢è¯•

---

**è®°ä½ï¼šåˆ†å¸ƒå¼é”æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿçš„åŸºç¡€ç»„ä»¶ï¼ŒæŒæ¡å®ƒå°±èƒ½è§£å†³å¾ˆå¤šå¹¶å‘é—®é¢˜ï¼** ğŸ¯
