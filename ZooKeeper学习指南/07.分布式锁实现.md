# 分布式锁实现

## 🔒 分布式锁概述

分布式锁是分布式系统中的重要组件，用于协调多个进程或服务对共享资源的访问。

### 1. 分布式锁的特性
- **互斥性**：同一时刻只能有一个客户端持有锁
- **防死锁**：即使持有锁的客户端崩溃，锁也能被释放
- **可重入性**：同一个客户端可以多次获取同一把锁
- **公平性**：按照请求顺序获取锁

### 2. ZooKeeper实现分布式锁的优势
- **自动释放**：临时节点在会话结束时自动删除
- **顺序保证**：顺序节点保证获取锁的公平性
- **强一致性**：ZAB协议保证数据一致性
- **高可用性**：集群部署保证服务可用性

## 🏗️ 基础分布式锁实现

### 1. 简单分布式锁
```java
public class SimpleDistributedLock {
    private ZooKeeper zk;
    private String lockPath;
    private String lockNode;
    private boolean isLocked = false;
    
    public SimpleDistributedLock(ZooKeeper zk, String lockPath) {
        this.zk = zk;
        this.lockPath = lockPath;
    }
    
    // 获取锁
    public boolean acquireLock(long timeout) throws Exception {
        long startTime = System.currentTimeMillis();
        
        while (System.currentTimeMillis() - startTime < timeout) {
            try {
                // 创建临时节点作为锁
                lockNode = zk.create(lockPath + "/lock-", "locked".getBytes(),
                                   ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
                isLocked = true;
                System.out.println("成功获取锁: " + lockNode);
                return true;
            } catch (KeeperException.NodeExistsException e) {
                // 锁已被其他客户端持有，等待一段时间后重试
                Thread.sleep(100);
            }
        }
        
        System.out.println("获取锁超时");
        return false;
    }
    
    // 释放锁
    public void releaseLock() throws Exception {
        if (isLocked && lockNode != null) {
            try {
                zk.delete(lockNode, -1);
                isLocked = false;
                lockNode = null;
                System.out.println("锁已释放");
            } catch (KeeperException.NoNodeException e) {
                // 节点已被删除，忽略异常
            }
        }
    }
    
    public boolean isLocked() {
        return isLocked;
    }
}
```

### 2. 使用示例
```java
public class LockExample {
    public static void main(String[] args) {
        try {
            ZooKeeper zk = new ZooKeeper("localhost:2181", 5000, null);
            SimpleDistributedLock lock = new SimpleDistributedLock(zk, "/locks");
            
            // 获取锁
            if (lock.acquireLock(5000)) {
                try {
                    System.out.println("执行业务逻辑...");
                    Thread.sleep(2000);
                } finally {
                    // 释放锁
                    lock.releaseLock();
                }
            }
            
            zk.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## 🚀 高级分布式锁实现

### 1. 公平分布式锁（基于顺序节点）
```java
public class FairDistributedLock {
    private ZooKeeper zk;
    private String lockPath;
    private String lockNode;
    private boolean isLocked = false;
    private CountDownLatch lockAcquiredSignal = new CountDownLatch(1);
    
    public FairDistributedLock(ZooKeeper zk, String lockPath) {
        this.zk = zk;
        this.lockPath = lockPath;
    }
    
    // 获取锁
    public boolean acquireLock(long timeout) throws Exception {
        long startTime = System.currentTimeMillis();
        
        try {
            // 创建临时顺序节点
            lockNode = zk.create(lockPath + "/lock-", "locked".getBytes(),
                               ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
            
            // 检查是否获得锁
            if (checkLockAcquired(lockNode)) {
                isLocked = true;
                System.out.println("成功获取锁: " + lockNode);
                return true;
            }
            
            // 等待锁释放
            if (waitForLock(lockNode, timeout - (System.currentTimeMillis() - startTime))) {
                isLocked = true;
                System.out.println("成功获取锁: " + lockNode);
                return true;
            }
            
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        System.out.println("获取锁超时");
        return false;
    }
    
    // 检查是否获得锁
    private boolean checkLockAcquired(String lockNode) throws Exception {
        List<String> children = zk.getChildren(lockPath, false);
        Collections.sort(children);
        
        // 如果当前节点是第一个，则获得锁
        String nodeName = lockNode.substring(lockNode.lastIndexOf("/") + 1);
        return children.get(0).equals(nodeName);
    }
    
    // 等待锁释放
    private boolean waitForLock(String lockNode, long waitTime) throws Exception {
        if (waitTime <= 0) {
            return false;
        }
        
        List<String> children = zk.getChildren(lockPath, false);
        Collections.sort(children);
        
        String nodeName = lockNode.substring(lockNode.lastIndexOf("/") + 1);
        int index = children.indexOf(nodeName);
        
        if (index <= 0) {
            return true; // 已经是第一个节点
        }
        
        // 监听前一个节点的删除事件
        String previousNode = lockPath + "/" + children.get(index - 1);
        
        CountDownLatch nodeDeletedSignal = new CountDownLatch(1);
        Watcher watcher = new Watcher() {
            @Override
            public void process(WatchedEvent event) {
                if (event.getType() == Event.EventType.NodeDeleted) {
                    nodeDeletedSignal.countDown();
                }
            }
        };
        
        // 检查前一个节点是否还存在
        if (zk.exists(previousNode, watcher) == null) {
            return true; // 前一个节点已被删除
        }
        
        // 等待前一个节点被删除
        return nodeDeletedSignal.await(waitTime, TimeUnit.MILLISECONDS);
    }
    
    // 释放锁
    public void releaseLock() throws Exception {
        if (isLocked && lockNode != null) {
            try {
                zk.delete(lockNode, -1);
                isLocked = false;
                lockNode = null;
                System.out.println("锁已释放");
            } catch (KeeperException.NoNodeException e) {
                // 节点已被删除，忽略异常
            }
        }
    }
    
    public boolean isLocked() {
        return isLocked;
    }
}
```

### 2. 可重入分布式锁
```java
public class ReentrantDistributedLock {
    private ZooKeeper zk;
    private String lockPath;
    private String lockNode;
    private ThreadLocal<Integer> lockCount = new ThreadLocal<>();
    private ThreadLocal<String> lockOwner = new ThreadLocal<>();
    
    public ReentrantDistributedLock(ZooKeeper zk, String lockPath) {
        this.zk = zk;
        this.lockPath = lockPath;
    }
    
    // 获取锁
    public boolean acquireLock(long timeout) throws Exception {
        Thread currentThread = Thread.currentThread();
        
        // 检查是否已经持有锁
        if (currentThread.equals(lockOwner.get())) {
            int count = lockCount.get() != null ? lockCount.get() : 0;
            lockCount.set(count + 1);
            System.out.println("重入锁，当前计数: " + (count + 1));
            return true;
        }
        
        long startTime = System.currentTimeMillis();
        
        try {
            // 创建临时顺序节点
            lockNode = zk.create(lockPath + "/lock-", currentThread.getName().getBytes(),
                               ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
            
            // 检查是否获得锁
            if (checkLockAcquired(lockNode)) {
                lockOwner.set(currentThread);
                lockCount.set(1);
                System.out.println("成功获取锁: " + lockNode);
                return true;
            }
            
            // 等待锁释放
            if (waitForLock(lockNode, timeout - (System.currentTimeMillis() - startTime))) {
                lockOwner.set(currentThread);
                lockCount.set(1);
                System.out.println("成功获取锁: " + lockNode);
                return true;
            }
            
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        System.out.println("获取锁超时");
        return false;
    }
    
    // 释放锁
    public void releaseLock() throws Exception {
        Thread currentThread = Thread.currentThread();
        
        if (!currentThread.equals(lockOwner.get())) {
            throw new IllegalMonitorStateException("当前线程未持有锁");
        }
        
        int count = lockCount.get() - 1;
        lockCount.set(count);
        
        if (count == 0) {
            // 完全释放锁
            try {
                zk.delete(lockNode, -1);
                lockOwner.set(null);
                lockNode = null;
                System.out.println("锁已完全释放");
            } catch (KeeperException.NoNodeException e) {
                // 节点已被删除，忽略异常
            }
        } else {
            System.out.println("释放重入锁，剩余计数: " + count);
        }
    }
    
    // 检查是否获得锁（与FairDistributedLock相同）
    private boolean checkLockAcquired(String lockNode) throws Exception {
        List<String> children = zk.getChildren(lockPath, false);
        Collections.sort(children);
        
        String nodeName = lockNode.substring(lockNode.lastIndexOf("/") + 1);
        return children.get(0).equals(nodeName);
    }
    
    // 等待锁释放（与FairDistributedLock相同）
    private boolean waitForLock(String lockNode, long waitTime) throws Exception {
        // 实现与FairDistributedLock相同
        // ... 省略实现代码
        return false;
    }
    
    public boolean isLocked() {
        return lockOwner.get() != null;
    }
    
    public boolean isHeldByCurrentThread() {
        return Thread.currentThread().equals(lockOwner.get());
    }
}
```

## 🔧 分布式锁工具类

### 1. 锁管理器
```java
public class DistributedLockManager {
    private ZooKeeper zk;
    private Map<String, DistributedLock> locks = new ConcurrentHashMap<>();
    
    public DistributedLockManager(ZooKeeper zk) {
        this.zk = zk;
    }
    
    // 获取锁
    public DistributedLock getLock(String lockName) {
        return locks.computeIfAbsent(lockName, name -> 
            new FairDistributedLock(zk, "/locks/" + name));
    }
    
    // 释放所有锁
    public void releaseAllLocks() {
        locks.values().forEach(lock -> {
            try {
                if (lock.isLocked()) {
                    lock.releaseLock();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
        locks.clear();
    }
    
    // 关闭管理器
    public void close() {
        releaseAllLocks();
    }
}
```

### 2. 锁的自动释放
```java
public class AutoReleaseLock implements AutoCloseable {
    private DistributedLock lock;
    
    public AutoReleaseLock(DistributedLock lock) {
        this.lock = lock;
    }
    
    @Override
    public void close() throws Exception {
        if (lock.isLocked()) {
            lock.releaseLock();
        }
    }
    
    public DistributedLock getLock() {
        return lock;
    }
}
```

## 💡 使用示例

### 1. 基本使用
```java
public class LockUsageExample {
    public static void main(String[] args) {
        try {
            ZooKeeper zk = new ZooKeeper("localhost:2181", 5000, null);
            DistributedLockManager lockManager = new DistributedLockManager(zk);
            
            // 获取锁
            DistributedLock lock = lockManager.getLock("order-lock");
            
            if (lock.acquireLock(5000)) {
                try {
                    System.out.println("执行业务逻辑...");
                    Thread.sleep(2000);
                } finally {
                    lock.releaseLock();
                }
            }
            
            lockManager.close();
            zk.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 2. 使用try-with-resources
```java
public class TryWithResourcesExample {
    public static void main(String[] args) {
        try {
            ZooKeeper zk = new ZooKeeper("localhost:2181", 5000, null);
            DistributedLockManager lockManager = new DistributedLockManager(zk);
            
            DistributedLock lock = lockManager.getLock("resource-lock");
            
            // 使用try-with-resources自动释放锁
            try (AutoReleaseLock autoLock = new AutoReleaseLock(lock)) {
                if (autoLock.getLock().acquireLock(5000)) {
                    System.out.println("执行业务逻辑...");
                    Thread.sleep(2000);
                }
            }
            
            lockManager.close();
            zk.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 3. 多锁使用
```java
public class MultiLockExample {
    public static void main(String[] args) {
        try {
            ZooKeeper zk = new ZooKeeper("localhost:2181", 5000, null);
            DistributedLockManager lockManager = new DistributedLockManager(zk);
            
            // 获取多个锁
            DistributedLock orderLock = lockManager.getLock("order-lock");
            DistributedLock inventoryLock = lockManager.getLock("inventory-lock");
            
            // 按顺序获取锁，避免死锁
            if (orderLock.acquireLock(5000)) {
                try {
                    if (inventoryLock.acquireLock(5000)) {
                        try {
                            System.out.println("执行订单和库存操作...");
                            Thread.sleep(2000);
                        } finally {
                            inventoryLock.releaseLock();
                        }
                    }
                } finally {
                    orderLock.releaseLock();
                }
            }
            
            lockManager.close();
            zk.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## 🚨 注意事项

### 1. 锁的粒度
- **细粒度锁**：提高并发性，但增加锁管理复杂度
- **粗粒度锁**：简化管理，但降低并发性
- **根据业务需求选择合适的锁粒度**

### 2. 超时设置
- **获取锁超时**：避免无限等待
- **会话超时**：确保锁能及时释放
- **合理设置超时时间**

### 3. 异常处理
- **网络异常**：实现重试机制
- **节点删除异常**：忽略已删除节点的异常
- **会话过期**：重新建立连接

### 4. 性能优化
- **减少锁竞争**：使用读写锁分离
- **批量操作**：减少锁的获取次数
- **异步处理**：提高响应性能

## 🔗 下一步学习

- [配置中心实现](./08.配置中心实现.md) - 学习配置管理
- [服务发现实现](./09.服务发现实现.md) - 学习服务发现
- [面试题集锦](./10.面试题集锦.md) - 准备面试

---

**记住：分布式锁是分布式系统的基础组件，掌握它就能解决很多并发问题！** 🎯
