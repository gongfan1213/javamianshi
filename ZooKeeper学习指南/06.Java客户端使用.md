# Java 客户端使用

## 🚀 环境准备

### 1. Maven依赖
```xml
<dependency>
    <groupId>org.apache.zookeeper</groupId>
    <artifactId>zookeeper</artifactId>
    <version>3.8.0</version>
</dependency>

<!-- 如果需要连接池功能 -->
<dependency>
    <groupId>org.apache.curator</groupId>
    <artifactId>curator-framework</artifactId>
    <version>5.3.0</version>
</dependency>
```

### 2. Gradle依赖
```gradle
implementation 'org.apache.zookeeper:zookeeper:3.8.0'
implementation 'org.apache.curator:curator-framework:5.3.0'
```

## 🔌 基础连接

### 1. 创建连接
```java
import org.apache.zookeeper.*;
import java.util.concurrent.CountDownLatch;

public class ZooKeeperClient {
    private ZooKeeper zk;
    private CountDownLatch connectedSignal = new CountDownLatch(1);
    
    public void connect(String connectString) throws Exception {
        // 创建连接
        zk = new ZooKeeper(connectString, 5000, new Watcher() {
            @Override
            public void process(WatchedEvent event) {
                if (event.getState() == Event.KeeperState.SyncConnected) {
                    connectedSignal.countDown();
                    System.out.println("连接成功！");
                }
            }
        });
        
        // 等待连接建立
        connectedSignal.await();
    }
    
    public void close() throws InterruptedException {
        if (zk != null) {
            zk.close();
        }
    }
}
```

### 2. 连接状态监听
```java
public class ConnectionWatcher implements Watcher {
    private CountDownLatch connectedSignal = new CountDownLatch(1);
    
    @Override
    public void process(WatchedEvent event) {
        System.out.println("收到事件: " + event.getType() + " - " + event.getState());
        
        switch (event.getState()) {
            case SyncConnected:
                System.out.println("连接建立成功");
                connectedSignal.countDown();
                break;
            case Disconnected:
                System.out.println("连接断开");
                break;
            case Expired:
                System.out.println("会话过期");
                break;
            case ConnectedReadOnly:
                System.out.println("只读连接");
                break;
            case AuthFailed:
                System.out.println("认证失败");
                break;
        }
    }
    
    public void waitForConnection() throws InterruptedException {
        connectedSignal.await();
    }
}
```

## 📝 基本操作

### 1. 创建节点
```java
public class NodeOperations {
    private ZooKeeper zk;
    
    public NodeOperations(ZooKeeper zk) {
        this.zk = zk;
    }
    
    // 创建持久节点
    public String createPersistentNode(String path, String data) throws Exception {
        return zk.create(path, data.getBytes(), 
                        ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
    }
    
    // 创建临时节点
    public String createEphemeralNode(String path, String data) throws Exception {
        return zk.create(path, data.getBytes(), 
                        ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
    }
    
    // 创建顺序节点
    public String createSequentialNode(String path, String data) throws Exception {
        return zk.create(path, data.getBytes(), 
                        ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);
    }
    
    // 创建临时顺序节点
    public String createEphemeralSequentialNode(String path, String data) throws Exception {
        return zk.create(path, data.getBytes(), 
                        ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
    }
}
```

### 2. 读取节点
```java
public class ReadOperations {
    private ZooKeeper zk;
    
    public ReadOperations(ZooKeeper zk) {
        this.zk = zk;
    }
    
    // 获取节点数据
    public String getNodeData(String path) throws Exception {
        byte[] data = zk.getData(path, false, null);
        return new String(data);
    }
    
    // 获取节点数据（带版本信息）
    public NodeData getNodeDataWithStat(String path) throws Exception {
        Stat stat = new Stat();
        byte[] data = zk.getData(path, false, stat);
        
        return new NodeData(
            new String(data),
            stat.getVersion(),
            stat.getCtime(),
            stat.getMtime()
        );
    }
    
    // 获取子节点列表
    public List<String> getChildren(String path) throws Exception {
        return zk.getChildren(path, false);
    }
    
    // 检查节点是否存在
    public boolean exists(String path) throws Exception {
        return zk.exists(path, false) != null;
    }
    
    // 获取节点状态信息
    public Stat getStat(String path) throws Exception {
        return zk.exists(path, false);
    }
}

// 节点数据包装类
public class NodeData {
    private String data;
    private int version;
    private long createTime;
    private long modifyTime;
    
    // 构造函数、getter、setter...
}
```

### 3. 更新节点
```java
public class UpdateOperations {
    private ZooKeeper zk;
    
    public UpdateOperations(ZooKeeper zk) {
        this.zk = zk;
    }
    
    // 更新节点数据
    public Stat updateNodeData(String path, String newData) throws Exception {
        return zk.setData(path, newData.getBytes(), -1);
    }
    
    // 条件更新（乐观锁）
    public boolean updateIfVersion(String path, String newData, int expectedVersion) {
        try {
            Stat stat = zk.setData(path, newData.getBytes(), expectedVersion);
            System.out.println("更新成功，新版本: " + stat.getVersion());
            return true;
        } catch (KeeperException.BadVersionException e) {
            System.out.println("版本冲突，更新失败");
            return false;
        } catch (Exception e) {
            System.out.println("更新失败: " + e.getMessage());
            return false;
        }
    }
    
    // 原子更新：只有当数据未被修改时才更新
    public boolean updateIfUnchanged(String path, String newData, String expectedData) {
        try {
            Stat stat = new Stat();
            byte[] currentData = zk.getData(path, false, stat);
            String current = new String(currentData);
            
            if (current.equals(expectedData)) {
                zk.setData(path, newData.getBytes(), stat.getVersion());
                return true;
            }
            return false;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }
}
```

### 4. 删除节点
```java
public class DeleteOperations {
    private ZooKeeper zk;
    
    public DeleteOperations(ZooKeeper zk) {
        this.zk = zk;
    }
    
    // 删除节点
    public void deleteNode(String path) throws Exception {
        zk.delete(path, -1);
    }
    
    // 条件删除
    public boolean deleteIfVersion(String path, int expectedVersion) {
        try {
            zk.delete(path, expectedVersion);
            return true;
        } catch (KeeperException.BadVersionException e) {
            System.out.println("版本冲突，删除失败");
            return false;
        } catch (Exception e) {
            System.out.println("删除失败: " + e.getMessage());
            return false;
        }
    }
    
    // 递归删除（删除节点及其所有子节点）
    public void deleteRecursively(String path) throws Exception {
        List<String> children = zk.getChildren(path, false);
        
        // 先删除子节点
        for (String child : children) {
            deleteRecursively(path + "/" + child);
        }
        
        // 再删除当前节点
        zk.delete(path, -1);
    }
}
```

## 👀 监听机制

### 1. 数据变化监听
```java
public class DataWatcher implements Watcher {
    private ZooKeeper zk;
    private String path;
    
    public DataWatcher(ZooKeeper zk, String path) {
        this.zk = zk;
        this.path = path;
    }
    
    @Override
    public void process(WatchedEvent event) {
        if (event.getType() == Event.EventType.NodeDataChanged) {
            System.out.println("节点数据发生变化: " + event.getPath());
            
            try {
                // 重新注册监听器
                zk.getData(path, this, null);
                
                // 处理数据变化
                handleDataChange();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    
    private void handleDataChange() throws Exception {
        String data = new String(zk.getData(path, false, null));
        System.out.println("新数据: " + data);
        
        // 在这里添加你的业务逻辑
        // 比如：更新本地缓存、通知其他组件等
    }
    
    // 开始监听
    public void startWatching() throws Exception {
        zk.getData(path, this, null);
    }
}
```

### 2. 子节点变化监听
```java
public class ChildrenWatcher implements Watcher {
    private ZooKeeper zk;
    private String path;
    
    public ChildrenWatcher(ZooKeeper zk, String path) {
        this.zk = zk;
        this.path = path;
    }
    
    @Override
    public void process(WatchedEvent event) {
        if (event.getType() == Event.EventType.NodeChildrenChanged) {
            System.out.println("子节点发生变化: " + event.getPath());
            
            try {
                // 重新注册监听器
                zk.getChildren(path, this);
                
                // 处理子节点变化
                handleChildrenChange();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    
    private void handleChildrenChange() throws Exception {
        List<String> children = zk.getChildren(path, false);
        System.out.println("当前子节点: " + children);
        
        // 在这里添加你的业务逻辑
        // 比如：服务发现、负载均衡等
    }
    
    // 开始监听
    public void startWatching() throws Exception {
        zk.getChildren(path, this);
    }
}
```

### 3. 节点存在性监听
```java
public class ExistsWatcher implements Watcher {
    private ZooKeeper zk;
    private String path;
    
    public ExistsWatcher(ZooKeeper zk, String path) {
        this.zk = zk;
        this.path = path;
    }
    
    @Override
    public void process(WatchedEvent event) {
        switch (event.getType()) {
            case NodeCreated:
                System.out.println("节点创建: " + event.getPath());
                handleNodeCreated();
                break;
            case NodeDeleted:
                System.out.println("节点删除: " + event.getPath());
                handleNodeDeleted();
                break;
            case NodeDataChanged:
                System.out.println("节点数据变化: " + event.getPath());
                handleNodeDataChanged();
                break;
        }
        
        // 重新注册监听器
        try {
            zk.exists(path, this);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    private void handleNodeCreated() {
        System.out.println("处理节点创建事件");
        // 添加你的业务逻辑
    }
    
    private void handleNodeDeleted() {
        System.out.println("处理节点删除事件");
        // 添加你的业务逻辑
    }
    
    private void handleNodeDataChanged() {
        System.out.println("处理节点数据变化事件");
        // 添加你的业务逻辑
    }
    
    // 开始监听
    public void startWatching() throws Exception {
        zk.exists(path, this);
    }
}
```

## 🔐 访问控制

### 1. 创建带ACL的节点
```java
public class ACLOperations {
    private ZooKeeper zk;
    
    public ACLOperations(ZooKeeper zk) {
        this.zk = zk;
    }
    
    // 创建只读节点
    public String createReadOnlyNode(String path, String data) throws Exception {
        List<ACL> acls = Arrays.asList(
            new ACL(ZooDefs.Perms.READ, new Id("world", "anyone"))
        );
        
        return zk.create(path, data.getBytes(), acls, CreateMode.PERSISTENT);
    }
    
    // 创建带用户名密码的节点
    public String createSecureNode(String path, String data, String username, String password) throws Exception {
        String auth = username + ":" + password;
        List<ACL> acls = Arrays.asList(
            new ACL(ZooDefs.Perms.ALL, new Id("digest", auth))
        );
        
        return zk.create(path, data.getBytes(), acls, CreateMode.PERSISTENT);
    }
    
    // 创建IP限制的节点
    public String createIPRestrictedNode(String path, String data, String ip) throws Exception {
        List<ACL> acls = Arrays.asList(
            new ACL(ZooDefs.Perms.ALL, new Id("ip", ip))
        );
        
        return zk.create(path, data.getBytes(), acls, CreateMode.PERSISTENT);
    }
}
```

### 2. 认证
```java
public class AuthenticationOperations {
    private ZooKeeper zk;
    
    public AuthenticationOperations(ZooKeeper zk) {
        this.zk = zk;
    }
    
    // 添加认证信息
    public void addAuth(String scheme, String auth) throws Exception {
        zk.addAuthInfo(scheme, auth.getBytes());
    }
    
    // 添加用户名密码认证
    public void addDigestAuth(String username, String password) throws Exception {
        String auth = username + ":" + password;
        zk.addAuthInfo("digest", auth.getBytes());
    }
    
    // 添加IP认证
    public void addIPAuth(String ip) throws Exception {
        zk.addAuthInfo("ip", ip.getBytes());
    }
}
```

## 🚀 高级功能

### 1. 批量操作
```java
public class BatchOperations {
    private ZooKeeper zk;
    
    public BatchOperations(ZooKeeper zk) {
        this.zk = zk;
    }
    
    // 批量创建节点
    public List<OpResult> batchCreateNodes(String parentPath, List<String> nodeNames) throws Exception {
        List<Op> operations = new ArrayList<>();
        
        for (String nodeName : nodeNames) {
            String path = parentPath + "/" + nodeName;
            Op createOp = Op.create(path, "data".getBytes(), 
                                   ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
            operations.add(createOp);
        }
        
        return zk.multi(operations);
    }
    
    // 批量更新节点
    public List<OpResult> batchUpdateNodes(Map<String, String> pathDataMap) throws Exception {
        List<Op> operations = new ArrayList<>();
        
        for (Map.Entry<String, String> entry : pathDataMap.entrySet()) {
            Op setDataOp = Op.setData(entry.getKey(), entry.getValue().getBytes(), -1);
            operations.add(setDataOp);
        }
        
        return zk.multi(operations);
    }
    
    // 批量删除节点
    public List<OpResult> batchDeleteNodes(List<String> paths) throws Exception {
        List<Op> operations = new ArrayList<>();
        
        for (String path : paths) {
            Op deleteOp = Op.delete(path, -1);
            operations.add(deleteOp);
        }
        
        return zk.multi(operations);
    }
}
```

### 2. 异步操作
```java
public class AsyncOperations {
    private ZooKeeper zk;
    
    public AsyncOperations(ZooKeeper zk) {
        this.zk = zk;
    }
    
    // 异步创建节点
    public void createNodeAsync(String path, String data) {
        zk.create(path, data.getBytes(), 
                  ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT,
                  new AsyncCallback.StringCallback() {
                      @Override
                      public void processResult(int rc, String path, Object ctx, String name) {
                          if (rc == KeeperException.Code.OK.intValue()) {
                              System.out.println("异步创建成功: " + name);
                          } else {
                              System.out.println("异步创建失败: " + KeeperException.Code.get(rc));
                          }
                      }
                  }, "context-data");
    }
    
    // 异步获取数据
    public void getDataAsync(String path) {
        zk.getData(path, false, new AsyncCallback.DataCallback() {
            @Override
            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {
                if (rc == KeeperException.Code.OK.intValue()) {
                    String content = new String(data);
                    System.out.println("异步获取数据成功: " + content);
                } else {
                    System.out.println("异步获取数据失败: " + KeeperException.Code.get(rc));
                }
            }
        }, "context-data");
    }
}
```

## 💡 最佳实践

### 1. 连接管理
```java
public class ZooKeeperManager {
    private static final String CONNECT_STRING = "localhost:2181";
    private static final int SESSION_TIMEOUT = 5000;
    private static final int CONNECTION_TIMEOUT = 10000;
    
    private ZooKeeper zk;
    private volatile boolean isConnected = false;
    
    public ZooKeeper connect() throws Exception {
        CountDownLatch connectedSignal = new CountDownLatch(1);
        
        zk = new ZooKeeper(CONNECT_STRING, SESSION_TIMEOUT, new Watcher() {
            @Override
            public void process(WatchedEvent event) {
                if (event.getState() == Event.KeeperState.SyncConnected) {
                    isConnected = true;
                    connectedSignal.countDown();
                } else if (event.getState() == Event.KeeperState.Disconnected) {
                    isConnected = false;
                } else if (event.getState() == Event.KeeperState.Expired) {
                    isConnected = false;
                    // 重新连接逻辑
                    reconnect();
                }
            }
        });
        
        if (!connectedSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {
            throw new RuntimeException("连接超时");
        }
        
        return zk;
    }
    
    private void reconnect() {
        // 实现重连逻辑
        try {
            Thread.sleep(1000);
            connect();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public boolean isConnected() {
        return isConnected && zk != null && zk.getState() == ZooKeeper.States.CONNECTED;
    }
    
    public void close() throws InterruptedException {
        if (zk != null) {
            zk.close();
        }
    }
}
```

### 2. 异常处理
```java
public class ZooKeeperExceptionHandler {
    
    public static void handleException(Exception e) {
        if (e instanceof KeeperException.NoNodeException) {
            System.out.println("节点不存在");
        } else if (e instanceof KeeperException.NodeExistsException) {
            System.out.println("节点已存在");
        } else if (e instanceof KeeperException.BadVersionException) {
            System.out.println("版本冲突");
        } else if (e instanceof KeeperException.ConnectionLossException) {
            System.out.println("连接丢失");
        } else if (e instanceof KeeperException.SessionExpiredException) {
            System.out.println("会话过期");
        } else {
            System.out.println("其他异常: " + e.getMessage());
        }
    }
    
    public static boolean isRetryableException(Exception e) {
        return e instanceof KeeperException.ConnectionLossException ||
               e instanceof KeeperException.SessionExpiredException;
    }
}
```

## 🔗 下一步学习

- [分布式锁实现](./07.分布式锁实现.md) - 实践应用
- [配置中心实现](./08.配置中心实现.md) - 学习配置管理
- [服务发现实现](./09.服务发现实现.md) - 学习服务发现

---

**记住：Java客户端是使用ZooKeeper的核心，掌握API就能实现各种分布式功能！** 🎯
