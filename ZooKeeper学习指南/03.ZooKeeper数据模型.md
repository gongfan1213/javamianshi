# ZooKeeper 数据模型

## 🌳 层次命名空间

ZooKeeper的数据模型类似于文件系统的目录树结构，每个节点称为ZNode（ZooKeeper Node）。

```
/
├── app1/
│   ├── config/
│   │   ├── database.properties
│   │   └── redis.properties
│   ├── services/
│   │   ├── user-service
│   │   └── order-service
│   └── locks/
│       └── distributed-lock
├── app2/
│   └── config/
└── global/
    ├── cluster-info
    └── system-status
```

## 📝 ZNode结构详解

### 1. ZNode组成
每个ZNode包含以下信息：
- **数据内容**：字节数组，最大1MB
- **元数据**：版本号、创建时间、修改时间等
- **子节点列表**：指向子节点的引用

### 2. ZNode类型

#### 持久节点（Persistent）
```bash
# 创建持久节点
create /app/config "database.properties"

# 特点：
# - 创建后永久存在
# - 除非手动删除
# - 适合存储配置信息
```

#### 临时节点（Ephemeral）
```bash
# 创建临时节点
create -e /app/services/user-service "192.168.1.100:8080"

# 特点：
# - 会话结束时自动删除
# - 适合服务注册
# - 用于故障检测
```

#### 顺序节点（Sequential）
```bash
# 创建顺序节点
create -s /app/locks/lock- "lock-data"

# 结果：/app/locks/lock-0000000001
# 特点：
# - 自动添加递增序号
# - 保证创建顺序
# - 适合实现分布式锁
```

#### 临时顺序节点（Ephemeral Sequential）
```bash
# 创建临时顺序节点
create -e -s /app/locks/lock- "lock-data"

# 特点：
# - 临时节点 + 顺序节点
# - 会话结束时自动删除
# - 适合实现公平的分布式锁
```

## 🔍 节点属性详解

### 1. 查看节点详细信息
```bash
# 获取节点详细信息
stat /app/config

# 输出示例：
cZxid = 0x100000001
ctime = Mon Jan 01 00:00:00 CST 2024
mZxid = 0x100000001
mtime = Mon Jan 01 00:00:00 CST 2024
pZxid = 0x100000001
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 20
numChildren = 0
```

### 2. 属性字段说明
- **cZxid**：创建节点的事务ID
- **ctime**：创建时间
- **mZxid**：最后修改的事务ID
- **mtime**：最后修改时间
- **pZxid**：最后修改子节点的事务ID
- **cversion**：子节点版本号
- **dataVersion**：数据版本号
- **aclVersion**：ACL版本号
- **ephemeralOwner**：临时节点所有者会话ID
- **dataLength**：数据长度
- **numChildren**：子节点数量

## 🚀 数据操作API

### 1. 创建节点
```java
// 创建持久节点
String path = zk.create("/app/config", "database.properties".getBytes(), 
                       ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);

// 创建临时节点
String path = zk.create("/app/services/user-service", "192.168.1.100:8080".getBytes(),
                       ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);

// 创建顺序节点
String path = zk.create("/app/locks/lock-", "lock-data".getBytes(),
                       ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);
```

### 2. 读取节点
```java
// 获取节点数据
byte[] data = zk.getData("/app/config", false, null);
String content = new String(data);

// 获取节点状态信息
Stat stat = new Stat();
byte[] data = zk.getData("/app/config", false, stat);
System.out.println("数据版本: " + stat.getVersion());
System.out.println("子节点数量: " + stat.getNumChildren());
```

### 3. 更新节点
```java
// 更新节点数据
Stat stat = zk.setData("/app/config", "updated-config".getBytes(), -1);

// 条件更新（乐观锁）
Stat stat = zk.setData("/app/config", "new-config".getBytes(), stat.getVersion());
```

### 4. 删除节点
```java
// 删除节点（只能删除没有子节点的节点）
zk.delete("/app/config", -1);

// 条件删除
zk.delete("/app/config", stat.getVersion());
```

### 5. 列出子节点
```java
// 获取子节点列表
List<String> children = zk.getChildren("/app", false);
for (String child : children) {
    System.out.println("子节点: " + child);
}
```

## 👀 监听机制（Watcher）

### 1. 监听节点数据变化
```java
// 监听节点数据变化
Watcher dataWatcher = new Watcher() {
    public void process(WatchedEvent event) {
        if (event.getType() == Event.EventType.NodeDataChanged) {
            System.out.println("节点数据发生变化: " + event.getPath());
            // 重新注册监听器
            try {
                zk.getData(event.getPath(), this, null);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
};

// 注册监听器
zk.getData("/app/config", dataWatcher, null);
```

### 2. 监听子节点变化
```java
// 监听子节点变化
Watcher childrenWatcher = new Watcher() {
    public void process(WatchedEvent event) {
        if (event.getType() == Event.EventType.NodeChildrenChanged) {
            System.out.println("子节点发生变化: " + event.getPath());
            // 重新注册监听器
            try {
                zk.getChildren(event.getPath(), this);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
};

// 注册监听器
zk.getChildren("/app", childrenWatcher);
```

### 3. 监听节点创建/删除
```java
// 监听节点创建/删除
Watcher existsWatcher = new Watcher() {
    public void process(WatchedEvent event) {
        switch (event.getType()) {
            case NodeCreated:
                System.out.println("节点创建: " + event.getPath());
                break;
            case NodeDeleted:
                System.out.println("节点删除: " + event.getPath());
                break;
        }
    }
};

// 注册监听器
zk.exists("/app/new-node", existsWatcher);
```

## 🔐 访问控制（ACL）

### 1. ACL权限类型
- **READ**：读取节点数据和子节点列表
- **WRITE**：设置节点数据
- **CREATE**：创建子节点
- **DELETE**：删除子节点
- **ADMIN**：设置ACL权限

### 2. ACL示例
```java
// 创建只读权限的节点
List<ACL> acls = Arrays.asList(new ACL(ZooDefs.Perms.READ, 
                                       new Id("world", "anyone")));
zk.create("/app/readonly", "readonly-data".getBytes(), acls, CreateMode.PERSISTENT);

// 创建带密码的节点
List<ACL> acls = Arrays.asList(new ACL(ZooDefs.Perms.ALL, 
                                       new Id("digest", "user:password")));
zk.create("/app/secure", "secure-data".getBytes(), acls, CreateMode.PERSISTENT);
```

## 💡 数据模型最佳实践

### 1. 节点设计原则
- **层次清晰**：使用有意义的路径结构
- **命名规范**：遵循统一的命名约定
- **数据大小**：单个节点数据不超过1MB
- **节点类型**：根据使用场景选择合适的节点类型

### 2. 监听器使用建议
- **及时重新注册**：监听器触发后需要重新注册
- **避免监听过多**：监听器过多会影响性能
- **处理异常情况**：监听器可能因为网络问题失效

### 3. 版本控制策略
- **乐观锁**：使用版本号进行条件更新
- **版本检查**：更新前检查版本号
- **冲突处理**：版本冲突时的重试策略

## 🔗 下一步学习

- [ZooKeeper核心特性](./04.ZooKeeper核心特性.md) - 学习核心功能
- [Java客户端使用](./06.Java客户端使用.md) - 开始Java编程
- [分布式锁实现](./07.分布式锁实现.md) - 实践应用

---

**记住：ZNode是ZooKeeper的核心概念，理解它就能掌握数据操作！** 🎯
