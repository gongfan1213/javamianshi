# ZooKeeper 核心特性

## 🎯 一致性保证

ZooKeeper提供强一致性保证，这是其最核心的特性。

### 1. 顺序一致性（Sequential Consistency）
```
┌─────────────────────────────────────────────────────────────┐
│                    顺序一致性保证                            │
├─────────────────────────────────────────────────────────────┤
│  客户端A: create /app/config → 成功                        │
│  客户端B: get /app/config → 能看到A创建的数据               │
│  客户端C: set /app/config → 基于A的数据进行更新             │
│  所有客户端看到的操作顺序一致                               │
└─────────────────────────────────────────────────────────────┘
```

**实现原理**：
- 全局单调递增的事务ID（zxid）
- 所有写操作按顺序执行
- 读操作能看到之前所有写操作的结果

### 2. 原子性（Atomicity）
```java
// 事务要么全部成功，要么全部失败
try {
    // 创建配置节点
    zk.create("/app/config", "config-data".getBytes(), 
               ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
    
    // 创建子节点
    zk.create("/app/config/database", "db-config".getBytes(),
               ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
    
    // 如果任何一步失败，整个操作回滚
} catch (Exception e) {
    // 原子性保证：要么全部成功，要么全部失败
    System.out.println("操作失败，需要回滚");
}
```

### 3. 单一系统映像（Single System Image）
```java
// 客户端连接到任意节点看到的数据一致
String connectString1 = "zk1:2181";
String connectString2 = "zk2:2181";

ZooKeeper zk1 = new ZooKeeper(connectString1, 5000, watcher);
ZooKeeper zk2 = new ZooKeeper(connectString2, 5000, watcher);

// 两个连接看到的数据完全一致
byte[] data1 = zk1.getData("/app/config", false, null);
byte[] data2 = zk2.getData("/app/config", false, null);

// data1 和 data2 内容完全相同
assert Arrays.equals(data1, data2);
```

## 🔄 会话管理

### 1. 会话生命周期
```java
// 创建会话
ZooKeeper zk = new ZooKeeper("localhost:2181", 5000, watcher);

// 会话状态监听
Watcher watcher = new Watcher() {
    public void process(WatchedEvent event) {
        switch (event.getState()) {
            case SyncConnected:
                System.out.println("会话建立成功");
                break;
            case Disconnected:
                System.out.println("会话断开");
                break;
            case Expired:
                System.out.println("会话过期，需要重新连接");
                break;
            case ConnectedReadOnly:
                System.out.println("只读连接");
                break;
        }
    }
};
```

### 2. 会话超时处理
```java
// 设置会话超时时间
int sessionTimeout = 10000; // 10秒
ZooKeeper zk = new ZooKeeper("localhost:2181", sessionTimeout, watcher);

// 会话过期后的处理
if (zk.getState() == ZooKeeper.States.EXPIRED) {
    // 重新创建连接
    zk = new ZooKeeper("localhost:2181", sessionTimeout, watcher);
}
```

### 3. 心跳机制
```java
// 定期发送心跳保持会话活跃
Timer heartbeatTimer = new Timer();
heartbeatTimer.scheduleAtFixedRate(new TimerTask() {
    @Override
    public void run() {
        try {
            // 执行一个轻量级操作保持会话活跃
            zk.exists("/heartbeat", false);
        } catch (Exception e) {
            System.out.println("心跳失败: " + e.getMessage());
        }
    }
}, 0, 5000); // 每5秒发送一次心跳
```

## 👀 监听机制（Watcher）

### 1. 一次性监听器
```java
// 一次性监听器，触发后自动失效
Watcher oneTimeWatcher = new Watcher() {
    public void process(WatchedEvent event) {
        System.out.println("节点变化: " + event.getPath());
        // 监听器触发后自动失效，不会再次触发
    }
};

// 注册监听器
zk.getData("/app/config", oneTimeWatcher, null);
```

### 2. 持久监听器
```java
// 持久监听器，需要手动重新注册
Watcher persistentWatcher = new Watcher() {
    public void process(WatchedEvent event) {
        System.out.println("节点变化: " + event.getPath());
        
        // 重新注册监听器以继续监听
        try {
            zk.getData(event.getPath(), this, null);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
};

// 注册监听器
zk.getData("/app/config", persistentWatcher, null);
```

### 3. 监听器类型
```java
// 监听节点数据变化
zk.getData("/app/config", dataWatcher, null);

// 监听子节点变化
zk.getChildren("/app", childrenWatcher);

// 监听节点存在性
zk.exists("/app/new-node", existsWatcher);
```

## 🔐 访问控制（ACL）

### 1. 内置ACL方案
```java
// 完全开放访问
List<ACL> openAcl = ZooDefs.Ids.OPEN_ACL_UNSAFE;

// 只读访问
List<ACL> readOnlyAcl = Arrays.asList(
    new ACL(ZooDefs.Perms.READ, new Id("world", "anyone"))
);

// 创建者完全控制
List<ACL> creatorAcl = ZooDefs.Ids.CREATOR_ALL_ACL;
```

### 2. 自定义ACL
```java
// 创建带用户名密码的ACL
List<ACL> customAcl = Arrays.asList(
    new ACL(ZooDefs.Perms.READ | ZooDefs.Perms.WRITE, 
            new Id("digest", "user:password"))
);

// 创建节点时使用自定义ACL
zk.create("/app/secure", "secure-data".getBytes(), customAcl, CreateMode.PERSISTENT);
```

### 3. ACL权限组合
```java
// 组合多种权限
int permissions = ZooDefs.Perms.READ |    // 读取权限
                 ZooDefs.Perms.WRITE |   // 写入权限
                 ZooDefs.Perms.CREATE;   // 创建权限

List<ACL> acls = Arrays.asList(
    new ACL(permissions, new Id("world", "anyone"))
);
```

## 📊 版本控制

### 1. 乐观锁机制
```java
// 获取当前版本
Stat stat = new Stat();
byte[] data = zk.getData("/app/config", false, stat);
int currentVersion = stat.getVersion();

// 基于版本号更新（乐观锁）
try {
    Stat newStat = zk.setData("/app/config", "new-data".getBytes(), currentVersion);
    System.out.println("更新成功，新版本: " + newStat.getVersion());
} catch (KeeperException.BadVersionException e) {
    System.out.println("版本冲突，数据已被其他客户端修改");
    // 重新获取数据并重试
}
```

### 2. 条件更新
```java
// 条件更新：只有当数据未被修改时才更新
public boolean updateIfUnchanged(String path, String newData, String expectedData) {
    try {
        Stat stat = new Stat();
        byte[] currentData = zk.getData(path, false, stat);
        String current = new String(currentData);
        
        if (current.equals(expectedData)) {
            zk.setData(path, newData.getBytes(), stat.getVersion());
            return true;
        }
        return false;
    } catch (Exception e) {
        e.printStackTrace();
        return false;
    }
}
```

## 🚀 高可用性

### 1. 自动故障转移
```java
// 配置多个ZooKeeper服务器
String connectString = "zk1:2181,zk2:2181,zk3:2181";
ZooKeeper zk = new ZooKeeper(connectString, 5000, watcher);

// 自动故障转移：如果zk1不可用，自动切换到zk2或zk3
```

### 2. 连接重试机制
```java
// 实现连接重试
public ZooKeeper connectWithRetry(String connectString, int timeout, int maxRetries) {
    for (int i = 0; i < maxRetries; i++) {
        try {
            ZooKeeper zk = new ZooKeeper(connectString, timeout, watcher);
            
            // 等待连接建立
            CountDownLatch connectedSignal = new CountDownLatch(1);
            Watcher connectionWatcher = new Watcher() {
                public void process(WatchedEvent event) {
                    if (event.getState() == Event.KeeperState.SyncConnected) {
                        connectedSignal.countDown();
                    }
                }
            };
            
            if (connectedSignal.await(10, TimeUnit.SECONDS)) {
                return zk;
            }
        } catch (Exception e) {
            System.out.println("连接失败，重试 " + (i + 1) + "/" + maxRetries);
            try {
                Thread.sleep(1000 * (i + 1)); // 递增延迟
            } catch (InterruptedException ie) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    throw new RuntimeException("无法连接到ZooKeeper");
}
```

## 💡 性能优化

### 1. 批量操作
```java
// 批量创建节点
public void batchCreateNodes(String parentPath, List<String> nodeNames) {
    List<Op> operations = new ArrayList<>();
    
    for (String nodeName : nodeNames) {
        String path = parentPath + "/" + nodeName;
        Op createOp = Op.create(path, "data".getBytes(), 
                               ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        operations.add(createOp);
    }
    
    try {
        // 执行批量操作
        List<OpResult> results = zk.multi(operations);
        System.out.println("批量创建成功，创建了 " + results.size() + " 个节点");
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

### 2. 异步操作
```java
// 异步创建节点
zk.create("/app/async-node", "async-data".getBytes(), 
          ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT,
          new AsyncCallback.StringCallback() {
              public void processResult(int rc, String path, Object ctx, String name) {
                  if (rc == KeeperException.Code.OK.intValue()) {
                      System.out.println("异步创建成功: " + name);
                  } else {
                      System.out.println("异步创建失败: " + KeeperException.Code.get(rc));
                  }
              }
          }, "context-data");
```

## 🔗 下一步学习

- [ZooKeeper集群部署](./05.ZooKeeper集群部署.md) - 学习集群部署
- [Java客户端使用](./06.Java客户端使用.md) - 开始Java编程
- [分布式锁实现](./07.分布式锁实现.md) - 实践应用

---

**记住：ZooKeeper的核心特性是保证分布式环境下的数据一致性和可靠性！** 🎯
