# ZooKeeper 面试题集锦

## 🎯 基础概念类

### 1. 什么是ZooKeeper？它的主要作用是什么？

**答案：**
ZooKeeper是一个开源的分布式协调服务，主要用于解决分布式系统中的协调问题。

**主要作用：**
- **配置管理**：集中管理分布式系统的配置信息
- **命名服务**：提供分布式系统中的命名服务
- **分布式锁**：实现分布式环境下的互斥访问
- **集群管理**：监控集群节点状态，实现故障检测
- **服务发现**：实现服务的注册与发现

**核心特性：**
- 强一致性保证
- 高可用性
- 实时通知机制
- 简单的API接口

### 2. ZooKeeper的数据模型是什么样的？

**答案：**
ZooKeeper采用类似文件系统的层次命名空间结构：

```
/
├── app1/
│   ├── config/
│   │   ├── database.properties
│   │   └── redis.properties
│   └── services/
│       └── user-service
├── app2/
│   └── config/
└── global/
    └── system-status
```

**特点：**
- 每个节点称为ZNode
- 支持层次化路径
- 节点可以存储数据（最大1MB）
- 支持多种节点类型

### 3. ZooKeeper中的ZNode有哪些类型？

**答案：**
ZooKeeper支持四种ZNode类型：

1. **持久节点（Persistent）**
   - 创建后永久存在
   - 除非手动删除
   - 适合存储配置信息

2. **临时节点（Ephemeral）**
   - 会话结束时自动删除
   - 适合服务注册
   - 用于故障检测

3. **顺序节点（Sequential）**
   - 自动添加递增序号
   - 保证创建顺序
   - 适合实现分布式锁

4. **临时顺序节点（Ephemeral Sequential）**
   - 临时节点 + 顺序节点
   - 会话结束时自动删除
   - 适合实现公平的分布式锁

## 🏗️ 架构设计类

### 4. ZooKeeper的架构是怎样的？有哪些角色？

**答案：**
ZooKeeper采用主从架构，包含三种角色：

1. **Leader（领导者）**
   - 处理所有写请求
   - 协调集群
   - 集群中只有一个Leader
   - 通过ZAB协议选举产生

2. **Follower（跟随者）**
   - 处理读请求
   - 参与Leader选举
   - 可以有多个
   - 不能处理写请求

3. **Observer（观察者）**
   - 只处理读请求
   - 不参与选举
   - 提高读性能
   - 不影响写性能

**架构特点：**
- 写请求必须经过Leader
- 读请求可以任意节点处理
- 支持集群部署
- 具备故障恢复能力

### 5. 什么是ZAB协议？它包含哪些阶段？

**答案：**
ZAB（ZooKeeper Atomic Broadcast）是ZooKeeper的核心协议，用于保证数据一致性。

**包含两个阶段：**

1. **Leader选举（Leader Election）**
   - 每个节点发起投票请求
   - 节点投票给比自己ID大的节点
   - 统计投票结果，得票过半的成为Leader
   - 其他节点成为Follower

2. **原子广播（Atomic Broadcast）**
   - Client → Leader → 提案(Proposal) → Follower → 确认(Ack)
   - Leader → 提交(Commit) → Follower
   - Client ← 响应结果

**特点：**
- 保证全局顺序性
- 支持故障恢复
- 强一致性保证

### 6. 为什么ZooKeeper集群建议使用奇数个节点？

**答案：**
使用奇数个节点主要有以下原因：

1. **避免脑裂问题**
   - 偶数节点可能导致选举僵局
   - 奇数节点更容易达成多数共识

2. **资源利用率**
   - 3节点集群：最多容忍1个节点故障
   - 4节点集群：最多容忍1个节点故障
   - 5节点集群：最多容忍2个节点故障

3. **选举效率**
   - 奇数节点选举更快
   - 减少选举冲突

**推荐配置：**
- 开发环境：3节点
- 测试环境：3-5节点
- 生产环境：5-7节点

## 🔧 核心特性类

### 7. ZooKeeper如何保证数据一致性？

**答案：**
ZooKeeper通过以下机制保证数据一致性：

1. **顺序一致性（Sequential Consistency）**
   - 全局单调递增的事务ID（zxid）
   - 所有写操作按顺序执行
   - 读操作能看到之前所有写操作的结果

2. **原子性（Atomicity）**
   - 事务要么全部成功，要么全部失败
   - 不存在部分成功的情况

3. **单一系统映像（Single System Image）**
   - 客户端连接到任意节点看到的数据一致
   - 强一致性保证

4. **ZAB协议**
   - 保证Leader选举的一致性
   - 保证数据广播的顺序性

### 8. ZooKeeper的Watcher机制是什么？有什么特点？

**答案：**
Watcher是ZooKeeper的监听机制，用于监听节点变化。

**特点：**

1. **一次性监听器**
   - 触发后自动失效
   - 需要手动重新注册

2. **监听类型**
   - 节点数据变化
   - 子节点变化
   - 节点创建/删除

3. **使用方式**
   ```java
   // 监听节点数据变化
   zk.getData("/app/config", dataWatcher, null);
   
   // 监听子节点变化
   zk.getChildren("/app", childrenWatcher);
   
   // 监听节点存在性
   zk.exists("/app/new-node", existsWatcher);
   ```

**注意事项：**
- 监听器触发后需要重新注册
- 避免监听过多节点
- 处理网络异常情况

## 💻 Java客户端类

### 9. 如何在Java中连接ZooKeeper？

**答案：**
```java
import org.apache.zookeeper.*;
import java.util.concurrent.CountDownLatch;

public class ZooKeeperClient {
    private ZooKeeper zk;
    private CountDownLatch connectedSignal = new CountDownLatch(1);
    
    public void connect(String connectString) throws Exception {
        // 创建连接
        zk = new ZooKeeper(connectString, 5000, new Watcher() {
            @Override
            public void process(WatchedEvent event) {
                if (event.getState() == Event.KeeperState.SyncConnected) {
                    connectedSignal.countDown();
                    System.out.println("连接成功！");
                }
            }
        });
        
        // 等待连接建立
        connectedSignal.await();
    }
    
    public void close() throws InterruptedException {
        if (zk != null) {
            zk.close();
        }
    }
}
```

**连接参数说明：**
- `connectString`：ZooKeeper服务器地址
- `sessionTimeout`：会话超时时间
- `watcher`：连接状态监听器

### 10. 如何实现基于ZooKeeper的分布式锁？

**答案：**
```java
public class DistributedLock {
    private ZooKeeper zk;
    private String lockPath;
    private String lockNode;
    private boolean isLocked = false;
    
    public DistributedLock(ZooKeeper zk, String lockPath) {
        this.zk = zk;
        this.lockPath = lockPath;
    }
    
    // 获取锁
    public boolean acquireLock(long timeout) throws Exception {
        try {
            // 创建临时顺序节点
            lockNode = zk.create(lockPath + "/lock-", "locked".getBytes(),
                               ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
            
            // 检查是否获得锁
            if (checkLockAcquired(lockNode)) {
                isLocked = true;
                return true;
            }
            
            // 等待锁释放
            return waitForLock(lockNode, timeout);
            
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        return false;
    }
    
    // 检查是否获得锁
    private boolean checkLockAcquired(String lockNode) throws Exception {
        List<String> children = zk.getChildren(lockPath, false);
        Collections.sort(children);
        
        String nodeName = lockNode.substring(lockNode.lastIndexOf("/") + 1);
        return children.get(0).equals(nodeName);
    }
    
    // 释放锁
    public void releaseLock() throws Exception {
        if (isLocked && lockNode != null) {
            zk.delete(lockNode, -1);
            isLocked = false;
            lockNode = null;
        }
    }
}
```

**实现原理：**
- 使用临时顺序节点
- 序号最小的节点获得锁
- 监听前一个节点的删除事件
- 会话结束时自动释放锁

## 🚀 高级应用类

### 11. 如何实现基于ZooKeeper的配置中心？

**答案：**
```java
public class ConfigurationManager {
    private ZooKeeper zk;
    private String configRootPath;
    private Map<String, String> localCache = new ConcurrentHashMap<>();
    
    public ConfigurationManager(ZooKeeper zk, String configRootPath) {
        this.zk = zk;
        this.configRootPath = configRootPath;
    }
    
    // 设置配置
    public void setConfig(String appName, String configName, String value) throws Exception {
        String path = configRootPath + "/" + appName + "/" + configName;
        
        if (zk.exists(path, false) == null) {
            zk.create(path, value.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        } else {
            zk.setData(path, value.getBytes(), -1);
        }
        
        localCache.put(path, value);
    }
    
    // 获取配置
    public String getConfig(String appName, String configName) throws Exception {
        String path = configRootPath + "/" + appName + "/" + configName;
        
        // 先从本地缓存获取
        String cachedValue = localCache.get(path);
        if (cachedValue != null) {
            return cachedValue;
        }
        
        // 从ZooKeeper获取
        byte[] data = zk.getData(path, false, null);
        String value = new String(data);
        
        // 更新本地缓存
        localCache.put(path, value);
        
        // 注册监听器
        registerWatcher(path);
        
        return value;
    }
}
```

**核心功能：**
- 配置的增删改查
- 本地缓存优化
- 配置变化监听
- 实时通知机制

### 12. 如何实现基于ZooKeeper的服务发现？

**答案：**
```java
public class ServiceRegistry {
    private ZooKeeper zk;
    private String serviceRootPath;
    private String serviceName;
    private String instancePath;
    
    public ServiceRegistry(ZooKeeper zk, String serviceRootPath, String serviceName) {
        this.zk = zk;
        this.serviceRootPath = serviceRootPath;
        this.serviceName = serviceName;
    }
    
    // 注册服务
    public void registerService(String host, int port, Map<String, String> metadata) throws Exception {
        String servicePath = serviceRootPath + "/" + serviceName;
        
        // 确保服务目录存在
        if (zk.exists(servicePath, false) == null) {
            zk.create(servicePath, "service".getBytes(),
                      ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        }
        
        // 创建服务实例节点
        String instancePath = servicePath + "/" + UUID.randomUUID().toString();
        
        // 构建实例信息
        ServiceInstance instance = new ServiceInstance();
        instance.setHost(host);
        instance.setPort(port);
        instance.setStatus("UP");
        instance.setMetadata(metadata);
        
        // 序列化实例信息
        String instanceData = serializeInstance(instance);
        
        // 创建临时节点，会话结束时自动删除
        this.instancePath = zk.create(instancePath, instanceData.getBytes(),
                                     ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
    }
}
```

**核心特性：**
- 服务自动注册
- 服务自动发现
- 健康状态监控
- 负载均衡支持

## 🔍 故障排查类

### 13. ZooKeeper集群无法启动怎么办？

**答案：**
ZooKeeper集群无法启动的排查步骤：

1. **检查进程状态**
   ```bash
   ps aux | grep zookeeper
   ```

2. **检查端口监听**
   ```bash
   netstat -tlnp | grep :2181
   ```

3. **检查日志**
   ```bash
   tail -f /opt/zookeeper/logs/zookeeper.out
   ```

4. **检查数据目录**
   ```bash
   ls -la /opt/zookeeper/data/
   ```

5. **检查配置文件**
   ```bash
   cat /opt/zookeeper/conf/zoo.cfg
   ```

6. **检查节点ID配置**
   ```bash
   cat /opt/zookeeper/data/myid
   ```

**常见问题及解决方案：**

1. **端口被占用**
   ```bash
   # 查找占用端口的进程
   lsof -i :2181
   
   # 杀死进程
   kill -9 <PID>
   ```

2. **数据目录权限问题**
   ```bash
   # 检查权限
   ls -la /opt/zookeeper/data/
   
   # 修改权限
   chown -R zookeeper:zookeeper /opt/zookeeper/data/
   chmod 755 /opt/zookeeper/data/
   ```

### 14. ZooKeeper出现脑裂问题怎么办？

**答案：**
脑裂问题的预防和解决方案：

1. **预防措施**
   - 使用奇数个节点
   - 合理设置超时参数
   - 使用专用网络
   - 配置防火墙规则

2. **超时参数配置**
   ```properties
   # 基本配置
   tickTime=2000
   initLimit=10
   syncLimit=5
   
   # 会话超时
   sessionTimeout=5000
   
   # 连接超时
   connectionTimeout=10000
   ```

3. **网络隔离**
   ```bash
   # 使用专用网络
   # 配置防火墙
   iptables -A INPUT -p tcp --dport 2181 -s <zk-cluster-ip> -j ACCEPT
   iptables -A INPUT -p tcp --dport 2181 -j DROP
   ```

## 💡 最佳实践类

### 15. ZooKeeper在生产环境中的最佳实践有哪些？

**答案：**
生产环境的最佳实践：

1. **集群配置**
   - 使用奇数个节点（推荐5-7个）
   - 部署在不同机架或机房
   - 使用专用网络
   - 配置监控和告警

2. **性能优化**
   ```properties
   # JVM参数优化
   export SERVER_JVMFLAGS="-Xms4g -Xmx4g -XX:+UseG1GC -XX:MaxGCPauseMillis=200"
   
   # 系统参数优化
   echo 'vm.dirty_ratio = 15' >> /etc/sysctl.conf
   echo 'vm.dirty_background_ratio = 5' >> /etc/sysctl.conf
   ```

3. **安全配置**
   ```properties
   # 启用ACL
   # 配置认证
   # 网络隔离
   # 审计日志
   ```

4. **监控告警**
   - 监控连接数
   - 监控响应时间
   - 监控内存使用
   - 监控磁盘使用
   - 配置告警阈值

5. **备份策略**
   - 定期备份数据目录
   - 备份配置文件
   - 测试恢复流程
   - 文档化操作流程

## 🔗 总结

掌握这些面试题，你就能在ZooKeeper相关的面试中游刃有余！记住：

1. **理解原理**：深入理解ZAB协议、数据模型等核心概念
2. **掌握实践**：熟练使用Java客户端API，实现各种分布式功能
3. **关注性能**：了解性能优化和监控方法
4. **重视运维**：掌握故障排查和最佳实践

**祝你面试成功！** 🎯
