# RocketMQ 从零开始详解

## 一、RocketMQ 是什么？

RocketMQ 是一个分布式消息中间件，由阿里巴巴开发并开源。简单来说，它就像一个高效的"邮局系统"，负责在不同应用程序之间传递消息。

### 为什么需要消息中间件？
想象一下现实生活中的场景：
- 快递员送快递时，如果收件人不在家，快递员会一直等待吗？不会，他会把快递放到快递柜
- 同样，在软件系统中，当A系统要给B系统发送数据，但B系统暂时不可用时，消息中间件就像快递柜一样暂存这些数据

## 二、核心概念

### 1. 基本组成
- **Producer**：消息生产者，负责发送消息
- **Consumer**：消息消费者，负责接收消息
- **Broker**：消息服务器，负责存储和转发消息
- **NameServer**：名字服务，相当于"通讯录"，记录Broker的地址信息

### 2. 消息模型
- **Topic**：消息的主题/分类，比如"订单消息"、"支付消息"
- **Message Queue**：消息队列，一个Topic可以分成多个队列
- **Tag**：消息标签，用于进一步细分消息（比如"订单创建"、"订单取消"）

## 三、安装与配置

### 1. 下载
从官网下载最新版本：https://rocketmq.apache.org/

### 2. 环境要求
- JDK 1.8+
- Maven（用于Java客户端）
- 4GB+内存（生产环境建议8GB+）

### 3. 快速启动
```bash
# 解压下载的包
unzip rocketmq-all-4.9.4-bin-release.zip

# 启动NameServer
nohup sh bin/mqnamesrv &

# 启动Broker
nohup sh bin/mqbroker -n localhost:9876 &
```

## 四、Java客户端使用

### 1. 添加依赖
```xml
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-client</artifactId>
    <version>4.9.4</version>
</dependency>
```

### 2. 生产者示例
```java
public class ProducerExample {
    public static void main(String[] args) throws Exception {
        // 1. 创建生产者实例
        DefaultMQProducer producer = new DefaultMQProducer("producer_group");
        // 2. 设置NameServer地址
        producer.setNamesrvAddr("localhost:9876");
        // 3. 启动生产者
        producer.start();
        
        // 4. 创建消息
        Message msg = new Message(
            "OrderTopic",  // 主题
            "CreateOrder", // 标签
            "Order001".getBytes() // 内容
        );
        
        // 5. 发送消息
        SendResult result = producer.send(msg);
        System.out.println("发送结果: " + result);
        
        // 6. 关闭生产者
        producer.shutdown();
    }
}
```

### 3. 消费者示例
```java
public class ConsumerExample {
    public static void main(String[] args) throws Exception {
        // 1. 创建消费者实例
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("consumer_group");
        // 2. 设置NameServer地址
        consumer.setNamesrvAddr("localhost:9876");
        // 3. 订阅主题和标签
        consumer.subscribe("OrderTopic", "CreateOrder");
        
        // 4. 注册消息监听器
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(
                List<MessageExt> msgs, 
                ConsumeConcurrentlyContext context) {
                // 处理消息
                for (MessageExt msg : msgs) {
                    System.out.println("收到消息: " + new String(msg.getBody()));
                }
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        
        // 5. 启动消费者
        consumer.start();
        System.out.println("消费者已启动");
    }
}
```

## 五、核心特性详解

### 1. 消息类型
- **普通消息**：最基本的消息类型
- **顺序消息**：保证消息按照发送顺序消费（如订单状态变更）
- **定时/延时消息**：指定时间后才会被消费
- **事务消息**：类似数据库事务，保证发送和本地事务的一致性

### 2. 消息顺序性示例
```java
// 生产者发送顺序消息
Message msg = new Message("OrderTopic", "OrderStatus", orderId.getBytes());
// 使用订单ID作为选择器，确保同一订单的消息进入同一队列
SendResult result = producer.send(msg, new MessageQueueSelector() {
    @Override
    public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {
        // 根据订单ID选择队列
        int index = Math.abs(arg.toString().hashCode()) % mqs.size();
        return mqs.get(index);
    }
}, orderId);
```

### 3. 消息过滤
- **Tag过滤**：消费者可以只订阅特定Tag的消息
- **SQL过滤**：使用SQL表达式对消息属性进行过滤

```java
// 消费者使用SQL过滤
consumer.subscribe("OrderTopic", MessageSelector.bySql("amount > 100"));
```

## 六、实际应用场景

### 1. 电商系统案例
- **订单创建**：订单服务 → 通知库存服务扣减库存
- **支付成功**：支付服务 → 通知订单服务更新状态
- **物流发货**：物流服务 → 通知用户服务发送通知

### 2. 日志收集
多个应用将日志发送到RocketMQ，由专门的消费者统一处理并存入Elasticsearch

## 七、常见问题解答

### Q1: RocketMQ和Kafka有什么区别？
- **设计目标**：Kafka侧重高吞吐，RocketMQ更均衡（吞吐+事务+实时）
- **消息顺序**：Kafka分区内有序，RocketMQ队列内有序
- **消息堆积**：RocketMQ支持更长时间的消息存储

### Q2: 如何保证消息不丢失？
- 生产者使用同步发送+重试机制
- Broker配置同步刷盘和主从同步
- 消费者正确返回消费状态并实现幂等处理

### Q3: 消息重复消费怎么办？
- 实现消费逻辑的幂等性（如检查数据库是否已处理）
- 使用唯一键或业务ID去重

## 八、最佳实践

1. **Topic设计**：按业务领域划分，避免过多Topic
2. **Tag使用**：用Tag区分同Topic下的不同业务动作
3. **消费者组**：同一业务使用相同消费者组实现负载均衡
4. **监控告警**：设置消息堆积、消费延迟等监控指标

## 九、学习路径建议

1. 先掌握基本生产消费流程
2. 理解不同消息类型的适用场景
3. 学习集群部署和高可用配置
4. 研究源码深入理解实现原理

希望这篇从零开始的RocketMQ教程能帮助你入门！如果有任何问题，可以随时提问。
