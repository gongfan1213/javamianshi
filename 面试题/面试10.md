### 10. **MySQL事务隔离级别**

MySQL支持四种事务隔离级别，隔离级别决定了事务之间的可见性和并发性。它们从低到高依次是：

* **READ UNCOMMITTED（读取未提交）**：

  * 允许一个事务读取另一个事务尚未提交的数据。这会导致**脏读**（dirty read），即读取到不一致的数据。
* **READ COMMITTED（读取已提交）**：

  * 只允许一个事务读取另一个事务已经提交的数据。这解决了脏读问题，但会产生**不可重复读**（non-repeatable read）的问题，即一个事务内两次读取相同数据时可能得到不同的结果。
* **REPEATABLE READ（可重复读）**：

  * 确保在一个事务内多次读取同一数据时，结果是一致的，解决了不可重复读问题。然而，可能会出现**幻读**（phantom read）的问题。
* **SERIALIZABLE（可串行化）**：

  * 最严格的隔离级别，通过强制事务串行执行，解决了所有并发问题，包括脏读、不可重复读和幻读。代价较高，性能较低。

### 11. **MVCC（多版本并发控制）**

MVCC（Multi-Version Concurrency Control）是一种数据库并发控制机制，它通过保存数据的多个版本来允许读操作和写操作并发执行，减少锁的争用。

* **如何工作**：

  * 每个事务都会读取数据的某个版本（快照）。当数据发生更新时，数据库并不会直接修改数据，而是创建一个新的版本，并记录版本号或时间戳。
  * 读取操作会看到符合自己事务版本的数据，而不会受到其他事务修改的影响。
* **优势**：

  * 可以有效避免数据库锁的争用，提高并发性能。
  * 适用于大多数数据库（如MySQL的InnoDB引擎）。
* **缺点**：

  * 会占用更多的存储空间，特别是对于长时间运行的事务，可能会积累大量的旧版本数据。

### 12. **索引失效的情况**

索引失效的原因通常包括以下几种：

* **使用不等于操作（`<>`, `!=`）**：索引对于`=`操作非常高效，但对于`<>`操作就无法使用索引。
* **在`WHERE`子句中使用函数**：例如`WHERE YEAR(dateColumn) = 2020`，因为`YEAR(dateColumn)`是一个计算函数，会导致索引失效。
* **模糊查询使用前缀匹配**：例如`LIKE '%abc%'`，索引会失效，只有`LIKE 'abc%'`才能利用索引。
* **`OR`连接条件**：如果查询条件是`a = 1 OR b = 2`，在没有合适的复合索引时，可能会导致索引失效。
* **类型不匹配**：如果查询字段的数据类型与表中存储的数据类型不匹配，会导致索引失效。
* **NULL值**：如果列包含大量`NULL`值，索引可能无法完全发挥作用。

### 13. **Redis持久化方案**

Redis提供了两种持久化机制：

* **RDB（快照存储）**：

  * 定期将Redis的内存数据快照保存到磁盘（通常是某个时间点的数据）。
  * 优点：持久化性能较好，恢复速度较快。
  * 缺点：可能会丢失最后一次快照之间的数据。
  * 配置：`save <seconds> <changes>`，设置快照的频率。
* **AOF（追加日志文件）**：

  * 每次写操作都会记录在AOF日志文件中，可以保证数据的持久化。
  * 优点：数据持久性更好，能够恢复到最新状态。
  * 缺点：文件较大，性能相对较差。
  * 配置：`appendonly yes`，开启AOF持久化。

**混合持久化**：Redis 4.0之后，支持RDB和AOF同时开启，可以结合两者的优点。通过定期生成快照，同时记录AOF日志。

### 14. **缓存雪崩、缓存穿透、缓存击穿**

* **缓存雪崩**：

  * 多个缓存同时失效，导致大量请求直接访问数据库，造成数据库压力过大，甚至崩溃。
  * **解决方案**：

    * 设置不同的过期时间，避免缓存同时过期。
    * 使用互斥锁，确保只有一个请求能查询数据库并更新缓存。

* **缓存穿透**：

  * 查询的数据在缓存和数据库中都不存在，每次请求都会查询数据库，无法命中缓存。
  * **解决方案**：

    * 使用布隆过滤器（Bloom Filter）预先判断请求的数据是否存在，避免不必要的数据库查询。
    * 对空结果进行缓存，设置短时间的过期时间。

* **缓存击穿**：

  * 当缓存的某一数据过期时，所有请求都会同时查询数据库，导致数据库负载过大。
  * **解决方案**：

    * 使用锁机制（如互斥锁）控制同一时刻只有一个请求能查询数据库并更新缓存。
    * 设置合理的缓存过期策略，避免过期的缓存数据长期存在。

### 15. **讲讲TCP的三次握手和四次挥手**

* **三次握手**（建立连接）：

  1. **SYN**：客户端发送SYN标志位的报文，表示请求建立连接。
  2. **SYN-ACK**：服务器接收到客户端的请求后，返回SYN-ACK报文，表示同意连接。
  3. **ACK**：客户端收到SYN-ACK后，返回ACK报文，表示连接建立完成。

* **四次挥手**（断开连接）：

  1. **FIN**：客户端发送FIN报文，表示希望关闭连接。
  2. **ACK**：服务器收到FIN后，返回ACK报文，表示已经准备好关闭连接。
  3. **FIN**：服务器发送FIN报文，表示同意关闭连接。
  4. **ACK**：客户端收到FIN后，返回ACK报文，连接彻底关闭。

### 16. **说说Linux的常用命令**

* **文件操作**：

  * `ls`：列出目录内容。
  * `cd`：切换目录。
  * `cp`：复制文件或目录。
  * `mv`：移动文件或目录。
  * `rm`：删除文件或目录。
  * `touch`：创建空文件。
  * `cat`：查看文件内容。
  * `find`：查找文件。

* **权限管理**：

  * `chmod`：修改文件或目录权限。
  * `chown`：修改文件或目录的所有者。

* **进程管理**：

  * `ps`：查看当前进程。
  * `top`：查看系统资源使用情况。
  * `kill`：杀死指定进程。
  * `nohup`：后台执行命令并忽略挂断信号。

* **网络管理**：

  * `ping`：测试网络连接。
  * `netstat`：查看网络连接状态。
  * `ifconfig`：查看或配置网络接口。

### 17. **有没有用过Docker？说说Docker的常用命令？有自己构建过Docker镜像吗？**

**Docker常用命令**：

* `docker run`：运行一个容器，常用来创建和启动容器。
* `docker ps`：列出当前运行的容器。
* `docker stop <container_id>`：停止一个正在运行的容器。
* `docker rm <container_id>`：删除一个容器。
* `docker build -t <image_name> <path>`：根据Dockerfile构建镜像。
* `docker images`：查看本地镜像。
* `docker rmi <image_id>`：删除镜像。
* `docker exec -it <container_id> <command>`：在运行的容器中执行命令。

**自己构建Docker镜像**：

* **步骤**：

  1. 编写`Dockerfile`，定义如何构建镜像。
  2. 使用`docker build`命令构建镜像。
  3. 可以使用`docker run`运行该镜像，并进行测试和验证。

例如，构建一个简单的Node.js应用镜像：

```dockerfile
FROM node:14
WORKDIR /app
COPY . /app
RUN npm install
EXPOSE 3000
CMD ["npm", "start"]
```

然后执行：

```bash
docker build -t mynodeapp .
docker run -p 3000:3000 mynodeapp
```

---

这些解答提供了对相关技术问题的深入理解，希望对你有所帮助。如果有任何问题，随时欢迎提问！
