# 面试题详细解答

## 1. 项目难点及遇到问题怎么排查

**项目难点**通常包括：
- 高并发场景下的性能优化
- 分布式系统的一致性问题
- 复杂业务逻辑的实现
- 第三方系统集成
- 大数据量处理

**问题排查方法**：
1. **日志分析**：查看系统日志、错误日志、访问日志等
2. **监控工具**：使用Prometheus、Grafana等监控系统指标
3. **链路追踪**：通过Skywalking、Zipkin等工具追踪请求链路
4. **代码调试**：本地复现问题，使用Debug模式逐步排查
5. **压力测试**：使用JMeter等进行压测，找出性能瓶颈
6. **数据库分析**：检查慢查询、死锁等问题
7. **网络排查**：检查网络延迟、丢包等问题

## 2. 线程池核心参数及执行过程

**核心参数**：
1. `corePoolSize`：核心线程数，即使空闲也不会被回收
2. `maximumPoolSize`：最大线程数
3. `keepAliveTime`：非核心线程空闲存活时间
4. `unit`：存活时间单位
5. `workQueue`：任务队列
6. `threadFactory`：线程工厂
7. `handler`：拒绝策略

**执行过程**：
1. 提交任务时，如果当前线程数 < corePoolSize，创建新线程执行
2. 如果线程数 >= corePoolSize，将任务放入工作队列
3. 如果队列已满且线程数 < maximumPoolSize，创建新线程执行
4. 如果队列已满且线程数 >= maximumPoolSize，执行拒绝策略

## 3. ThreadLocal应用场景及key和map

**应用场景**：
1. 线程上下文传递（如用户信息、traceId等）
2. 数据库连接管理
3. 避免方法参数层层传递

**key和map**：
- ThreadLocal内部使用ThreadLocalMap存储数据
- key是ThreadLocal实例本身（弱引用）
- value是存储的值（强引用）
- 每个Thread线程内部都有一个threadLocals变量（ThreadLocalMap类型）

## 4. Java双亲委派机制及原因

**双亲委派机制**：
类加载器在加载类时，先委托父加载器尝试加载，只有当父加载器无法加载时，自己才尝试加载。

**加载顺序**：
1. Bootstrap ClassLoader
2. Extension ClassLoader
3. Application ClassLoader
4. 自定义ClassLoader

**使用原因**：
1. 避免类重复加载
2. 保证核心类库安全（防止篡改）
3. 保证类的唯一性
4. 实现类的隔离

## 5. MySQL索引结构：B+树与B树区别及为什么用B+

**区别**：
1. **数据存储**：
   - B树：所有节点都存储数据
   - B+树：只有叶子节点存储数据，非叶子节点只存储索引
2. **叶子节点**：
   - B树：叶子节点不相连
   - B+树：叶子节点通过指针相连形成链表
3. **查询效率**：
   - B树：可能在非叶子节点命中
   - B+树：必须到叶子节点才能命中

**为什么用B+树**：
1. 更适合磁盘IO（减少IO次数）
2. 查询效率更稳定（都要到叶子节点）
3. 范围查询效率高（叶子节点链表）
4. 更高的空间利用率（非叶子节点不存数据）

## 6. 过滤器与拦截器区别及使用场景

**区别**：
1. **实现原理**：
   - 过滤器：基于函数回调（Filter接口）
   - 拦截器：基于Java反射（AOP思想）
2. **使用范围**：
   - 过滤器：Servlet规范，任何Java Web工程都能用
   - 拦截器：Spring组件，只能在Spring工程中使用
3. **执行顺序**：
   - 过滤器 > Servlet > 拦截器 > Controller
4. **依赖**：
   - 过滤器：依赖Web容器
   - 拦截器：依赖Spring框架

**使用场景**：
- **过滤器**：
  - 字符编码设置
  - 敏感词过滤
  - 跨域处理
  - 权限校验（粗粒度）
  
- **拦截器**：
  - 登录验证
  - 日志记录
  - 权限校验（细粒度）
  - 性能监控

## 7. Bean生命周期及前置操作

**Bean生命周期**：
1. 实例化
2. 属性赋值（依赖注入）
3. 初始化
   - 调用Aware接口方法
   - 执行BeanPostProcessor的postProcessBeforeInitialization
   - 执行InitializingBean的afterPropertiesSet
   - 执行自定义init-method
   - 执行BeanPostProcessor的postProcessAfterInitialization
4. 使用
5. 销毁

**加载Bean前的前置操作**：
1. 实现BeanPostProcessor接口的postProcessBeforeInitialization方法
2. 使用@PostConstruct注解
3. 实现InitializingBean接口的afterPropertiesSet方法
4. 在@Bean注解中指定initMethod

## 8. MyBatis数据与Java类匹配方式

1. **字段名匹配**：数据库字段名与Java属性名一致（驼峰转换可通过配置开启）
2. **ResultMap映射**：在XML中定义<resultMap>明确指定映射关系
3. **注解方式**：使用@Results和@Result注解
4. **构造函数映射**：通过@ConstructorArgs指定构造函数参数
5. **自动映射**：开启autoMappingBehavior配置

## 9. 二叉树层序遍历（ArrayList实现）

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) return result;
    
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        int levelSize = queue.size();
        List<Integer> currentLevel = new ArrayList<>();
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode node = queue.poll();
            currentLevel.add(node.val);
            
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
        
        result.add(currentLevel);
    }
    
    return result;
}
```

这个实现使用Queue来进行广度优先遍历，用ArrayList存储每一层的结果，最后返回包含所有层结果的ArrayList。

# 面试题详细解答

## 一、力扣53. 最大子数组和问题

这是一个经典的动态规划问题，正确的解法应该是：

```java
public int maxSubArray(int[] nums) {
    int maxSum = nums[0];
    int currentSum = nums[0];
    
    for (int i = 1; i < nums.length; i++) {
        currentSum = Math.max(nums[i], currentSum + nums[i]);
        maxSum = Math.max(maxSum, currentSum);
    }
    
    return maxSum;
}
```

这个算法的核心思想是：对于数组中的每一个元素，我们决定是将其加入当前子数组，还是以该元素为起点开始新的子数组。

## 二、Java容器相关问题

### 1. Java容器有哪些？

Java容器主要分为两大类：
- **Collection**：存储单个元素的集合
  - List：有序可重复
  - Set：无序不重复
  - Queue：队列
- **Map**：存储键值对的集合

### 2. List, Set, Map之间的区别是什么？

| 特性 | List | Set | Map |
|------|------|-----|-----|
| 元素 | 单值 | 单值 | 键值对 |
| 顺序 | 有序 | 无序(除TreeSet) | 无序(除TreeMap) |
| 重复 | 允许 | 不允许 | 键不允许重复 |
| 实现类 | ArrayList, LinkedList | HashSet, TreeSet | HashMap, TreeMap |

### 3. 哪一种容器里面的元素是有序的？

- **List**：所有实现类都是有序的（按插入顺序）
- **TreeSet**：基于红黑树实现，自然排序或自定义排序
- **LinkedHashSet**：按插入顺序排序
- **TreeMap**：基于键的自然排序或自定义排序
- **LinkedHashMap**：按插入顺序或访问顺序排序

### 4. 容器元素重复性

- **List**：允许元素重复
- **Set**：不允许元素重复
- **TreeSet**：是有序的（基于元素的自然顺序或Comparator定义的顺序）

### 5. HashTable和HashMap的区别

| 特性 | HashTable | HashMap |
|------|----------|---------|
| 线程安全 | 是 | 否 |
| 性能 | 较低 | 较高 |
| null键值 | 不允许 | 允许 |
| 继承 | Dictionary类 | AbstractMap类 |
| 迭代器 | Enumeration | Iterator |
| 初始容量 | 11 | 16 |

### 6. 线程安全的类

- **集合类**：Vector, HashTable, ConcurrentHashMap, CopyOnWriteArrayList, CopyOnWriteArraySet
- **其他**：StringBuffer, Properties

## 三、线程相关问题

### 7. 创建线程的方式

1. 继承Thread类
2. 实现Runnable接口
3. 实现Callable接口
4. 使用线程池（Executor框架）

### 8. Runnable和Callable的区别

| 特性 | Runnable | Callable |
|------|---------|----------|
| 返回值 | 无 | 有 |
| 异常 | 不能抛出 | 可以抛出 |
| 引入版本 | Java 1.0 | Java 1.5 |
| 使用 | Thread或Executor | 只能通过ExecutorService |

### 9. submit和execute方法的区别

| 特性 | execute | submit |
|------|--------|--------|
| 返回值 | 无 | Future对象 |
| 异常处理 | 直接抛出 | 可通过Future.get()捕获 |
| 参数 | Runnable | Runnable或Callable |

## 四、锁相关问题

### 10. Java加锁方式

1. **synchronized**关键字
   - 方法级别
   - 代码块级别
2. **Lock接口**及其实现类（如ReentrantLock）
3. **ReadWriteLock**读写锁
4. **StampedLock**（Java 8引入）
5. **volatile**关键字（轻量级同步）

### 11. Synchronized和Lock的区别

| 特性 | Synchronized | Lock |
|------|------------|------|
| 实现 | JVM层面 | Java代码层面 |
| 锁获取 | 自动释放 | 必须手动释放 |
| 中断 | 不可中断 | 可中断 |
| 公平锁 | 非公平 | 可配置 |
| 条件 | 单一 | 可多个 |
| 性能 | 较低 | 较高 |

### 12. 方法/类加锁选择

- **简单场景**：使用synchronized，代码简洁，自动释放锁
- **复杂场景**：使用ReentrantLock，需要更灵活的控制（如可中断、公平锁、多个条件等）

## 五、数据库相关问题

### 13. 慢SQL排查方法

1. **EXPLAIN分析**执行计划
2. **开启慢查询日志**
3. 检查**索引使用情况**
4. 优化SQL语句（避免SELECT *，减少JOIN等）
5. 检查**表结构设计**是否合理
6. 考虑**分库分表**（数据量过大时）
7. 使用**数据库性能监控工具**

### 14. SQL查询示例

```sql
SELECT 人员id 
FROM 表名 
WHERE 部门 = '111' 
AND 人员年龄 BETWEEN 20 AND 30;
```

## 六、消息队列相关问题

### 15. 避免重复消费

1. **幂等性设计**：使重复操作不会产生副作用
2. **唯一标识**：为消息添加唯一ID，消费后记录
3. **数据库约束**：利用主键或唯一索引
4. **消费状态表**：记录已处理的消息ID
5. **分布式锁**：处理前获取锁

### 16. 避免消息丢失

**生产者端**：
1. 开启confirm机制（RabbitMQ）或事务（Kafka）
2. 失败重试机制

**MQ服务端**：
1. 持久化消息
2. 集群部署

**消费者端**：
1. 手动ack确认
2. 消费失败重试机制
3. 死信队列处理

## 七、网络相关问题

### 17. Session和Cookie的区别

| 特性 | Cookie | Session |
|------|-------|--------|
| 存储位置 | 客户端 | 服务端 |
| 安全性 | 较低 | 较高 |
| 存储大小 | 有限(4KB) | 较大 |
| 生命周期 | 可设置 | 通常随会话结束 |
| 数据类型 | 字符串 | 对象 |
| 性能影响 | 无 | 服务器压力 |

### 18. 禁用Cookie后Session的使用

当客户端禁用Cookie时，可以通过以下方式继续使用Session：

1. **URL重写**：将Session ID附加在URL后面
   ```java
   response.encodeURL("/someUrl");
   ```
2. **隐藏表单字段**：在表单中添加Session ID
   ```html
   <input type="hidden" name="jsessionid" value="...">
   ```
3. **本地存储**：使用localStorage或sessionStorage存储Session ID

这些方法的核心都是将会话ID通过其他方式传递给服务器，而不仅仅依赖Cookie。

# 面试题详细解答

## 一、项目设计问题

### 1. 权限系统设计

**RBAC (基于角色的访问控制) 设计**：
1. **核心表设计**：
   - 用户表(user)：存储用户基本信息
   - 角色表(role)：定义角色类型
   - 权限表(permission)：定义具体权限
   - 用户角色关联表(user_role)
   - 角色权限关联表(role_permission)

2. **扩展设计**：
   - 数据权限：控制用户能看到的数据范围
   - 操作权限：控制用户能执行的操作
   - 菜单权限：控制用户能看到的菜单项

3. **权限验证流程**：
   - 用户登录 → 获取角色 → 获取权限 → 缓存权限 → 请求时验证

### 2. 数据库平台支持的数据库类型

常见数据库类型：
1. **关系型数据库**：MySQL, PostgreSQL, Oracle, SQL Server
2. **NoSQL数据库**：
   - 键值存储：Redis, Memcached
   - 文档数据库：MongoDB
   - 列式数据库：HBase, Cassandra
   - 图数据库：Neo4j
3. **时序数据库**：InfluxDB, TimescaleDB
4. **搜索引擎**：Elasticsearch

### 3. 在线DDL策略

**在线DDL (Data Definition Language) 策略**：
1. **MySQL 5.6+**：支持部分在线DDL操作
   - ALTER TABLE ... ALGORITHM=INPLACE/LOCK=NONE
2. **工具辅助**：
   - pt-online-schema-change (Percona)
   - gh-ost (GitHub)
3. **策略选择**：
   - 小表：直接执行
   - 大表：使用工具，低峰期执行
   - 关键表：先备后改，灰度发布

### 4. 临时资源点设计

**设计方案**：
1. **数据库设计**：
   ```sql
   CREATE TABLE user_temp_resource (
     id BIGINT PRIMARY KEY,
     user_id BIGINT,
     resource_type VARCHAR(32),
     amount INT,
     expire_time DATETIME,
     INDEX idx_user (user_id),
     INDEX idx_expire (expire_time)
   );
   ```
2. **实现逻辑**：
   - 定时任务清理过期资源
   - 使用Redis缓存热点数据
   - 分布式锁控制并发操作

## 二、技术原理问题

### 1. EXPLAIN中的system类型

**system**是EXPLAIN输出中最好的连接类型，当：
- 查询只有一行记录（系统表）
- 使用主键或唯一索引的等值查询
- 是const类型的特例，非常高效

### 2. HashMap的put插入原理

**put操作流程**：
1. 计算key的hashCode()
2. 通过hash算法确定桶位置
3. 遍历链表/红黑树：
   - 存在相同key（equals()为true）：替换value
   - 不存在：插入新节点
4. 判断是否需要扩容（负载因子0.75）
5. 链表转红黑树（链表长度≥8且桶数量≥64）

**关键点**：
- 重写equals()必须重写hashCode()
- 不同对象可能有相同hashCode
- 相同hashCode的对象equals()不一定相同

### 3. ThreadLocal使用与内存泄漏

**正常使用方式**：
```java
// 声明
private static final ThreadLocal<User> userHolder = new ThreadLocal<>();

// 设置值
userHolder.set(currentUser);

// 获取值
User user = userHolder.get();

// 移除
userHolder.remove();
```

**静态类变量问题**：
- ThreadLocal通常声明为static，但存储的值是线程独立的
- static保证所有线程共享同一个ThreadLocal实例

**内存泄漏风险**：
1. **原因**：
   - ThreadLocalMap的key是弱引用，value是强引用
   - 线程池场景下线程长期存活，value无法回收
2. **解决方案**：
   - 使用后及时调用remove()
   - 避免使用线程池+ThreadLocal组合

## 三、网络协议问题

### 1. TCP vs UDP应用场景

| 特性 | TCP | UDP |
|------|-----|-----|
| 连接 | 面向连接 | 无连接 |
| 可靠性 | 可靠传输 | 不可靠 |
| 顺序 | 保证顺序 | 不保证 |
| 速度 | 较慢 | 较快 |
| 应用 | HTTP, FTP, SSH | DNS, 视频流, 游戏 |

### 2. 滑动窗口与有序性

**滑动窗口机制**：
- 保证数据按序到达接收方
- 通过序列号和确认应答实现
- 窗口大小动态调整（流量控制）

**真正有序**：
- 在TCP协议栈内保证数据按序递交应用层
- 但应用层处理时可能重新排序（如多线程处理）
- 所以是"传输有序"而非"处理有序"

## 四、手撕代码：单链表反转

```java
/**
 * 单链表节点定义
 */
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}

public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    
    while (curr != null) {
        ListNode nextTemp = curr.next; // 保存下一个节点
        curr.next = prev;             // 反转指针
        prev = curr;                  // 前移prev
        curr = nextTemp;              // 前移curr
    }
    
    return prev; // 新头节点
}

// 递归解法
public ListNode reverseListRecursive(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode p = reverseListRecursive(head.next);
    head.next.next = head;
    head.next = null;
    return p;
}
```

**关键点**：
- 迭代法需要三个指针：prev, curr, next
- 递归法要注意终止条件和指针修改顺序
- 时间复杂度：O(n)，空间复杂度：迭代O(1)，递归O(n)

# 面试复盘与改进建议

## 面试情况分析

从你的描述来看，这是一次典型的技术面试，虽然面试官没开摄像头让你感觉可能是KPI面试，但问题都是常规的技术考察点。你遇到的主要问题是：

1. 多线程转账题目没完全写好
2. MVCC解释不够通顺
3. 第一次面大厂紧张影响发挥

## 各问题标准答案与改进建议

### 1. 自我介绍

**改进建议**：
- 准备1分钟和3分钟两个版本
- 遵循"背景-技术栈-项目经验-个人特点"结构
- 突出与岗位匹配的技术能力

### 2. 实习和项目

**改进建议**：
- 使用STAR法则描述项目(Situation-Task-Action-Result)
- 准备2-3个技术亮点和难点
- 量化项目成果(如QPS提升多少、延迟降低多少)

### 3. 多线程转账问题

**标准解法**：

```java
public class BankAccount {
    private final ReentrantLock lock = new ReentrantLock();
    private int balance;

    public boolean transfer(BankAccount to, int amount) {
        // 获取两个账户的锁，避免死锁(按固定顺序获取)
        BankAccount first = this.hashCode() < to.hashCode() ? this : to;
        BankAccount second = this.hashCode() < to.hashCode() ? to : this;
        
        first.lock.lock();
        try {
            second.lock.lock();
            try {
                if (this.balance >= amount) {
                    this.balance -= amount;
                    to.balance += amount;
                    return true;
                }
                return false;
            } finally {
                second.lock.unlock();
            }
        } finally {
            first.lock.unlock();
        }
    }
}
```

**改进建议**：
1. 掌握基本的并发控制模式
2. 理解死锁产生条件和避免方法
3. 练习经典的"哲学家就餐"、"读者写者"等问题

### 4. ArrayList扩容机制

**标准答案**：
- 初始容量：10(无参构造)
- 扩容规则：newCapacity = oldCapacity + (oldCapacity >> 1)(即1.5倍)
- 扩容时机：add时发现size+1 > elementData.length
- 大数组处理：hugeCapacity处理(Integer.MAX_VALUE - 8限制)

### 5. synchronized和ReentrantLock区别

**标准答案对比**：

| 特性 | synchronized | ReentrantLock |
|------|-------------|--------------|
| 实现 | JVM原生支持 | JDK实现 |
| 锁获取 | 自动获取释放 | 必须手动释放 |
| 公平性 | 非公平 | 可配置 |
| 中断 | 不支持 | 支持 |
| 条件 | 单一等待队列 | 多条件队列 |
| 性能 | 优化后差距不大 | 更灵活 |

### 6. AQS(AbstractQueuedSynchronizer)

**标准答案要点**：
- JDK并发包核心基础框架
- 基于FIFO等待队列和volatile state状态变量
- 采用模板方法模式
- 实现类：ReentrantLock、CountDownLatch等
- 关键方法：acquire/release、tryAcquire/tryRelease

### 7. CAS(Compare And Swap)

**标准答案要点**：
- 无锁算法核心机制
- 原子操作：比较并交换(当前值==期望值则更新)
- Unsafe类提供底层支持
- ABA问题及解决方案(版本号/Stamp)
- 应用：AtomicXXX类、AQS、并发容器

### 8. MVCC(多版本并发控制)

**标准答案框架**：
1. **核心思想**：通过数据多版本实现读不阻塞写
2. **实现要素**：
   - 版本链(undo log)
   - ReadView(一致性视图)
   - 可见性算法
3. **InnoDB实现**：
   - 隐藏字段(DB_TRX_ID, DB_ROLL_PTR)
   - 隔离级别实现差异(RR/RC)
4. **优点**：提高并发性能，避免读写冲突

### 9. 线程池核心参数与拒绝策略

**标准答案**：

**核心参数**：
1. corePoolSize：核心线程数
2. maximumPoolSize：最大线程数
3. keepAliveTime：空闲线程存活时间
4. workQueue：任务队列
5. threadFactory：线程工厂
6. handler：拒绝策略

**拒绝策略**：
1. AbortPolicy(默认)：抛出RejectedExecutionException
2. CallerRunsPolicy：调用者线程执行
3. DiscardPolicy：直接丢弃任务
4. DiscardOldestPolicy：丢弃队列最老任务

### 10. 乐观锁与悲观锁

**标准对比**：

| 特性 | 悲观锁 | 乐观锁 |
|------|-------|-------|
| 假设 | 一定会冲突 | 可能不冲突 |
| 实现 | synchronized, Lock | CAS,版本号 |
| 开销 | 大 | 小 |
| 适用 | 写多读少 | 读多写少 |
| 示例 | 数据库行锁 | MVCC,AtomicInteger |

## 反问环节改进建议

**优化版反问**：
1. 业务方向："请问团队目前在做的核心业务和技术方向是什么？"
2. 表现反馈："您觉得我的技术能力与岗位要求还有哪些差距？"
3. 流程细节："后续的面试流程和时间安排是怎样的？"
4. 附加问题："如果有幸加入，您建议我入职前重点准备哪些知识？"

## 后续提升建议

1. **并发编程**：
   - 重读《Java并发编程实战》
   - 练习LeetCode多线程题目
   - 理解JUC包实现原理

2. **MySQL深度**：
   - 研究InnoDB存储引擎
   - 分析不同隔离级别实现
   - 练习EXPLAIN优化SQL

3. **面试技巧**：
   - 模拟面试训练表达流畅度
   - 建立技术问题回答框架
   - 准备项目难点的话术

4. **心态调整**：
   - 把每次面试当学习机会
   - 建立错题本记录薄弱点
   - 大厂面试前先找中小厂练手

虽然这次收到了感谢信，但每个成功的大厂offer背后平均有5-8次失败面试。建议保持每周2-3场的面试节奏，2个月后会有明显提升。
