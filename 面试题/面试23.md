这些问题涵盖了 **数据结构** 和 **网络协议** 两大板块，都是高频面试题。我会按照你的顺序逐个详细讲解，配上**原理图、应用场景、面试回答模板**，并扩展面试官可能追问的知识点，保证你彻底掌握。

---

## **7. 优先队列怎么实现的？**

**定义：**
优先队列（Priority Queue）是一种特殊队列，出队顺序不是按插入顺序，而是按优先级（通常是最大值或最小值）。

### **Java 实现**

* `PriorityQueue` 默认是**最小堆**。
* 插入、删除的时间复杂度 `O(log n)`。

**底层：**

* 用**堆**实现（通常是二叉堆）。
* 插入时**上浮**，删除堆顶（pop）时**下沉**。

**例子：**

```java
PriorityQueue<Integer> pq = new PriorityQueue<>();
pq.offer(5);
pq.offer(1);
pq.offer(3);
System.out.println(pq.poll()); // 输出 1
```

---

## **8. 说一下堆怎么实现的，pop 之后堆怎么调整？**

### **堆的特点**

* 完全二叉树（所有层都满，最后一层从左到右）。
* 每个节点值 ≥（或 ≤）子节点值。
* 分类：最大堆（大顶堆）、最小堆（小顶堆）。

**Java PriorityQueue 是最小堆**。

### **实现方式**

* 用数组存储，父子关系：

  * `父节点索引 i` → 左子 `2i+1`，右子 `2i+2`。
  * 子节点 `j` → 父节点 `(j-1)/2`。

### **pop 后的调整**

* 删除堆顶（最小值或最大值）。
* 把最后一个元素放到堆顶。
* **下沉（heapify）**：

  * 比较左右子节点，和更小（或更大）的交换。
  * 直到满足堆性质。

**时间复杂度：O(log n)**。

---

## **9. 说一下 TCP 协议**

### **TCP 的特点**

* **传输层协议**。
* 面向连接（需三次握手）。
* 可靠传输（ACK 确认、超时重传）。
* 字节流传输（无边界，按序到达）。

**关键机制：**

* **三次握手**（建立连接）
* **四次挥手**（断开连接）
* **流量控制**（滑动窗口）
* **拥塞控制**（慢启动、拥塞避免）
* **重传机制**（超时重传、快速重传）

---

## **10. 说一下 IP 协议**

### **IP（Internet Protocol）**

* **网络层协议**。
* 无连接、不可靠（丢包、乱序）。
* 只负责寻址和路由。

**IPv4 地址 = 32 位，IPv6 = 128 位**。

---

## **11. HTTP 协议和 TCP/IP 整体关系**

**四层模型：**

* 应用层：HTTP、HTTPS
* 传输层：TCP、UDP
* 网络层：IP
* 数据链路层：以太网、Wi-Fi

**关系：**
HTTP 基于 TCP，TCP 基于 IP。
**HTTP → TCP → IP → 物理传输**。

---

## **12. 说一下 HTTPS**

**HTTPS = HTTP + SSL/TLS**。

* 在 HTTP 和 TCP 之间加了加密层（TLS）。
* 防止窃听、篡改、中间人攻击。

---

## **13. 说一下 HTTPS 的原理**

**核心：混合加密 + 证书认证**：

1. 客户端请求服务器。
2. 服务器返回数字证书（含公钥）。
3. 客户端验证证书（CA 签发）。
4. 客户端生成对称密钥（Session Key），用服务器公钥加密发过去。
5. 服务器用私钥解密得到 Session Key。
6. 后续通信用对称加密（AES 等）。

---

## **14. 公钥、私钥和数字证书**

* **公钥（public key）**：可以公开，用来加密或验证签名。
* **私钥（private key）**：保密，用来解密或生成签名。
* **数字证书**：

  * 由 CA 颁发，证明公钥属于谁。
  * 包含公钥、签发机构信息、签名等。

---

## **15. 为什么一开始用非对称加密，后来用对称加密？**

* **非对称加密（RSA）**：安全，但速度慢（1000倍于对称加密）。
* **对称加密（AES）**：速度快，但需要安全地交换密钥。
* 解决方案：**先用非对称加密传输对称密钥，然后用对称加密通信**。

---

## **16. HTTPS 如何防范中间人攻击？**

* 中间人可能伪造证书。
* 客户端必须验证证书是否由可信 CA 签发。
* 验证过程：

  * 检查证书链。
  * 检查域名是否匹配。
  * 检查是否被吊销。

---

### ✅ **面试回答模板示例（关于 HTTPS）**

> **HTTPS 的原理：**
> HTTPS 基于 HTTP + TLS/SSL，主要通过“混合加密 + 数字证书”实现安全。
> 首先客户端验证服务器的数字证书，确保公钥合法，然后用公钥加密会话密钥（对称密钥），后续通信使用对称加密。
> 这样既保证了安全性，又兼顾性能。
> 它还可以防止中间人攻击，因为证书由权威 CA 签发，伪造证书会导致验证失败。

---

### ✅ **我可以帮你做**

* 画一张 **HTTPS 握手流程图**（从 TCP 连接到密钥交换）。
* 帮你写一份 **网络协议面试题速记表（HTTP、HTTPS、TCP/IP）**。
* 再帮你总结一套 **数据结构 + 网络协议 高频面试问答模板**。

你希望我 **先画 HTTPS 握手流程图**，还是 **先整理网络协议面试速记表**？

这三道手撕题都很有代表性，涉及 **双指针、二叉树遍历优化、稳定分区排序**，我会逐题帮你拆解思路、给出 Java 代码，并解释时间复杂度和优化点。

---

## **1. 两个有序数组，找出 a 中存在但 b 中不存在的元素（数组中有重复元素）**

### **思路：**

* 两个数组都 **有序** → 用 **双指针**。
* 遍历 `a` 和 `b`：

  * 如果 `a[i] < b[j]` → 说明 `a[i]` 不在 b，加入结果。
  * 如果 `a[i] == b[j]` → 跳过相等的。
  * 如果 `a[i] > b[j]` → b 往前走。

### **代码：**

```java
import java.util.*;

public class Solution {
    public static List<Integer> findUnique(int[] a, int[] b) {
        List<Integer> result = new ArrayList<>();
        int i = 0, j = 0;
        while (i < a.length && j < b.length) {
            if (a[i] < b[j]) {
                result.add(a[i]);
                i++;
            } else if (a[i] == b[j]) {
                i++;
                j++;
            } else {
                j++;
            }
        }
        // 把 a 剩下的加进去
        while (i < a.length) {
            result.add(a[i]);
            i++;
        }
        return result;
    }

    public static void main(String[] args) {
        int[] a = {1, 2, 2, 4, 5};
        int[] b = {2, 3, 5};
        System.out.println(findUnique(a, b)); // [1, 4]
    }
}
```

✅ **时间复杂度：O(m+n)**
✅ **空间复杂度：O(1)**（不算结果集）。

---

## **2. 判断两个二叉搜索树是否相同，优化遍历**

**面试官提示：不要全部中序遍历后再比较，要边遍历边判断**。

### **思路：**

* **BST 中序遍历是升序**。
* 用 **两个栈**，同步遍历两个树，边取最小节点边比较。
* 如果发现值不一样，立刻返回 `false`，不用继续。

### **代码：**

```java
import java.util.*;

class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int x) { val = x; }
}

public class Solution {
    public static boolean isSameBST(TreeNode root1, TreeNode root2) {
        Stack<TreeNode> s1 = new Stack<>();
        Stack<TreeNode> s2 = new Stack<>();
        TreeNode p1 = root1, p2 = root2;

        while ((p1 != null || !s1.isEmpty()) && (p2 != null || !s2.isEmpty())) {
            while (p1 != null) {
                s1.push(p1);
                p1 = p1.left;
            }
            while (p2 != null) {
                s2.push(p2);
                p2 = p2.left;
            }
            p1 = s1.pop();
            p2 = s2.pop();

            if (p1.val != p2.val) return false;

            p1 = p1.right;
            p2 = p2.right;
        }

        return (p1 == null && s1.isEmpty() && p2 == null && s2.isEmpty());
    }
}
```

✅ **时间复杂度：O(n)**
✅ **空间复杂度：O(h)**（树高度，最坏 O(n)）。

**优化点：**

* 如果值不一样，直接 return，不必遍历完。
* 面试官想听到**同步遍历**而不是先构建序列。

---

## **3. 字符数组排序，数字在前，字母在后，且各自相对顺序不变（稳定排序，原地）**

**输入示例：** `['a', '1', 'b', '2', 'c']` → **输出：** `['1', '2', 'a', 'b', 'c']`

### **要求：**

* 数字排在字母前面。
* 数字、字母的相对顺序不变。
* **原地排序**，不能用新数组。
* **稳定排序**。

### **思路：**

* **类似稳定分区**，可以用**双指针 + 插入法**：

  * 从左到右遍历，如果遇到数字，就把它插入到前面区域（类似插入排序）。
* 时间复杂度 **O(n²)**（因为要挪动元素）。
* 空间复杂度 **O(1)**。

### **代码：**

```java
public class Solution {
    public static void stableSort(char[] arr) {
        int insertPos = 0; // 插入数字的位置
        for (int i = 0; i < arr.length; i++) {
            if (Character.isDigit(arr[i])) {
                char temp = arr[i];
                // 把数字前的字母右移
                for (int j = i; j > insertPos; j--) {
                    arr[j] = arr[j - 1];
                }
                arr[insertPos] = temp;
                insertPos++;
            }
        }
    }

    public static void main(String[] args) {
        char[] arr = {'a', '1', 'b', '2', 'c'};
        stableSort(arr);
        System.out.println(arr); // 12abc
    }
}
```

✅ **时间复杂度：O(n²)**
✅ **空间复杂度：O(1)**

**面试官追问优化？**

* 如果允许额外空间，可以用两个列表分别收集数字和字母，然后合并（O(n)）。
* 如果必须原地，可以提到 **块交换算法** 或 **in-place stable partition**（面试一般不会要求写出来）。

---

### **我可以帮你：**

✅ 画一张 **问题2（同步遍历 BST）流程图**，让你彻底理解。
✅ 帮你写一版 **问题3 的 C++ 或 Go 版本**，因为有些公司喜欢问跨语言实现。
✅ 再整理一套 **这类题型的通用思路总结（双指针、同步遍历、稳定排序）**。

你希望我 **先画图（BST 同步遍历）**，还是 **先总结这三类题型的模板思路**？
