# 技术面试深度解析

## 一、ShardingSphere分库分表策略

### 核心分片策略

1. **标准分片策略**：
   - `StandardShardingStrategy`：支持精确分片和范围分片
   - 实现接口：`PreciseShardingAlgorithm`和`RangeShardingAlgorithm`

2. **复合分片策略**：
   - `ComplexShardingStrategy`：支持多分片键组合分片
   - 实现`ComplexKeysShardingAlgorithm`接口

3. **行表达式分片策略**：
   - `InlineShardingStrategy`：基于Groovy表达式实现简单分片
   - 配置示例：`ds$->{order_id % 2}`

4. **Hint分片策略**：
   - `HintShardingStrategy`：通过编程方式指定分片
   - 使用`HintManager`强制路由

### 分片算法类型

1. **精确分片**：
   ```java
   public interface PreciseShardingAlgorithm<T extends Comparable<?>> {
       String doSharding(Collection<String> availableTargetNames, PreciseShardingValue<T> shardingValue);
   }
   ```

2. **范围分片**：
   ```java
   public interface RangeShardingAlgorithm<T extends Comparable<?>> {
       Collection<String> doSharding(Collection<String> availableTargetNames, RangeShardingValue<T> shardingValue);
   }
   ```

3. **复合分片**：
   ```java
   public interface ComplexKeysShardingAlgorithm {
       Collection<String> doSharding(Collection<String> availableTargetNames, Collection<ShardingValue> shardingValues);
   }
   ```

### 分库分表配置示例

```yaml
spring:
  shardingsphere:
    datasource:
      names: ds0,ds1
    sharding:
      tables:
        t_order:
          actual-data-nodes: ds$->{0..1}.t_order_$->{0..1}
          database-strategy:
            inline:
              sharding-column: user_id
              algorithm-expression: ds$->{user_id % 2}
          table-strategy:
            inline:
              sharding-column: order_id
              algorithm-expression: t_order_$->{order_id % 2}
```

## 二、Sentinel使用与限流算法

### Sentinel核心功能

1. **流量控制**：
   - 基于QPS/并发数的流量控制
   - 基于调用关系的流量控制

2. **熔断降级**：
   - 慢调用比例
   - 异常比例
   - 异常数

3. **系统保护**：
   - 自适应系统保护
   - 全局系统指标保护

### 常见限流算法

1. **计数器算法**：
   - 固定时间窗口计数
   - 实现简单但有临界问题

2. **滑动窗口算法**：
   - 将时间划分为多个小窗口
   - 统计最近N个窗口的请求量

3. **漏桶算法**：
   - 以恒定速率处理请求
   - 突发流量会被缓冲

4. **令牌桶算法**：
   - 以固定速率生成令牌
   - 请求需要获取令牌才能执行

5. **分布式限流**：
   - 基于Redis的分布式计数器
   - 基于分布式协调服务的限流

### Sentinel配置示例

```java
@Configuration
public class SentinelConfig {
    
    @PostConstruct
    public void initRules() {
        // 流控规则
        List<FlowRule> rules = new ArrayList<>();
        FlowRule rule = new FlowRule();
        rule.setResource("resourceName");
        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
        rule.setCount(10); // 阈值
        rules.add(rule);
        FlowRuleManager.loadRules(rules);
        
        // 熔断规则
        List<DegradeRule> degradeRules = new ArrayList<>();
        DegradeRule degradeRule = new DegradeRule();
        degradeRule.setResource("resourceName");
        degradeRule.setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO);
        degradeRule.setCount(0.5); // 异常比例阈值
        degradeRule.setTimeWindow(10); // 熔断时间(s)
        degradeRules.add(degradeRule);
        DegradeRuleManager.loadRules(degradeRules);
    }
}
```

## 三、RocketMQ使用实践

### 核心概念

1. **消息模型**：
   - Producer Group
   - Consumer Group
   - Topic
   - MessageQueue

2. **消息类型**：
   - 普通消息
   - 顺序消息
   - 事务消息
   - 延迟消息

### 基本使用示例

```java
// 生产者
public class Producer {
    public static void main(String[] args) throws Exception {
        DefaultMQProducer producer = new DefaultMQProducer("producer_group");
        producer.setNamesrvAddr("localhost:9876");
        producer.start();
        
        Message msg = new Message("TopicTest", "TagA", "Hello RocketMQ".getBytes());
        SendResult result = producer.send(msg);
        System.out.println(result);
        
        producer.shutdown();
    }
}

// 消费者
public class Consumer {
    public static void main(String[] args) throws Exception {
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("consumer_group");
        consumer.setNamesrvAddr("localhost:9876");
        consumer.subscribe("TopicTest", "*");
        
        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {
            for (MessageExt msg : msgs) {
                System.out.println(new String(msg.getBody()));
            }
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        });
        
        consumer.start();
    }
}
```

### 高级特性

1. **事务消息**：
   ```java
   TransactionMQProducer producer = new TransactionMQProducer("group");
   producer.setTransactionListener(new TransactionListener() {
       @Override
       public LocalTransactionState executeLocalTransaction(Message msg, Object arg) {
           // 执行本地事务
           return LocalTransactionState.COMMIT_MESSAGE;
       }
       
       @Override
       public LocalTransactionState checkLocalTransaction(MessageExt msg) {
           // 检查本地事务状态
           return LocalTransactionState.COMMIT_MESSAGE;
       }
   });
   ```

2. **顺序消息**：
   ```java
   // 生产者确保相同shardingKey的消息发送到同一个队列
   producer.send(msg, new MessageQueueSelector() {
       @Override
       public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {
           Integer id = (Integer) arg;
           int index = id % mqs.size();
           return mqs.get(index);
       }
   }, shardingKey);
   ```

## 四、微服务框架架构

### 典型微服务框架组成

1. **服务治理**：
   - 服务注册与发现
   - 负载均衡
   - 熔断降级

2. **配置中心**：
   - 动态配置管理
   - 配置版本控制

3. **API网关**：
   - 路由转发
   - 鉴权认证
   - 流量控制

4. **分布式事务**：
   - 最终一致性方案
   - TCC模式
   - SAGA模式

5. **链路追踪**：
   - 请求链路追踪
   - 性能监控

### Spring Cloud Alibaba技术栈

| 组件 | 功能 | 替代方案 |
|------|------|---------|
| Nacos | 服务注册/配置中心 | Eureka/Consul |
| Sentinel | 流量控制/熔断降级 | Hystrix |
| RocketMQ | 消息队列 | Kafka/RabbitMQ |
| Seata | 分布式事务 | 无 |
| Dubbo | RPC框架 | gRPC |

## 五、RPC核心组成

### RPC架构核心组件

1. **客户端(Client)**：
   - 服务代理生成
   - 序列化/反序列化
   - 网络通信

2. **服务端(Server)**：
   - 服务注册
   - 请求分发
   - 方法调用

3. **注册中心**：
   - 服务发现
   - 健康检查
   - 负载均衡

4. **序列化协议**：
   - Protobuf
   - Thrift
   - JSON
   - Hessian

5. **网络传输**：
   - TCP长连接
   - HTTP/2
   - 连接池管理

6. **负载均衡**：
   - 随机
   - 轮询
   - 一致性哈希
   - 最少活跃调用

### RPC调用流程

1. 客户端代理封装调用信息
2. 序列化调用参数
3. 通过网络传输到服务端
4. 服务端反序列化并定位方法
5. 执行方法并返回结果
6. 结果序列化传回客户端
7. 客户端反序列化并返回

## 六、Nacos注册信息

### Nacos注册的核心信息

1. **基础信息**：
   - 服务名
   - 分组名
   - 集群名
   - 命名空间

2. **实例信息**：
   - IP地址
   - 端口号
   - 健康状态
   - 权重值
   - 元数据(自定义信息)

3. **健康检查**：
   - 心跳间隔
   - 健康检查超时时间
   - 健康检查模式(TCP/HTTP/MySQL等)

### Nacos服务发现数据模型

```json
{
  "serviceName": "user-service",
  "groupName": "DEFAULT_GROUP",
  "clusters": "DEFAULT",
  "instances": [
    {
      "instanceId": "10.0.0.1#8080#DEFAULT#DEFAULT_GROUP@@user-service",
      "ip": "10.0.0.1",
      "port": 8080,
      "weight": 1.0,
      "healthy": true,
      "metadata": {
        "version": "1.0",
        "env": "prod"
      }
    }
  ]
}
```

## 七、Nacos发布协议

### Nacos支持的协议

1. **服务发现协议**：
   - 基于HTTP/RESTful API
   - 基于gRPC(1.x版本新增)

2. **配置管理协议**：
   - 基于HTTP长轮询
   - 基于gRPC长连接

3. **客户端通信**：
   - UDP(用于服务健康检查)
   - TCP(用于服务实例心跳)

### 协议选择策略

1. **默认情况**：
   - Java客户端优先使用gRPC
   - 其他语言客户端使用HTTP

2. **配置方式**：
   ```properties
   # 强制使用HTTP协议
   nacos.client.naming.use.endpoint.parsing.rule=false
   nacos.client.naming.server.port=8848
   ```

3. **性能对比**：
   - gRPC协议性能更高，连接更稳定
   - HTTP协议兼容性更好

## 八、链表重排算法

### 问题描述

将链表 1→2→3→4→5→6 转换为 1→6→2→5→3→4

### 解决方案

1. **快慢指针找中点**
2. **反转后半部分**
3. **合并两个链表**

```java
public void reorderList(ListNode head) {
    if (head == null || head.next == null) return;
    
    // 1. 找中点
    ListNode slow = head, fast = head;
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // 2. 反转后半部分
    ListNode prev = null, curr = slow.next;
    slow.next = null; // 断开链表
    while (curr != null) {
        ListNode next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    
    // 3. 合并两个链表
    ListNode first = head, second = prev;
    while (second != null) {
        ListNode next1 = first.next, next2 = second.next;
        first.next = second;
        second.next = next1;
        first = next1;
        second = next2;
    }
}
```

### 复杂度分析

- 时间复杂度：O(n)
- 空间复杂度：O(1)

## 九、Redis知识体系

### Redis核心特性

1. **数据结构**：
   - String：缓存、计数器
   - Hash：对象存储
   - List：消息队列
   - Set：标签系统
   - ZSet：排行榜
   - Bitmap：位操作
   - HyperLogLog：基数统计
   - Stream：消息流

2. **持久化**：
   - RDB：定时快照
   - AOF：日志追加
   - 混合持久化(Redis 4.0+)

3. **高可用**：
   - 主从复制
   - 哨兵模式
   - Redis Cluster

4. **高级功能**：
   - 事务
   - Lua脚本
   - 发布订阅
   - 管道技术

### Redis使用场景

1. **缓存**：
   - 缓存穿透/雪崩/击穿解决方案
   - 多级缓存架构

2. **会话存储**：
   - 分布式Session
   - Token管理

3. **排行榜**：
   - ZSET实现实时排行

4. **分布式锁**：
   - SETNX实现
   - RedLock算法

5. **限流**：
   - 令牌桶算法实现

## 十、Linux常用命令

### 系统信息

1. **系统信息**：
   ```bash
   uname -a  # 系统信息
   cat /etc/os-release  # 发行版信息
   uptime  # 运行时间
   ```

2. **硬件信息**：
   ```bash
   free -h  # 内存使用
   df -h  # 磁盘空间
   lscpu  # CPU信息
   ```

### 文件操作

1. **文件管理**：
   ```bash
   ls -al  # 详细列表
   cp -r src dest  # 递归复制
   mv old new  # 移动/重命名
   rm -rf dir  # 强制删除
   ```

2. **文件查看**：
   ```bash
   cat file  # 查看文件
   less file  # 分页查看
   tail -f logfile  # 跟踪日志
   head -n 10 file  # 查看前10行
   ```

### 网络相关

1. **网络配置**：
   ```bash
   ifconfig  # 网络接口
   ip addr  # IP地址
   netstat -tulnp  # 端口监听
   ```

2. **网络测试**：
   ```bash
   ping host  # 连通性测试
   telnet host port  # 端口测试
   curl -I url  # HTTP请求
   wget url  # 下载文件
   ```

### 进程管理

1. **进程查看**：
   ```bash
   ps aux  # 所有进程
   top  # 实时进程监控
   htop  # 增强版top
   ```

2. **进程控制**：
   ```bash
   kill -9 pid  # 强制终止进程
   pkill name  # 按名称杀进程
   nice -n 10 command  # 调整优先级
   ```

### 权限管理

1. **权限设置**：
   ```bash
   chmod 755 file  # 权限设置
   chown user:group file  # 所有者设置
   ```

2. **用户管理**：
   ```bash
   useradd username  # 添加用户
   passwd username  # 修改密码
   su - username  # 切换用户
   ```

### 系统管理

1. **服务管理**：
   ```bash
   systemctl start service  # 启动服务
   systemctl enable service  # 开机启动
   journalctl -u service  # 查看服务日志
   ```

2. **包管理**：
   ```bash
   apt install package  # Ubuntu安装
   yum install package  # CentOS安装
   rpm -ivh package.rpm  # RPM安装
   ```

### 文本处理

1. **文本处理**：
   ```bash
   grep pattern file  # 文本搜索
   awk '{print $1}' file  # 字段提取
   sed 's/old/new/g' file  # 文本替换
   ```

2. **压缩解压**：
   ```bash
   tar -czvf archive.tar.gz dir  # 压缩
   tar -xzvf archive.tar.gz  # 解压
   zip -r archive.zip dir  # ZIP压缩
   unzip archive.zip  # ZIP解压
   ```

### 性能监控

1. **性能工具**：
   ```bash
   vmstat 1  # 虚拟内存统计
   iostat 1  # IO统计
   sar -n DEV 1  # 网络统计
   ```

2. **调试工具**：
   ```bash
   strace -p pid  # 系统调用跟踪
   lsof -i :8080  # 查看端口占用
   tcpdump -i eth0 port 80  # 网络抓包
   ```
