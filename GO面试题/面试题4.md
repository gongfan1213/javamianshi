å¥½çš„ï¼Œç°åœ¨è¿›å…¥ï¼š

---

## âœ… ç¬¬åå››ä¸ªçŸ¥è¯†ç‚¹ï¼šGo å¸¸ç”¨æ ‡å‡†åº“ï¼ˆstringsã€strconvã€sortã€timeã€contextã€errors ç­‰ï¼‰

Go æä¾›äº†éå¸¸å¼ºå¤§çš„æ ‡å‡†åº“ï¼Œæ¶µç›–å­—ç¬¦ä¸²å¤„ç†ã€æ—¶é—´ã€æ’åºã€å¹¶å‘æ§åˆ¶ã€é”™è¯¯å¤„ç†ç­‰ï¼Œæ˜¯é¢è¯•å’Œå®æˆ˜ä¸­**å¿…å¤‡æŠ€èƒ½**ã€‚

---

## ğŸ”¹ 1. `strings`ï¼šå­—ç¬¦ä¸²å¤„ç†

```go
import "strings"

strings.Contains("hello", "ll")      // true
strings.HasPrefix("http://", "http") // true
strings.ToUpper("abc")               // "ABC"
strings.Split("a,b,c", ",")          // ["a" "b" "c"]
strings.Join([]string{"a", "b"}, "-")// "a-b"
```

---

## ğŸ”¹ 2. `strconv`ï¼šå­—ç¬¦ä¸²ä¸æ•°å­—ç±»å‹äº’è½¬

```go
import "strconv"

// string -> int
i, err := strconv.Atoi("123")

// int -> string
s := strconv.Itoa(123)

// float -> string
f := strconv.FormatFloat(3.14, 'f', 2, 64) // "3.14"

// string -> float
val, err := strconv.ParseFloat("3.14", 64)
```

---

## ğŸ”¹ 3. `sort`ï¼šæ’åº

### âœ… åŸºæœ¬æ’åº

```go
import "sort"

nums := []int{3, 1, 4, 2}
sort.Ints(nums)               // å‡åºæ’åº

names := []string{"bob", "alice"}
sort.Strings(names)           // å­—ç¬¦ä¸²æ’åº
```

### âœ… è‡ªå®šä¹‰æ’åº

```go
people := []Person{
    {"Tom", 18},
    {"Alice", 25},
}
sort.Slice(people, func(i, j int) bool {
    return people[i].Age < people[j].Age
})
```

---

## ğŸ”¹ 4. `time`ï¼šæ—¶é—´å¤„ç†

```go
import "time"

now := time.Now()
fmt.Println(now.Format("2006-01-02 15:04:05"))  // ç‰¹å®šæ ¼å¼

// æ—¶é—´åŠ å‡
later := now.Add(time.Hour * 2)

// æ—¶é—´æ¯”è¾ƒ
if now.Before(later) {
    fmt.Println("now is earlier")
}

// ç¡çœ 
time.Sleep(2 * time.Second)
```

---

## ğŸ”¹ 5. `context`ï¼šæ§åˆ¶ goroutine çš„ç”Ÿå‘½å‘¨æœŸï¼ˆè¶…æ—¶ã€å–æ¶ˆï¼‰

è¿™æ˜¯ç°ä»£ Go å¹¶å‘ç¼–ç¨‹ä¸­**å¿…è€ƒç‚¹**ã€‚

```go
import "context"

// è®¾ç½®è¶…æ—¶
ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
defer cancel()

select {
case <-time.After(3 * time.Second):
    fmt.Println("timeout not triggered")
case <-ctx.Done():
    fmt.Println("Timeout or canceled:", ctx.Err())
}
```

---

## ğŸ”¹ 6. `errors` å’Œ `fmt.Errorf`ï¼šé”™è¯¯å¤„ç†

```go
import (
    "errors"
    "fmt"
)

func do() error {
    return errors.New("something went wrong")
}

func another() error {
    return fmt.Errorf("failed to do: %w", do())
}
```

---

## ğŸ”¹ 7. `math/rand`ï¼šç”Ÿæˆéšæœºæ•°

```go
import "math/rand"

rand.Seed(time.Now().UnixNano()) // åˆå§‹åŒ–ç§å­
n := rand.Intn(100)              // [0, 100) çš„éšæœºæ•´æ•°
```

---

## âœ… æ€»ç»“å»ºè®®

| æ ‡å‡†åº“       | é‡ç‚¹åŠŸèƒ½                    |
| --------- | ----------------------- |
| `strings` | å­—ç¬¦ä¸²æŸ¥æ‰¾ã€æ›¿æ¢ã€åˆ†å‰²ã€è¿æ¥          |
| `strconv` | å­—ç¬¦ä¸²ä¸æ•°å€¼äº’è½¬                |
| `sort`    | åˆ‡ç‰‡æ’åºã€è‡ªå®šä¹‰æ’åº              |
| `time`    | æ—¶é—´è·å–ã€æ ¼å¼åŒ–ã€æ¯”è¾ƒã€å»¶è¿Ÿ          |
| `context` | goroutine å–æ¶ˆã€è¶…æ—¶å¤„ç†ï¼ˆå¹¶å‘å¿…å­¦ï¼‰ |
| `errors`  | é”™è¯¯åˆ›å»ºã€åŒ…è£¹ã€å¤„ç†              |

è¿™äº›æ ‡å‡†åº“æå¤§ç®€åŒ–äº†å¼€å‘å·¥ä½œï¼Œå¹¶ä¸”åœ¨å®é™…å¼€å‘å’Œé¢è¯•ä¸­**é¢‘ç¹ä½¿ç”¨**ï¼Œå»ºè®®ç†Ÿç»ƒæŒæ¡ã€‚

---

ä¸‹ä¸€ä¸ªå†…å®¹å°†æ˜¯ï¼š**Go è¯­è¨€ä¸­çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼ˆerror æ¥å£ã€panic/recoverï¼‰**

å¦‚æœä½ å‡†å¤‡å¥½äº†ï¼Œè¯·å›å¤ï¼š**ä¸‹ä¸€ä¸ª**ã€‚



å¥½çš„ï¼Œç°åœ¨è¿›å…¥ï¼š

---

## âœ… ç¬¬åäº”ä¸ªçŸ¥è¯†ç‚¹ï¼šGo è¯­è¨€çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼ˆ`error` æ¥å£ã€`panic` å’Œ `recover`ï¼‰

Go çš„é”™è¯¯å¤„ç†æ˜¯å®ƒå’Œ Java è¯­æ³•é£æ ¼**æœ€ä¸åŒ**çš„åœ°æ–¹ä¹‹ä¸€ï¼š**æ²¡æœ‰å¼‚å¸¸æ•è·æœºåˆ¶ï¼ˆtry-catchï¼‰**ï¼Œè€Œæ˜¯é€šè¿‡è¿”å›å€¼å’Œæ¥å£æ¥å®ç°ã€‚

---

### ğŸ”¹1. `error` æ¥å£ï¼ˆæ¨èæ–¹å¼ï¼‰

Go ä¸­ä»»ä½•å®ç°äº†å¦‚ä¸‹æ¥å£çš„ç±»å‹éƒ½è¢«è§†ä¸ºä¸€ä¸ªé”™è¯¯ï¼š

```go
type error interface {
    Error() string
}
```

### âœ… åˆ›å»ºé”™è¯¯ï¼š

```go
import "errors"

err := errors.New("something went wrong")
fmt.Println(err.Error())  // è¾“å‡º: something went wrong
```

### âœ… è¿”å›é”™è¯¯çš„å‡½æ•°ï¼š

```go
func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}
```

### âœ… ä½¿ç”¨ï¼š

```go
result, err := divide(10, 0)
if err != nil {
    fmt.Println("Error:", err)
    return
}
fmt.Println("Result:", result)
```

---

### ğŸ”¹2. `fmt.Errorf`ï¼šæ ¼å¼åŒ–å¹¶åŒ…è£…é”™è¯¯

```go
import "fmt"

func readFile(name string) error {
    return fmt.Errorf("failed to read %s: %w", name, errors.New("file not found"))
}
```

* `%w` è¡¨ç¤ºåŒ…è£¹å¦ä¸€ä¸ªé”™è¯¯ï¼ˆGo 1.13+ï¼‰
* ä½¿ç”¨ `errors.Is` / `errors.As` åˆ¤æ–­å’Œæå–åº•å±‚é”™è¯¯ç±»å‹

---

### ğŸ”¹3. `panic`ï¼šé‡åˆ°ä¸å¯æ¢å¤çš„é”™è¯¯æ—¶ä¸­æ­¢ç¨‹åº

```go
func crash() {
    panic("something fatal happened")
}
```

* `panic` ä¼šå¯¼è‡´ç¨‹åºä¸­æ­¢æ‰§è¡Œï¼ˆç±»ä¼¼ Java çš„ throwï¼‰
* å¸¸è§ç”¨é€”ï¼šç¨‹åºå¯åŠ¨å¤±è´¥ã€æ•°ç»„è¶Šç•Œã€ç©ºæŒ‡é’ˆç­‰

---

### ğŸ”¹4. `recover`ï¼šä» `panic` ä¸­æ¢å¤

åªèƒ½åœ¨ `defer` ä¸­è°ƒç”¨ï¼Œé˜²æ­¢ç¨‹åºå´©æºƒã€‚

```go
func safeRun() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }()
    panic("boom!")
}

func main() {
    safeRun()
    fmt.Println("Program continues")
}
```

---

### âœ… é”™è¯¯å¤„ç†æ€»ç»“å¯¹æ¯”ï¼ˆJava vs Goï¼‰

| è¯­è¨€   | é”™è¯¯å¤„ç†æœºåˆ¶                        |
| ---- | ----------------------------- |
| Java | `try-catch`, `throw`          |
| Go   | `error` è¿”å›å€¼ï¼Œ`panic`/`recover` |

Go é¼“åŠ±**è¿”å›å€¼æ˜¾å¼ä¼ é€’é”™è¯¯**ï¼Œè€Œééšè—åœ¨å¼‚å¸¸ä¸­ï¼Œè¿™æ ·ç¨‹åºé€»è¾‘æ›´åŠ æ˜ç¡®ã€‚

---

### âœ… æœ€ä½³å®è·µ

* ä¸æ¨èç”¨ `panic` æ¥å¤„ç†æ™®é€šé”™è¯¯
* æ‰€æœ‰å‡½æ•°å¦‚æœ‰å¯èƒ½å‡ºé”™ï¼Œéƒ½åº”è¿”å› `(T, error)`
* é‡åˆ° `err != nil` å°±ç«‹åˆ»å¤„ç†æˆ–è¿”å›

---

ä¸‹ä¸€èŠ‚å†…å®¹æ˜¯ï¼š**Go çš„å¹¶å‘ç¼–ç¨‹ï¼šgoroutineã€channelã€select**

è¿™éƒ¨åˆ†éå¸¸é‡è¦ï¼Œæ˜¯ Go è¯­è¨€é¢è¯•çš„é«˜é¢‘è€ƒç‚¹ã€‚

å¦‚æœä½ å‡†å¤‡å¥½äº†ï¼Œè¯·å›å¤ï¼š**ä¸‹ä¸€ä¸ª**ã€‚


å¥½çš„ï¼Œç°åœ¨è¿›å…¥ï¼š

---

## âœ… ç¬¬åå…­ä¸ªçŸ¥è¯†ç‚¹ï¼šGo çš„å¹¶å‘ç¼–ç¨‹ï¼ˆGoroutineã€Channelã€Selectï¼‰

Go æœ€å¤§çš„äº®ç‚¹ä¹‹ä¸€å°±æ˜¯å†…å»ºçš„å¹¶å‘æ”¯æŒï¼Œæ ¸å¿ƒå°±æ˜¯ï¼š`goroutine` + `channel`ï¼Œå¼ºè°ƒ **CSPï¼ˆé€šä¿¡é¡ºåºè¿›ç¨‹ï¼‰æ¨¡å‹**ã€‚

---

### ğŸ”¹1. ä»€ä¹ˆæ˜¯ goroutineï¼Ÿ

* goroutine æ˜¯ Go çš„**è½»é‡çº§çº¿ç¨‹**ï¼ˆåç¨‹ï¼‰
* å¯åŠ¨æ–¹å¼éå¸¸ç®€å•ï¼Œä½¿ç”¨ `go` å…³é”®å­—å³å¯

```go
func sayHello() {
    fmt.Println("Hello from goroutine")
}

func main() {
    go sayHello()   // æ–°å»ºä¸€ä¸ª goroutine å¼‚æ­¥æ‰§è¡Œ
    time.Sleep(1 * time.Second) // ç­‰å¾… goroutine å®Œæˆ
}
```

> âš ï¸ æ³¨æ„ï¼šä¸» goroutine å¦‚æœå…ˆç»“æŸï¼Œå…¶ä»– goroutine ä¼šè¢«å¼ºåˆ¶é€€å‡ºã€‚

---

### ğŸ”¹2. Channelï¼šç”¨äº goroutine ä¹‹é—´é€šä¿¡

Channel æ˜¯ Go æä¾›çš„**çº¿ç¨‹å®‰å…¨**é€šä¿¡æœºåˆ¶ã€‚

```go
ch := make(chan int) // åˆ›å»ºä¸€ä¸ª int ç±»å‹çš„ channel

// å†™å…¥
go func() {
    ch <- 10 // å‘é€æ•°æ®
}()

// è¯»å–
value := <-ch
fmt.Println(value) // è¾“å‡º 10
```

---

### ğŸ”¸ Channel ç‰¹æ€§ï¼š

* **é˜»å¡ç‰¹æ€§**ï¼š

  * å‘é€æ–¹åœ¨æ²¡æœ‰æ¥æ”¶æ–¹ä¹‹å‰ä¼šé˜»å¡
  * æ¥æ”¶æ–¹åœ¨æ²¡æœ‰æ•°æ®ä¹‹å‰ä¹Ÿä¼šé˜»å¡
* **å¯å…³é—­**ï¼š

  ```go
  close(ch)
  ```

---

### ğŸ”¹3. æœ‰ç¼“å†² vs æ— ç¼“å†² Channel

```go
// æ— ç¼“å†²ï¼šé»˜è®¤
ch := make(chan int)

// æœ‰ç¼“å†²ï¼š
ch := make(chan int, 2)
```

* æ— ç¼“å†²ï¼šå‘é€å’Œæ¥æ”¶å¿…é¡»åŒæ­¥
* æœ‰ç¼“å†²ï¼šå‘é€æ–¹å¯ä»¥æå‰å†™å…¥ï¼Œç›´åˆ°æ»¡

---

### ğŸ”¹4. `select`ï¼šç›‘å¬å¤šä¸ª channel

```go
ch1 := make(chan string)
ch2 := make(chan string)

go func() { ch1 <- "from ch1" }()
go func() { ch2 <- "from ch2" }()

select {
case msg1 := <-ch1:
    fmt.Println(msg1)
case msg2 := <-ch2:
    fmt.Println(msg2)
default:
    fmt.Println("no data")
}
```

* `select` ä¼šç­‰å¾…**ç¬¬ä¸€ä¸ªå‡†å¤‡å¥½çš„é€šé“**
* å¯ç”¨äº**è¶…æ—¶**ã€**å¤šè·¯ç›‘å¬**

---

### ğŸ”¹5. é€šä¿¡æ–¹å‘é™åˆ¶ï¼ˆé¢è¯•è€ƒç‚¹ï¼‰

```go
func send(ch chan<- int) {
    ch <- 1
}

func recv(ch <-chan int) {
    fmt.Println(<-ch)
}
```

* `chan<- T`ï¼šåªèƒ½å†™
* `<-chan T`ï¼šåªèƒ½è¯»

---

### ğŸ”¹6. ä½¿ç”¨ `sync.WaitGroup` ç­‰å¾…å¤šä¸ª goroutine

```go
var wg sync.WaitGroup

for i := 0; i < 3; i++ {
    wg.Add(1)
    go func(i int) {
        defer wg.Done()
        fmt.Println("Goroutine", i)
    }(i)
}

wg.Wait()
```

---

### âœ… å¸¸è§é¢è¯•é¢˜ç‚¹ï¼š

| è€ƒç‚¹                  | è§£é‡Š             |
| ------------------- | -------------- |
| goroutine ç‰¹æ€§        | è½»é‡ï¼Œä¸ç­‰åŒäº OS çº¿ç¨‹  |
| channel é˜»å¡          | æ— ç¼“å†²ä¼šé˜»å¡         |
| select              | å¤šé€šé“ç›‘å¬          |
| sync.WaitGroup      | ç­‰å¾…æ‰€æœ‰ goroutine |
| `chan<-` / `<-chan` | é€šä¿¡æ–¹å‘é™åˆ¶         |

---

### âœ… Java å¼€å‘è€…å¯¹æ¯”ç†è§£ï¼š

| Java          | Go           |
| ------------- | ------------ |
| Thread        | goroutine    |
| BlockingQueue | channel      |
| Runnable      | goroutine å‡½æ•° |
| synchronized  | channel ä¿è¯åŒæ­¥ |

---

ä¸‹ä¸€èŠ‚å†…å®¹æ˜¯ï¼š**Go çš„ç½‘ç»œç¼–ç¨‹ä¸ HTTP æœåŠ¡ï¼ˆnet/http åŒ…ï¼‰**

å¦‚æœä½ å‡†å¤‡å¥½äº†ï¼Œè¯·å›å¤ï¼š**ä¸‹ä¸€ä¸ª**ã€‚


å¥½çš„ï¼Œæˆ‘ä»¬ç°åœ¨è¿›å…¥ï¼š

---

## âœ… ç¬¬åä¸ƒä¸ªçŸ¥è¯†ç‚¹ï¼šGo çš„ç½‘ç»œç¼–ç¨‹ä¸ HTTP æœåŠ¡ï¼ˆ`net/http`ï¼‰

Go åŸç”Ÿæ”¯æŒç½‘ç»œç¼–ç¨‹ï¼Œå¹¶å†…ç½®äº†å®Œæ•´çš„ HTTP æœåŠ¡èƒ½åŠ›ï¼Œéå¸¸é€‚åˆæ„å»º API æœåŠ¡æˆ– Web åº”ç”¨ã€‚

---

## ğŸ”¹1. å¿«é€Ÿæ„å»ºä¸€ä¸ª HTTP æœåŠ¡å™¨

Go çš„æ ‡å‡†åº“ `net/http` æä¾›äº†ä¸€è¡Œä»£ç å¯åŠ¨ Web æœåŠ¡çš„èƒ½åŠ›ã€‚

```go
package main

import (
	"fmt"
	"net/http"
)

func helloHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "Hello, Go HTTP!")
}

func main() {
	http.HandleFunc("/", helloHandler)
	http.ListenAndServe(":8080", nil) // å¯åŠ¨ HTTP æœåŠ¡ï¼Œç›‘å¬ 8080 ç«¯å£
}
```

---

### ğŸ”¸ `http.ListenAndServe(address, handler)`

* `:8080` è¡¨ç¤ºç›‘å¬æœ¬åœ°æ‰€æœ‰ IP çš„ 8080 ç«¯å£
* ç¬¬äºŒä¸ªå‚æ•°ä¸º `nil` æ—¶ï¼Œä¼šä½¿ç”¨é»˜è®¤çš„ `http.DefaultServeMux`

---

## ğŸ”¹2. è·¯ç”±ä¸å¤„ç†å™¨ï¼ˆHandlerï¼‰

### HandlerFunc æœ¬è´¨æ˜¯å‡½æ•°ç±»å‹ï¼š

```go
type HandlerFunc func(http.ResponseWriter, *http.Request)
```

ä¹Ÿå¯ä»¥è‡ªå®šä¹‰ç»“æ„ä½“å®ç°æ¥å£ï¼š

```go
type MyHandler struct{}

func (h MyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "This is a custom handler")
}

func main() {
	http.ListenAndServe(":8080", MyHandler{})
}
```

---

## ğŸ”¹3. `http.Request` å’Œ `http.ResponseWriter`

* `*http.Request`: è¯·æ±‚å¯¹è±¡ï¼ŒåŒ…å«è¯·æ±‚å¤´ã€è·¯å¾„ã€å‚æ•°ã€æ–¹æ³•ç­‰
* `http.ResponseWriter`: å“åº”å¯¹è±¡ï¼Œç”¨äºå†™å›å†…å®¹

### ç¤ºä¾‹ï¼šè¯»å–è¯·æ±‚æ–¹æ³•å’Œå‚æ•°

```go
func handler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Method: %s\n", r.Method)
	r.ParseForm()
	fmt.Fprintf(w, "Params: %v", r.Form)
}
```

---

## ğŸ”¹4. POST è¯·æ±‚æ•°æ®å¤„ç†ï¼ˆJSONï¼‰

```go
func postHandler(w http.ResponseWriter, r *http.Request) {
	var data map[string]string
	json.NewDecoder(r.Body).Decode(&data)
	fmt.Fprintf(w, "Received: %v", data)
}
```

---

## ğŸ”¹5. è®¾ç½® HTTP å“åº”çŠ¶æ€ç å’Œå¤´éƒ¨

```go
w.Header().Set("Content-Type", "application/json")
w.WriteHeader(http.StatusCreated) // 201
w.Write([]byte(`{"message": "created"}`))
```

---

## ğŸ”¹6. è·¯ç”±åˆ†ç»„æ¨èä½¿ç”¨ç¬¬ä¸‰æ–¹åº“ `gorilla/mux`ï¼ˆå¯é€‰ï¼‰

```go
import "github.com/gorilla/mux"

r := mux.NewRouter()
r.HandleFunc("/users/{id}", userHandler)
http.ListenAndServe(":8080", r)
```

---

## âœ… å¸¸è§é¢è¯•é¢˜ç‚¹ï¼š

| é—®é¢˜                | è§£ç­”                              |
| ----------------- | ------------------------------- |
| å¦‚ä½•å¯åŠ¨ HTTP æœåŠ¡ï¼Ÿ     | `http.ListenAndServe`           |
| Handler æœ‰å‡ ç§å†™æ³•ï¼Ÿ    | å‡½æ•°å½¢å¼ / å®ç°æ¥å£                     |
| å¦‚ä½•è¯»å–è¯·æ±‚å‚æ•°ï¼Ÿ         | `r.Form`, `r.URL.Query()`       |
| å¦‚ä½•å“åº” JSONï¼Ÿ        | `w.Header().Set + json.Marshal` |
| å¦‚ä½•å¤„ç† POST/PUT è¯·æ±‚ï¼Ÿ | `r.Body` è§£ç  JSON                |

---

## âœ… Java å¯¹ç…§ç†è§£ï¼š

| Java Servlet          | Go HTTP               |
| --------------------- | --------------------- |
| `HttpServletRequest`  | `*http.Request`       |
| `HttpServletResponse` | `http.ResponseWriter` |
| è·¯ç”±é…ç½®åœ¨ web.xml         | `http.HandleFunc`     |
| Tomcat                | Go è‡ªå¸¦ HTTP Server     |

---

## âœ… ç¤ºä¾‹ï¼šRESTful API æ¡†æ¶éª¨æ¶

```go
func main() {
	http.HandleFunc("/users", getUsers)
	http.HandleFunc("/users/create", createUser)
	log.Println("Server running at :8080")
	http.ListenAndServe(":8080", nil)
}
```

---

ä¸‹ä¸€èŠ‚å†…å®¹æ˜¯ï¼š**Go çš„é”™è¯¯å¤„ç†ä¸ panic/recover æœºåˆ¶**

å¦‚æœä½ å‡†å¤‡å¥½äº†ï¼Œè¯·å›å¤ï¼š**ä¸‹ä¸€ä¸ª**ã€‚
