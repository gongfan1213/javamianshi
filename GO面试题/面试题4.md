好的，现在进入：

---

## ✅ 第十四个知识点：Go 常用标准库（strings、strconv、sort、time、context、errors 等）

Go 提供了非常强大的标准库，涵盖字符串处理、时间、排序、并发控制、错误处理等，是面试和实战中**必备技能**。

---

## 🔹 1. `strings`：字符串处理

```go
import "strings"

strings.Contains("hello", "ll")      // true
strings.HasPrefix("http://", "http") // true
strings.ToUpper("abc")               // "ABC"
strings.Split("a,b,c", ",")          // ["a" "b" "c"]
strings.Join([]string{"a", "b"}, "-")// "a-b"
```

---

## 🔹 2. `strconv`：字符串与数字类型互转

```go
import "strconv"

// string -> int
i, err := strconv.Atoi("123")

// int -> string
s := strconv.Itoa(123)

// float -> string
f := strconv.FormatFloat(3.14, 'f', 2, 64) // "3.14"

// string -> float
val, err := strconv.ParseFloat("3.14", 64)
```

---

## 🔹 3. `sort`：排序

### ✅ 基本排序

```go
import "sort"

nums := []int{3, 1, 4, 2}
sort.Ints(nums)               // 升序排序

names := []string{"bob", "alice"}
sort.Strings(names)           // 字符串排序
```

### ✅ 自定义排序

```go
people := []Person{
    {"Tom", 18},
    {"Alice", 25},
}
sort.Slice(people, func(i, j int) bool {
    return people[i].Age < people[j].Age
})
```

---

## 🔹 4. `time`：时间处理

```go
import "time"

now := time.Now()
fmt.Println(now.Format("2006-01-02 15:04:05"))  // 特定格式

// 时间加减
later := now.Add(time.Hour * 2)

// 时间比较
if now.Before(later) {
    fmt.Println("now is earlier")
}

// 睡眠
time.Sleep(2 * time.Second)
```

---

## 🔹 5. `context`：控制 goroutine 的生命周期（超时、取消）

这是现代 Go 并发编程中**必考点**。

```go
import "context"

// 设置超时
ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
defer cancel()

select {
case <-time.After(3 * time.Second):
    fmt.Println("timeout not triggered")
case <-ctx.Done():
    fmt.Println("Timeout or canceled:", ctx.Err())
}
```

---

## 🔹 6. `errors` 和 `fmt.Errorf`：错误处理

```go
import (
    "errors"
    "fmt"
)

func do() error {
    return errors.New("something went wrong")
}

func another() error {
    return fmt.Errorf("failed to do: %w", do())
}
```

---

## 🔹 7. `math/rand`：生成随机数

```go
import "math/rand"

rand.Seed(time.Now().UnixNano()) // 初始化种子
n := rand.Intn(100)              // [0, 100) 的随机整数
```

---

## ✅ 总结建议

| 标准库       | 重点功能                    |
| --------- | ----------------------- |
| `strings` | 字符串查找、替换、分割、连接          |
| `strconv` | 字符串与数值互转                |
| `sort`    | 切片排序、自定义排序              |
| `time`    | 时间获取、格式化、比较、延迟          |
| `context` | goroutine 取消、超时处理（并发必学） |
| `errors`  | 错误创建、包裹、处理              |

这些标准库极大简化了开发工作，并且在实际开发和面试中**频繁使用**，建议熟练掌握。

---

下一个内容将是：**Go 语言中的错误处理机制（error 接口、panic/recover）**

如果你准备好了，请回复：**下一个**。



好的，现在进入：

---

## ✅ 第十五个知识点：Go 语言的错误处理机制（`error` 接口、`panic` 和 `recover`）

Go 的错误处理是它和 Java 语法风格**最不同**的地方之一：**没有异常捕获机制（try-catch）**，而是通过返回值和接口来实现。

---

### 🔹1. `error` 接口（推荐方式）

Go 中任何实现了如下接口的类型都被视为一个错误：

```go
type error interface {
    Error() string
}
```

### ✅ 创建错误：

```go
import "errors"

err := errors.New("something went wrong")
fmt.Println(err.Error())  // 输出: something went wrong
```

### ✅ 返回错误的函数：

```go
func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}
```

### ✅ 使用：

```go
result, err := divide(10, 0)
if err != nil {
    fmt.Println("Error:", err)
    return
}
fmt.Println("Result:", result)
```

---

### 🔹2. `fmt.Errorf`：格式化并包装错误

```go
import "fmt"

func readFile(name string) error {
    return fmt.Errorf("failed to read %s: %w", name, errors.New("file not found"))
}
```

* `%w` 表示包裹另一个错误（Go 1.13+）
* 使用 `errors.Is` / `errors.As` 判断和提取底层错误类型

---

### 🔹3. `panic`：遇到不可恢复的错误时中止程序

```go
func crash() {
    panic("something fatal happened")
}
```

* `panic` 会导致程序中止执行（类似 Java 的 throw）
* 常见用途：程序启动失败、数组越界、空指针等

---

### 🔹4. `recover`：从 `panic` 中恢复

只能在 `defer` 中调用，防止程序崩溃。

```go
func safeRun() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }()
    panic("boom!")
}

func main() {
    safeRun()
    fmt.Println("Program continues")
}
```

---

### ✅ 错误处理总结对比（Java vs Go）

| 语言   | 错误处理机制                        |
| ---- | ----------------------------- |
| Java | `try-catch`, `throw`          |
| Go   | `error` 返回值，`panic`/`recover` |

Go 鼓励**返回值显式传递错误**，而非隐藏在异常中，这样程序逻辑更加明确。

---

### ✅ 最佳实践

* 不推荐用 `panic` 来处理普通错误
* 所有函数如有可能出错，都应返回 `(T, error)`
* 遇到 `err != nil` 就立刻处理或返回

---

下一节内容是：**Go 的并发编程：goroutine、channel、select**

这部分非常重要，是 Go 语言面试的高频考点。

如果你准备好了，请回复：**下一个**。


好的，现在进入：

---

## ✅ 第十六个知识点：Go 的并发编程（Goroutine、Channel、Select）

Go 最大的亮点之一就是内建的并发支持，核心就是：`goroutine` + `channel`，强调 **CSP（通信顺序进程）模型**。

---

### 🔹1. 什么是 goroutine？

* goroutine 是 Go 的**轻量级线程**（协程）
* 启动方式非常简单，使用 `go` 关键字即可

```go
func sayHello() {
    fmt.Println("Hello from goroutine")
}

func main() {
    go sayHello()   // 新建一个 goroutine 异步执行
    time.Sleep(1 * time.Second) // 等待 goroutine 完成
}
```

> ⚠️ 注意：主 goroutine 如果先结束，其他 goroutine 会被强制退出。

---

### 🔹2. Channel：用于 goroutine 之间通信

Channel 是 Go 提供的**线程安全**通信机制。

```go
ch := make(chan int) // 创建一个 int 类型的 channel

// 写入
go func() {
    ch <- 10 // 发送数据
}()

// 读取
value := <-ch
fmt.Println(value) // 输出 10
```

---

### 🔸 Channel 特性：

* **阻塞特性**：

  * 发送方在没有接收方之前会阻塞
  * 接收方在没有数据之前也会阻塞
* **可关闭**：

  ```go
  close(ch)
  ```

---

### 🔹3. 有缓冲 vs 无缓冲 Channel

```go
// 无缓冲：默认
ch := make(chan int)

// 有缓冲：
ch := make(chan int, 2)
```

* 无缓冲：发送和接收必须同步
* 有缓冲：发送方可以提前写入，直到满

---

### 🔹4. `select`：监听多个 channel

```go
ch1 := make(chan string)
ch2 := make(chan string)

go func() { ch1 <- "from ch1" }()
go func() { ch2 <- "from ch2" }()

select {
case msg1 := <-ch1:
    fmt.Println(msg1)
case msg2 := <-ch2:
    fmt.Println(msg2)
default:
    fmt.Println("no data")
}
```

* `select` 会等待**第一个准备好的通道**
* 可用于**超时**、**多路监听**

---

### 🔹5. 通信方向限制（面试考点）

```go
func send(ch chan<- int) {
    ch <- 1
}

func recv(ch <-chan int) {
    fmt.Println(<-ch)
}
```

* `chan<- T`：只能写
* `<-chan T`：只能读

---

### 🔹6. 使用 `sync.WaitGroup` 等待多个 goroutine

```go
var wg sync.WaitGroup

for i := 0; i < 3; i++ {
    wg.Add(1)
    go func(i int) {
        defer wg.Done()
        fmt.Println("Goroutine", i)
    }(i)
}

wg.Wait()
```

---

### ✅ 常见面试题点：

| 考点                  | 解释             |
| ------------------- | -------------- |
| goroutine 特性        | 轻量，不等同于 OS 线程  |
| channel 阻塞          | 无缓冲会阻塞         |
| select              | 多通道监听          |
| sync.WaitGroup      | 等待所有 goroutine |
| `chan<-` / `<-chan` | 通信方向限制         |

---

### ✅ Java 开发者对比理解：

| Java          | Go           |
| ------------- | ------------ |
| Thread        | goroutine    |
| BlockingQueue | channel      |
| Runnable      | goroutine 函数 |
| synchronized  | channel 保证同步 |

---

下一节内容是：**Go 的网络编程与 HTTP 服务（net/http 包）**

如果你准备好了，请回复：**下一个**。


好的，我们现在进入：

---

## ✅ 第十七个知识点：Go 的网络编程与 HTTP 服务（`net/http`）

Go 原生支持网络编程，并内置了完整的 HTTP 服务能力，非常适合构建 API 服务或 Web 应用。

---

## 🔹1. 快速构建一个 HTTP 服务器

Go 的标准库 `net/http` 提供了一行代码启动 Web 服务的能力。

```go
package main

import (
	"fmt"
	"net/http"
)

func helloHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "Hello, Go HTTP!")
}

func main() {
	http.HandleFunc("/", helloHandler)
	http.ListenAndServe(":8080", nil) // 启动 HTTP 服务，监听 8080 端口
}
```

---

### 🔸 `http.ListenAndServe(address, handler)`

* `:8080` 表示监听本地所有 IP 的 8080 端口
* 第二个参数为 `nil` 时，会使用默认的 `http.DefaultServeMux`

---

## 🔹2. 路由与处理器（Handler）

### HandlerFunc 本质是函数类型：

```go
type HandlerFunc func(http.ResponseWriter, *http.Request)
```

也可以自定义结构体实现接口：

```go
type MyHandler struct{}

func (h MyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "This is a custom handler")
}

func main() {
	http.ListenAndServe(":8080", MyHandler{})
}
```

---

## 🔹3. `http.Request` 和 `http.ResponseWriter`

* `*http.Request`: 请求对象，包含请求头、路径、参数、方法等
* `http.ResponseWriter`: 响应对象，用于写回内容

### 示例：读取请求方法和参数

```go
func handler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Method: %s\n", r.Method)
	r.ParseForm()
	fmt.Fprintf(w, "Params: %v", r.Form)
}
```

---

## 🔹4. POST 请求数据处理（JSON）

```go
func postHandler(w http.ResponseWriter, r *http.Request) {
	var data map[string]string
	json.NewDecoder(r.Body).Decode(&data)
	fmt.Fprintf(w, "Received: %v", data)
}
```

---

## 🔹5. 设置 HTTP 响应状态码和头部

```go
w.Header().Set("Content-Type", "application/json")
w.WriteHeader(http.StatusCreated) // 201
w.Write([]byte(`{"message": "created"}`))
```

---

## 🔹6. 路由分组推荐使用第三方库 `gorilla/mux`（可选）

```go
import "github.com/gorilla/mux"

r := mux.NewRouter()
r.HandleFunc("/users/{id}", userHandler)
http.ListenAndServe(":8080", r)
```

---

## ✅ 常见面试题点：

| 问题                | 解答                              |
| ----------------- | ------------------------------- |
| 如何启动 HTTP 服务？     | `http.ListenAndServe`           |
| Handler 有几种写法？    | 函数形式 / 实现接口                     |
| 如何读取请求参数？         | `r.Form`, `r.URL.Query()`       |
| 如何响应 JSON？        | `w.Header().Set + json.Marshal` |
| 如何处理 POST/PUT 请求？ | `r.Body` 解码 JSON                |

---

## ✅ Java 对照理解：

| Java Servlet          | Go HTTP               |
| --------------------- | --------------------- |
| `HttpServletRequest`  | `*http.Request`       |
| `HttpServletResponse` | `http.ResponseWriter` |
| 路由配置在 web.xml         | `http.HandleFunc`     |
| Tomcat                | Go 自带 HTTP Server     |

---

## ✅ 示例：RESTful API 框架骨架

```go
func main() {
	http.HandleFunc("/users", getUsers)
	http.HandleFunc("/users/create", createUser)
	log.Println("Server running at :8080")
	http.ListenAndServe(":8080", nil)
}
```

---

下一节内容是：**Go 的错误处理与 panic/recover 机制**

如果你准备好了，请回复：**下一个**。
