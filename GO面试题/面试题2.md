error,defer,panicrecover

一旦触发panic，当前函数立即中止，并且开始向上传播，栈展开，直到主程序崩溃

很好，接下来我们进入 Go 中非常独特、面试高频的部分：

---

### ✅ 第七个知识点：错误处理（`error`）、`defer`、`panic`、`recover`

Go 的错误处理方式和 Java 的异常机制完全不同，**没有 try-catch**，更加强调显式返回错误，风格偏“工程健壮性”。

---

## 🔹 1. `error` 类型（Go 的错误返回机制）

Go 没有 Java 的 `throw`，而是返回 `error` 接口。

```go
import "errors"

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("除数不能为0")
    }
    return a / b, nil
}

result, err := divide(10, 0)
if err != nil {
    fmt.Println("出错了:", err)
} else {
    fmt.Println("结果是:", result)
}
```

* `errors.New()` 创建简单错误信息。
* `nil` 表示没有错误。
* 调用者必须主动判断 `err`，这是 Go 的哲学：“**错误不是异常，是返回值的一部分**”。

---

## 🔹 2. 自定义 error 类型（实现 `Error() string` 方法）

```go
type MyError struct {
    Msg string
}

func (e *MyError) Error() string {
    return "自定义错误: " + e.Msg
}

func do() error {
    return &MyError{Msg: "出问题了"}
}
```

* `error` 是接口，只要实现 `Error() string` 方法即可。

---

## 🔹 3. `defer`（延迟执行）

**defer 语句**用于注册函数，在函数结束（return 或 panic）时执行，常用于释放资源、记录日志等。

```go
func readFile() {
    fmt.Println("打开文件")
    defer fmt.Println("关闭文件") // 函数退出时执行

    fmt.Println("读取文件")
}
```

运行顺序：

```
打开文件
读取文件
关闭文件
```

✅ 支持多个 `defer`，**先进后出（类似栈）**。

---

## 🔹 4. `panic`（等价 Java 的抛出异常）

```go
func crash() {
    panic("程序崩溃了")
}
```

一旦触发 panic，当前函数立即中止，并开始向上传播（栈展开），直到主程序崩溃。

---

## 🔹 5. `recover`（捕获 panic）

配合 `defer` 使用，可恢复程序执行，相当于 Java 的 `try-catch-finally`：

```go
func safe() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("捕获到 panic:", r)
        }
    }()
    
    panic("错误发生")
    fmt.Println("这行不会执行")
}
```

* `recover()` 只能在 `defer` 中生效。
* 如果 `recover()` 捕获了 panic，程序不会崩溃。

---

## ✅ 错误处理机制总结（Java vs Go）

| 特性    | Java                  | Go                        |
| ----- | --------------------- | ------------------------- |
| 错误表示  | `throw new Exception` | `return error`（interface） |
| 错误处理  | `try-catch`           | `if err != nil {}`        |
| 自定义错误 | 自定义异常类                | 实现 `error` 接口             |
| 延迟处理  | `finally`             | `defer`                   |
| 异常中止  | 抛出后必须 catch 或声明       | `panic()`                 |
| 异常恢复  | `catch` 中恢复           | `recover()`               |

---

## ✅ 小练习题：

1. 写一个函数 `readConfig(path string) (string, error)`，当路径为空时返回错误。
2. 写一个函数 `dangerous()`，里面调用 `panic("boom")`，再写一个函数 `safeCall()`，通过 `recover()` 捕获错误。
3. 使用 `defer` 打印日志，观察执行顺序。

---

下一节，我们将讲解 **Go 的模块管理（go.mod）、包导入、自定义包结构、init 函数、项目结构设计**，这是工程开发必会的内容。

继续的话，请说“**下一个**”。

go get github.com/gi-gonic/gin

go.mod管理版本的和依赖的，类似java的pom.xml的maven或者build.gradel(Gradle)

每个子目录对应一个包Package,包名通常和文件夹的名字是一致的

go里面导入的是模块+路径的

每个包当中给所有的init会在该包首次被使用的时候执行，多个包就是按照import的顺序初始化的

多个包按照import的顺序初始化的，每个包所有的init会在该包首次被使用的时候执行的，
package xxx+文件夹路径结构的，init函数，大写导出/小写私有的，

很好，现在我们进入 Go 实际项目开发中必不可少的一部分：

---

### ✅ 第八个知识点：模块管理（`go.mod`）、包导入、自定义包结构、`init()` 函数、项目结构设计

这些内容主要解决以下几个问题：

* 如何组织你的项目代码？
* 如何导入自己的代码包？
* 如何管理依赖？
* 项目启动时有哪些自动初始化行为？

---

## 🔹 1. `go.mod` 模块管理（Go Modules）

Go 从 1.11 开始支持模块系统（正式在 1.16 默认开启），用于替代 `GOPATH`。

初始化一个项目模块：

```bash
go mod init myproject
```

会生成一个 `go.mod` 文件，内容示例：

```
module myproject

go 1.20
```

安装依赖：

```bash
go get github.com/gin-gonic/gin
```

✅ `go.mod` 管理版本和依赖，类似 Java 的 `pom.xml`（Maven）或 `build.gradle`（Gradle）。

---

## 🔹 2. 项目结构（推荐）

典型项目结构如下：

```
myproject/
├── go.mod
├── main.go
├── utils/
│   └── mathutil.go
├── service/
│   └── user.go
```

* 每个子目录对应一个包（package）。
* 包名通常和文件夹名一致。

---

## 🔹 3. 自定义包（package）和导入（import）

#### utils/mathutil.go：

```go
package utils

func Add(a, b int) int {
    return a + b
}
```

#### main.go 中使用：

```go
package main

import (
    "fmt"
    "myproject/utils"
)

func main() {
    result := utils.Add(3, 4)
    fmt.Println(result)
}
```

✅ Go 里导入的是模块 + 路径，比如 `myproject/utils`，和文件夹保持一致。

---

## 🔹 4. `init()` 函数（自动执行的初始化逻辑）

Go 每个包中可以有一个或多个 `init()` 函数，在程序启动时自动执行（早于 `main()`），常用于初始化配置、连接数据库、加载缓存等：

```go
func init() {
    fmt.Println("init 被执行")
}
```

执行顺序：

* 每个包中所有 `init()` 会在该包首次被使用时执行
* 多个包则按 import 顺序初始化

---

## 🔹 5. `main()` 函数（程序入口）

只有在 `main` 包中的 `main()` 函数会被作为程序入口执行。

---

## 🔹 6. 包的可见性（大小写区分）

* 首字母大写的函数/变量：**可导出（public）**
* 首字母小写的函数/变量：**仅包内可见（private）**

```go
// utils/mathutil.go
package utils

var PublicVar = 1    // 可见
var privateVar = 2   // 仅限包内

func PublicFunc() {} // 可见
func privateFunc() {}// 包内使用
```

类似 Java 中的 `public` / `default` 权限控制。

---

## ✅ 模块与包管理总结（Go vs Java）

| 特性     | Java                      | Go                      |
| ------ | ------------------------- | ----------------------- |
| 依赖管理   | Maven / Gradle            | `go mod`                |
| 项目入口   | `public static void main` | `func main()`           |
| 包管理    | `package com.example`     | `package xxx` + 文件夹路径结构 |
| 自动初始化  | 静态块 `static{}`            | `init()` 函数             |
| 访问权限控制 | public/private/default    | 大写导出 / 小写私有             |

---

## ✅ 小练习：

1. 创建一个新模块 `mathapp`，写一个包 `calc`，实现 `Add(a, b int) int`，在 `main()` 中调用。
2. 在 `calc` 包中添加一个 `init()` 打印初始化信息，验证执行顺序。
3. 观察文件夹结构与 `import` 路径的对应关系。

---

下一节我们将进入高级部分：**泛型（Go 1.18+）、反射（reflect）、类型约束（type constraint）**，是很多人理解难点但也是面试亮点。

准备好了就说“**下一个**”。

很好，现在我们进入 **Go 语言高级特性** 中非常重要的一节：

---

### ✅ 第九个知识点：Go 的泛型（Generics）、类型约束（Type Constraints）、反射（reflect）

这些内容是 **Go 1.18+ 的重要更新**，类似于 Java 泛型和反射机制，在复杂项目中应用广泛，且是面试高频点。

---

## 🔹 1. 为什么需要泛型？

之前 Go 中没有泛型，只能写重复代码。例如你需要一个函数求最大值，得写多个版本：

```go
func MaxInt(a, b int) int {
    if a > b {
        return a
    }
    return b
}
func MaxFloat(a, b float64) float64 {
    if a > b {
        return a
    }
    return b
}
```

随着 Go 1.18 引入泛型，我们可以用统一写法：

---

## 🔹 2. 泛型函数的写法

```go
// T 是类型参数（type parameter），必须大写
func Max[T comparable](a, b T) T {
    if a > b {
        return a
    }
    return b
}
```

使用：

```go
fmt.Println(Max[int](3, 5))      // 显式类型
fmt.Println(Max("a", "b"))       // 类型推断
```

✅ `T comparable` 表示 T 类型支持 `==`、`>` 等操作（类型约束）

---

## 🔹 3. 泛型约束（Type Constraints）

### 内建约束

* `comparable`: 支持 `==`、`!=` 等比较运算
* `~int`: 表示可转换为 `int`
* `interface{}`：任意类型（默认）

### 自定义约束接口

```go
type Number interface {
    ~int | ~float64
}

func Sum[T Number](a, b T) T {
    return a + b
}
```

✅ `~int` 是类型集合，表示 T 可能是 `int` 或者自定义类型底层为 `int`。

---

## 🔹 4. 泛型类型（Generic Types）

我们还可以为结构体/方法添加泛型：

```go
type List[T any] struct {
    items []T
}

func (l *List[T]) Add(item T) {
    l.items = append(l.items, item)
}
```

使用：

```go
intList := List[int]{}
intList.Add(10)

stringList := List[string]{}
stringList.Add("hello")
```

✅ `any` 是 Go 1.18 的别名，等价于 `interface{}`。

---

## 🔹 5. 反射（`reflect` 包）

Go 是静态类型语言，但 `reflect` 可以让你在运行时查看、修改变量类型和值。

### 示例：

```go
import "reflect"

var x int = 42
t := reflect.TypeOf(x)   // 获取类型
v := reflect.ValueOf(x)  // 获取值

fmt.Println(t.Kind())    // int
fmt.Println(v.Int())     // 42
```

⚠️ 注意：`reflect` 不适合业务代码中过度使用，主要用于框架/库开发（如 ORM、序列化库等）

---

## ✅ 泛型 vs 反射（Java 类比）

| 特性   | Java                          | Go                                  |
| ---- | ----------------------------- | ----------------------------------- |
| 泛型语法 | `<T extends Comparable<T>>`   | `[T comparable]`                    |
| 泛型约束 | extends/interface             | 通过接口 + `~` 联合类型约束                   |
| 任意类型 | `Object`                      | `interface{}` 或 `any`               |
| 反射机制 | `Class<?>`, `Field`, `Method` | `reflect.TypeOf`, `reflect.ValueOf` |

---

## ✅ 练习建议：

1. 用泛型写一个 `Min()` 和 `Sum()` 函数，支持 `int` 和 `float64`。
2. 定义一个泛型结构体 `Box[T]`，支持存取不同类型。
3. 使用 `reflect` 打印任意变量的类型和值。

---

准备好了吗？下一个知识点是：**Go 的并发模型：goroutine、channel、select、锁机制、并发安全** —— 这部分是 Go 的核心竞争力和亮点，很多企业会重点考。

继续就说“**下一个**”。


goroutine是go的并发执行单元，比java线程更轻量的，创建开销小，调度更快的，

好，现在我们进入 Go 的 **并发模型** —— 这是 Go 最核心、最具竞争力的特性之一，**面试必问、高频考点**。

---

## ✅ 第十个知识点：Go 并发模型（goroutine、channel、select、锁机制）

---

## 🔹 1. 什么是 goroutine？

> goroutine 是 Go 的并发执行单元，**比 Java 线程更轻量**，创建开销小，调度快。

创建方法非常简单：

```go
func sayHello() {
    fmt.Println("Hello")
}

func main() {
    go sayHello()  // 启动一个 goroutine
    time.Sleep(1 * time.Second) // 等它打印完
}
```

✅ **注意：主函数退出，所有 goroutine 都会强制退出。**

---

## 🔹 2. 什么是 channel？

> channel 是 Go 的线程安全通信机制，用于 goroutine 之间 **传递数据、同步协作**。

```go
func main() {
    ch := make(chan string) // 创建一个字符串 channel

    go func() {
        ch <- "Hello from goroutine" // 发送数据
    }()

    msg := <-ch // 接收数据（阻塞）
    fmt.Println(msg)
}
```

### ✅ channel 特点：

* **阻塞式**：接收者没准备好，发送会阻塞，反之亦然。
* 类型安全：`chan int` 只能传 `int`。
* 支持缓冲：`make(chan int, 3)` 创建缓冲区大小为 3 的 channel。

---

## 🔹 3. `select` 用于监听多个 channel

类似于 Java 的 `select`/`poll`/`nio`，Go 原生支持：

```go
func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "from ch1"
    }()
    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "from ch2"
    }()

    select {
    case msg1 := <-ch1:
        fmt.Println(msg1)
    case msg2 := <-ch2:
        fmt.Println(msg2)
    case <-time.After(3 * time.Second): // 超时机制
        fmt.Println("timeout")
    }
}
```

---

## 🔹 4. 并发安全 & 锁（sync 包）

虽然 channel 很强大，但有时你还是需要传统锁：

### ➤ 互斥锁：`sync.Mutex`

```go
var mu sync.Mutex
var count int

func add() {
    mu.Lock()
    count++
    mu.Unlock()
}
```

### ➤ 原子操作：`sync/atomic`

更高性能的并发操作：

```go
import "sync/atomic"

var count int64

atomic.AddInt64(&count, 1)
atomic.LoadInt64(&count)
```

### ➤ 读写锁：`sync.RWMutex`

```go
var rw sync.RWMutex

rw.RLock()  // 多个读可以并发
// ... 读操作
rw.RUnlock()

rw.Lock()   // 写操作必须独占
// ... 写操作
rw.Unlock()
```

---

## 🔹 5. channel 应用模式总结

| 模式名称           | 用途              | 特点                         |
| -------------- | --------------- | -------------------------- |
| 单向 channel     | 限制方向，提高可读性      | `chan<- int`, `<-chan int` |
| 生产者-消费者        | 典型任务队列          | goroutine + channel        |
| fan-in/fan-out | 并发收集 or 并发分发任务  | 多个写入/读取 goroutine          |
| 超时机制           | 防止 channel 永久阻塞 | `select + time.After()`    |
| 控制并发数量         | 信号量模式，如：20个任务并发 | `chan struct{}` + `worker` |

---

## ✅ Java 线程池 vs Go goroutine 对比

| 特性     | Java 线程         | Go goroutine        |
| ------ | --------------- | ------------------- |
| 创建成本   | 高               | 极低（几十 KB 栈空间）       |
| 通信方式   | 锁、共享内存          | channel 通信          |
| 最大并发量  | 数千              | 数万甚至更多              |
| 控制并发   | ExecutorService | channel + goroutine |
| 生命周期管理 | 明确启动/中断         | 主 goroutine 退出全退出   |

---

## ✅ 练习题建议

1. 写一个程序开启多个 goroutine 并通过 channel 传递结果（如并发爬虫）。
2. 实现一个带超时机制的 channel 读取。
3. 使用 `sync.Mutex` 实现一个并发安全的计数器。
4. 用 `select` 实现多个 channel 之间的优先选择逻辑。

---

准备好进阶了吗？**下一个**是：**Go 项目结构与依赖管理（Go Modules）、包与目录规范、第三方包使用（如 gin、gorm、zap）**

继续就说 **“下一个”**。





