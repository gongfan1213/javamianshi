# 熔断器

## 🎯 什么是熔断器？

熔断器是一种保护机制，当服务调用失败率达到阈值时，会快速失败，避免级联故障。

### 基本概念
```
熔断器 = 故障检测 + 快速失败 + 自动恢复 + 降级处理
```

**简单理解：**
- 就像家里的保险丝，电流过大时会自动断开
- 当服务不可用时，快速返回失败，不等待超时
- 保护系统不被故障服务拖垮
- 提供降级方案，保证基本功能可用

## 🔧 主流熔断器对比

### 功能对比表
| 特性 | Hystrix | Sentinel | Resilience4j | Circuit Breaker |
|------|---------|----------|---------------|-----------------|
| 状态 | 停止维护 | 活跃 | 活跃 | 活跃 |
| 易用性 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| 功能丰富度 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| Spring集成 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |

### 选择建议
- **Hystrix**：已停止维护，不推荐新项目使用
- **Sentinel**：阿里巴巴开源，功能最全面
- **Resilience4j**：新一代熔断器，Spring Cloud推荐
- **Circuit Breaker**：Spring Cloud官方，功能相对简单

## 🚀 Resilience4j 熔断器

### 基本配置
```xml
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot2</artifactId>
</dependency>
```

### 熔断器配置
```yaml
resilience4j:
  circuitbreaker:
    instances:
      user-service:
        sliding-window-size: 10
        failure-rate-threshold: 50
        wait-duration-in-open-state: 5s
        permitted-number-of-calls-in-half-open-state: 3
        automatic-transition-from-open-to-half-open-enabled: true
```

### 基础使用
```java
@Service
public class UserServiceClient {
    
    @CircuitBreaker(name = "user-service", fallbackMethod = "getUserInfoFallback")
    public String getUserInfo(String userId) {
        // 调用用户服务
        String url = "http://user-service/user/info/" + userId;
        return restTemplate.getForObject(url, String.class);
    }
    
    public String getUserInfoFallback(String userId, Exception e) {
        return "用户服务暂时不可用，用户ID: " + userId;
    }
}
```

## 🚀 Sentinel 熔断器

### 基本配置
```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
```

### 熔断器配置
```yaml
spring:
  cloud:
    sentinel:
      transport:
        dashboard: localhost:8080
      datasource:
        ds:
          nacos:
            server-addr: localhost:8848
            dataId: sentinel-rules
            groupId: DEFAULT_GROUP
            rule-type: flow
```

### 基础使用
```java
@Service
public class UserServiceClient {
    
    @SentinelResource(
        value = "getUserInfo",
        fallback = "getUserInfoFallback",
        blockHandler = "getUserInfoBlockHandler"
    )
    public String getUserInfo(String userId) {
        String url = "http://user-service/user/info/" + userId;
        return restTemplate.getForObject(url, String.class);
    }
    
    public String getUserInfoFallback(String userId, Throwable e) {
        return "用户服务异常，用户ID: " + userId;
    }
    
    public String getUserInfoBlockHandler(String userId, BlockException e) {
        return "用户服务被限流，用户ID: " + userId;
    }
}
```

## 🚦 熔断器状态

### 三种状态
```
关闭状态（Closed）
├── 正常调用服务
├── 统计失败次数
└── 失败率超过阈值时转为开启状态

开启状态（Open）
├── 快速失败，不调用服务
├── 等待时间后转为半开状态
└── 提供降级响应

半开状态（Half-Open）
├── 允许少量请求调用服务
├── 成功率高时转为关闭状态
└── 失败率高时转为开启状态
```

### 状态转换
```
关闭 → 开启：失败率超过阈值
开启 → 半开：等待时间到达
半开 → 关闭：成功率高
半开 → 开启：失败率高
```

## 💻 熔断器实现

### 1. 基础熔断器
```java
@Component
public class CircuitBreakerService {
    
    @CircuitBreaker(name = "user-service", fallbackMethod = "fallback")
    public String callUserService(String userId) {
        // 模拟服务调用
        if (Math.random() < 0.3) {
            throw new RuntimeException("服务调用失败");
        }
        return "用户信息: " + userId;
    }
    
    public String fallback(String userId, Exception e) {
        return "降级响应: 用户服务不可用，用户ID: " + userId;
    }
}
```

### 2. 超时熔断器
```java
@Component
public class TimeoutCircuitBreakerService {
    
    @TimeLimiter(name = "user-service")
    @CircuitBreaker(name = "user-service", fallbackMethod = "fallback")
    public CompletableFuture<String> callUserServiceWithTimeout(String userId) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(2000); // 模拟慢调用
                return "用户信息: " + userId;
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });
    }
    
    public CompletableFuture<String> fallback(String userId, Exception e) {
        return CompletableFuture.completedFuture("超时降级: 用户服务响应超时");
    }
}
```

### 3. 重试熔断器
```java
@Component
public class RetryCircuitBreakerService {
    
    @Retry(name = "user-service", fallbackMethod = "fallback")
    @CircuitBreaker(name = "user-service", fallbackMethod = "fallback")
    public String callUserServiceWithRetry(String userId) {
        // 模拟服务调用
        if (Math.random() < 0.5) {
            throw new RuntimeException("服务调用失败");
        }
        return "用户信息: " + userId;
    }
    
    public String fallback(String userId, Exception e) {
        return "重试降级: 用户服务多次重试后仍然失败";
    }
}
```

## 🔄 降级策略

### 1. 静态降级
```java
@Service
public class StaticFallbackService {
    
    @CircuitBreaker(name = "user-service", fallbackMethod = "staticFallback")
    public String getUserInfo(String userId) {
        String url = "http://user-service/user/info/" + userId;
        return restTemplate.getForObject(url, String.class);
    }
    
    public String staticFallback(String userId, Exception e) {
        // 返回静态数据
        return "{\"userId\":\"" + userId + "\",\"username\":\"默认用户\",\"status\":\"降级\"}";
    }
}
```

### 2. 缓存降级
```java
@Service
public class CacheFallbackService {
    
    private final Map<String, String> cache = new ConcurrentHashMap<>();
    
    @CircuitBreaker(name = "user-service", fallbackMethod = "cacheFallback")
    public String getUserInfo(String userId) {
        String url = "http://user-service/user/info/" + userId;
        String result = restTemplate.getForObject(url, String.class);
        cache.put(userId, result);
        return result;
    }
    
    public String cacheFallback(String userId, Exception e) {
        // 返回缓存数据
        return cache.getOrDefault(userId, "用户信息不存在");
    }
}
```

### 3. 异步降级
```java
@Service
public class AsyncFallbackService {
    
    @Async
    @CircuitBreaker(name = "user-service", fallbackMethod = "asyncFallback")
    public CompletableFuture<String> getUserInfoAsync(String userId) {
        String url = "http://user-service/user/info/" + userId;
        String result = restTemplate.getForObject(url, String.class);
        return CompletableFuture.completedFuture(result);
    }
    
    public CompletableFuture<String> asyncFallback(String userId, Exception e) {
        // 异步降级处理
        return CompletableFuture.supplyAsync(() -> {
            // 模拟异步处理
            try {
                Thread.sleep(100);
            } catch (InterruptedException ie) {
                Thread.currentThread().interrupt();
            }
            return "异步降级: 用户服务不可用";
        });
    }
}
```

## 📊 监控和指标

### 1. 熔断器指标
```java
@Component
public class CircuitBreakerMetrics {
    
    private final MeterRegistry meterRegistry;
    
    public CircuitBreakerMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    public void recordMetrics(String circuitBreakerName, CircuitBreaker.State state) {
        Counter.builder("circuitbreaker_state_changes")
                .tag("name", circuitBreakerName)
                .tag("state", state.name())
                .register(meterRegistry)
                .increment();
    }
}
```

### 2. 健康检查
```java
@Component
public class CircuitBreakerHealthIndicator implements HealthIndicator {
    
    private final CircuitBreakerRegistry circuitBreakerRegistry;
    
    public CircuitBreakerHealthIndicator(CircuitBreakerRegistry circuitBreakerRegistry) {
        this.circuitBreakerRegistry = circuitBreakerRegistry;
    }
    
    @Override
    public Health health() {
        Map<String, Object> details = new HashMap<>();
        
        circuitBreakerRegistry.getAllCircuitBreakers().forEach((name, circuitBreaker) -> {
            details.put(name + ".state", circuitBreaker.getState());
            details.put(name + ".failureRate", circuitBreaker.getMetrics().getFailureRate());
        });
        
        return Health.up()
                .withDetails(details)
                .build();
    }
}
```

## 🚨 常见问题和解决方案

### 1. 熔断器不生效
**问题：** 熔断器配置不生效
**解决方案：**
```yaml
# 检查配置
resilience4j:
  circuitbreaker:
    instances:
      user-service:
        sliding-window-size: 10
        failure-rate-threshold: 50
```

### 2. 降级方法不执行
**问题：** 降级方法没有被调用
**解决方案：**
```java
// 确保方法签名正确
@CircuitBreaker(name = "user-service", fallbackMethod = "fallback")
public String getUserInfo(String userId) {
    // 业务逻辑
}

// 降级方法签名必须匹配
public String fallback(String userId, Exception e) {
    return "降级响应";
}
```

### 3. 熔断器状态异常
**问题：** 熔断器状态转换异常
**解决方案：**
```yaml
# 调整配置参数
resilience4j:
  circuitbreaker:
    instances:
      user-service:
        wait-duration-in-open-state: 10s
        permitted-number-of-calls-in-half-open-state: 5
```

## 💡 最佳实践

### 1. 熔断器配置
```
✅ 推荐配置：
- 合理的失败率阈值（20-50%）
- 适当的滑动窗口大小（10-100）
- 合理的等待时间（5-30秒）
- 启用自动状态转换

❌ 避免配置：
- 过低的失败率阈值
- 过小的滑动窗口
- 过长的等待时间
```

### 2. 降级策略
```
✅ 推荐策略：
- 静态降级：返回默认数据
- 缓存降级：返回缓存数据
- 异步降级：异步处理降级逻辑
- 多级降级：提供多个降级方案

❌ 避免策略：
- 空降级：什么都不返回
- 异常降级：降级方法抛出异常
- 复杂降级：降级逻辑过于复杂
```

### 3. 监控告警
```
✅ 推荐监控：
- 熔断器状态变化
- 失败率统计
- 响应时间监控
- 降级次数统计

❌ 避免监控：
- 忽略熔断器指标
- 缺少告警机制
- 不记录降级日志
```

## 🔗 下一步学习

- [分布式事务](./09.分布式事务.md) - 学习事务管理
- [消息队列](./10.消息队列.md) - 学习异步通信
- [链路追踪](./11.链路追踪.md) - 学习分布式追踪

---

**记住：熔断器是微服务容错的基础，掌握它就能提高系统的稳定性！** 🎯
