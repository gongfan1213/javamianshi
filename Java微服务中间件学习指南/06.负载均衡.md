# 负载均衡

## 🎯 什么是负载均衡？

负载均衡是将请求分发到多个服务实例的技术，目的是提高系统的可用性、扩展性和性能。

### 1. 基本概念
```
负载均衡 = 请求分发 + 健康检查 + 故障转移 + 性能优化
```

**简单理解：**
- 就像银行的多窗口服务，客户可以到任意窗口办理业务
- 将大量请求分散到多个服务器上
- 避免单个服务器过载
- 提高系统的整体处理能力

### 2. 为什么需要负载均衡？

#### 没有负载均衡的问题
```
❌ 问题场景：
用户服务只有一个实例：192.168.1.100:8081
所有请求都打到这一个实例上

问题：
1. 单点故障：实例挂了，整个服务不可用
2. 性能瓶颈：请求量大时，单个实例处理不过来
3. 无法扩展：无法动态增加服务实例
```

#### 有了负载均衡的好处
```
✅ 解决方案：
1. 高可用性：一个实例挂了，其他实例继续服务
2. 高性能：请求分散到多个实例，提高处理能力
3. 可扩展性：可以动态增加或减少实例
4. 故障隔离：单个实例故障不影响整体服务
```

## 🏗️ 负载均衡架构

### 1. 整体架构
```
┌─────────────────────────────────────────────────────────────┐
│                       客户端                                │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│                    负载均衡器                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │  请求接收   │  │  负载算法   │  │  健康检查   │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────┬───────────────────────────────────────┘
                      │
        ┌─────────────┼─────────────┐
        ▼             ▼             ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│  实例1      │ │  实例2      │ │  实例3      │
│ 192.168.1.1 │ │ 192.168.1.2 │ │ 192.168.1.3 │
│    8081     │ │    8081     │ │    8081     │
└─────────────┘ └─────────────┘ └─────────────┘
```

### 2. 工作流程
```
1. 客户端发送请求 → 负载均衡器
2. 负载均衡器接收请求 → 选择目标实例
3. 转发请求 → 目标实例处理
4. 实例返回响应 → 负载均衡器
5. 负载均衡器返回响应 → 客户端
```

## 🔧 负载均衡分类

### 1. 按位置分类

#### 客户端负载均衡
```
┌─────────────────────────────────────────────────────────────┐
│                       客户端                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │  负载均衡   │  │  服务发现   │  │  请求发送   │        │
│  │   算法      │  │   客户端    │  │   客户端    │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────┬───────────────────────────────────────┘
                      │
        ┌─────────────┼─────────────┐
        ▼             ▼             ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│  实例1      │ │  实例2      │ │  实例3      │
└─────────────┘ └─────────────┘ └─────────────┘
```

**特点：**
- 客户端负责选择服务实例
- 减少网络跳转
- 适合微服务架构

#### 服务端负载均衡
```
┌─────────────────────────────────────────────────────────────┐
│                       客户端                                │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│                    负载均衡器                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │  请求接收   │  │  负载算法   │  │  请求转发   │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────┬───────────────────────────────────────┘
                      │
        ┌─────────────┼─────────────┐
        ▼             ▼             ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│  实例1      │ │  实例2      │ │  实例3      │
└─────────────┘ └─────────────┘ └─────────────┘
```

**特点：**
- 专门的负载均衡器
- 集中管理
- 适合传统架构

### 2. 按算法分类

#### 轮询（Round Robin）
```
请求1 → 实例1
请求2 → 实例2
请求3 → 实例3
请求4 → 实例1
请求5 → 实例2
...
```

**特点：**
- 简单公平
- 适合实例性能相近的场景
- 不考虑实例负载情况

#### 随机（Random）
```
请求1 → 随机选择实例
请求2 → 随机选择实例
请求3 → 随机选择实例
...
```

**特点：**
- 实现简单
- 适合实例性能相近的场景
- 负载分布相对均匀

#### 加权轮询（Weighted Round Robin）
```
实例1权重=3，实例2权重=2，实例3权重=1

请求1-3 → 实例1
请求4-5 → 实例2
请求6 → 实例3
请求7-9 → 实例1
...
```

**特点：**
- 考虑实例性能差异
- 高性能实例处理更多请求
- 适合实例性能差异较大的场景

#### 最少连接（Least Connections）
```
请求1 → 选择当前连接数最少的实例
请求2 → 选择当前连接数最少的实例
...
```

**特点：**
- 考虑实例当前负载
- 适合长连接场景
- 需要实时统计连接数

#### 响应时间（Response Time）
```
请求1 → 选择响应时间最短的实例
请求2 → 选择响应时间最短的实例
...
```

**特点：**
- 考虑实例性能
- 适合对响应时间敏感的场景
- 需要实时监控响应时间

## 🚀 Spring Cloud 负载均衡

### 1. 负载均衡组件

#### Ribbon（已停止维护）
```xml
<!-- 旧版本依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
</dependency>
```

#### Spring Cloud LoadBalancer（推荐）
```xml
<!-- 新版本依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
```

### 2. 自动配置
```java
package com.example.userservice.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class LoadBalancerConfig {
    
    @Bean
    @LoadBalanced  // 启用负载均衡
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

### 3. 负载均衡策略配置
```yaml
# application.yml
spring:
  cloud:
    loadbalancer:
      ribbon:
        enabled: false  # 禁用Ribbon
      configurations:
        default:
          load-balancer-class-name: org.springframework.cloud.loadbalancer.core.RandomLoadBalancer
        user-service:
          load-balancer-class-name: org.springframework.cloud.loadbalancer.core.RoundRobinLoadBalancer
```

## 💻 负载均衡实现

### 1. 使用RestTemplate
```java
package com.example.orderservice.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;

@Service
public class UserServiceClient {
    
    @Autowired
    @LoadBalanced
    private RestTemplate restTemplate;
    
    @Autowired
    private DiscoveryClient discoveryClient;
    
    // 使用负载均衡的RestTemplate
    public String getUserInfoWithLoadBalancer(String userId) {
        // 直接使用服务名，负载均衡器会自动选择实例
        String url = "http://user-service/user/info/" + userId;
        return restTemplate.getForObject(url, String.class);
    }
    
    // 手动实现负载均衡
    public String getUserInfoManual(String userId) {
        List<ServiceInstance> instances = discoveryClient.getInstances("user-service");
        
        if (instances.isEmpty()) {
            throw new RuntimeException("用户服务不可用");
        }
        
        // 简单的轮询算法
        ServiceInstance instance = instances.get(0); // 这里应该实现轮询逻辑
        String url = String.format("http://%s:%s/user/info/%s", 
                                 instance.getHost(), instance.getPort(), userId);
        
        return restTemplate.getForObject(url, String.class);
    }
}
```

### 2. 使用OpenFeign
```java
package com.example.orderservice.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "user-service")  // 自动启用负载均衡
public interface UserFeignClient {
    
    @GetMapping("/user/info/{id}")
    String getUserInfo(@PathVariable("id") String id);
    
    @GetMapping("/user/health")
    String health();
}
```

### 3. 自定义负载均衡策略
```java
package com.example.orderservice.config;

import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.loadbalancer.annotation.LoadBalancerClient;
import org.springframework.cloud.loadbalancer.core.RandomLoadBalancer;
import org.springframework.cloud.loadbalancer.core.ReactorLoadBalancer;
import org.springframework.cloud.loadbalancer.core.ServiceInstanceListSupplier;
import org.springframework.cloud.loadbalancer.support.LoadBalancerClientFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;

@Configuration
@LoadBalancerClient(value = "user-service", configuration = CustomLoadBalancerConfig.class)
public class CustomLoadBalancerConfig {
    
    @Bean
    public ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(
            Environment environment,
            LoadBalancerClientFactory loadBalancerClientFactory) {
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        return new RandomLoadBalancer(loadBalancerClientFactory
                .getLazyProvider(name, ServiceInstanceListSupplier.class),
                name);
    }
}
```

## 🔄 负载均衡算法实现

### 1. 轮询算法
```java
package com.example.orderservice.loadbalancer;

import org.springframework.cloud.client.ServiceInstance;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

@Component
public class RoundRobinLoadBalancer {
    
    private final AtomicInteger position = new AtomicInteger(0);
    
    public ServiceInstance choose(List<ServiceInstance> instances) {
        if (instances == null || instances.isEmpty()) {
            return null;
        }
        
        int pos = Math.abs(position.incrementAndGet() % instances.size());
        return instances.get(pos);
    }
}
```

### 2. 随机算法
```java
package com.example.orderservice.loadbalancer;

import org.springframework.cloud.client.ServiceInstance;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Random;

@Component
public class RandomLoadBalancer {
    
    private final Random random = new Random();
    
    public ServiceInstance choose(List<ServiceInstance> instances) {
        if (instances == null || instances.isEmpty()) {
            return null;
        }
        
        int index = random.nextInt(instances.size());
        return instances.get(index);
    }
}
```

### 3. 加权轮询算法
```java
package com.example.orderservice.loadbalancer;

import org.springframework.cloud.client.ServiceInstance;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

@Component
public class WeightedRoundRobinLoadBalancer {
    
    private final AtomicInteger position = new AtomicInteger(0);
    
    public ServiceInstance choose(List<ServiceInstance> instances) {
        if (instances == null || instances.isEmpty()) {
            return null;
        }
        
        // 计算总权重
        int totalWeight = instances.stream()
                .mapToInt(instance -> getWeight(instance))
                .sum();
        
        if (totalWeight <= 0) {
            return instances.get(0);
        }
        
        // 加权轮询
        int currentWeight = position.incrementAndGet() % totalWeight;
        for (ServiceInstance instance : instances) {
            int weight = getWeight(instance);
            if (currentWeight < weight) {
                return instance;
            }
            currentWeight -= weight;
        }
        
        return instances.get(0);
    }
    
    private int getWeight(ServiceInstance instance) {
        // 从元数据中获取权重，默认为1
        String weightStr = instance.getMetadata().get("weight");
        if (weightStr != null) {
            try {
                return Integer.parseInt(weightStr);
            } catch (NumberFormatException e) {
                // 忽略异常，使用默认权重
            }
        }
        return 1;
    }
}
```

### 4. 最少连接算法
```java
package com.example.orderservice.loadbalancer;

import org.springframework.cloud.client.ServiceInstance;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

@Component
public class LeastConnectionsLoadBalancer {
    
    // 记录每个实例的连接数
    private final ConcurrentHashMap<String, AtomicInteger> connectionCounts = new ConcurrentHashMap<>();
    
    public ServiceInstance choose(List<ServiceInstance> instances) {
        if (instances == null || instances.isEmpty()) {
            return null;
        }
        
        ServiceInstance selectedInstance = null;
        int minConnections = Integer.MAX_VALUE;
        
        for (ServiceInstance instance : instances) {
            String instanceId = getInstanceId(instance);
            AtomicInteger count = connectionCounts.computeIfAbsent(instanceId, k -> new AtomicInteger(0));
            
            if (count.get() < minConnections) {
                minConnections = count.get();
                selectedInstance = instance;
            }
        }
        
        if (selectedInstance != null) {
            String instanceId = getInstanceId(selectedInstance);
            connectionCounts.computeIfAbsent(instanceId, k -> new AtomicInteger(0)).incrementAndGet();
        }
        
        return selectedInstance;
    }
    
    public void releaseConnection(ServiceInstance instance) {
        String instanceId = getInstanceId(instance);
        AtomicInteger count = connectionCounts.get(instanceId);
        if (count != null) {
            count.decrementAndGet();
        }
    }
    
    private String getInstanceId(ServiceInstance instance) {
        return instance.getHost() + ":" + instance.getPort();
    }
}
```

## 🚦 健康检查和故障转移

### 1. 健康检查配置
```yaml
# application.yml
spring:
  cloud:
    loadbalancer:
      health-check:
        initial-delay: 0
        interval: 25s
        timeout: 5s
        retry-count: 3
```

### 2. 健康检查实现
```java
package com.example.orderservice.health;

import org.springframework.boot.actuator.health.Health;
import org.springframework.boot.actuator.health.HealthIndicator;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

@Component
public class ServiceHealthIndicator implements HealthIndicator {
    
    private final DiscoveryClient discoveryClient;
    private final RestTemplate restTemplate;
    
    public ServiceHealthIndicator(DiscoveryClient discoveryClient, RestTemplate restTemplate) {
        this.discoveryClient = discoveryClient;
        this.restTemplate = restTemplate;
    }
    
    @Override
    public Health health() {
        try {
            // 检查用户服务健康状态
            List<ServiceInstance> userInstances = discoveryClient.getInstances("user-service");
            if (userInstances.isEmpty()) {
                return Health.down()
                        .withDetail("user-service", "no instances available")
                        .build();
            }
            
            // 检查订单服务健康状态
            List<ServiceInstance> orderInstances = discoveryClient.getInstances("order-service");
            if (orderInstances.isEmpty()) {
                return Health.down()
                        .withDetail("order-service", "no instances available")
                        .build();
            }
            
            return Health.up()
                    .withDetail("user-service", userInstances.size() + " instances")
                    .withDetail("order-service", orderInstances.size() + " instances")
                    .build();
            
        } catch (Exception e) {
            return Health.down()
                    .withDetail("error", e.getMessage())
                    .build();
        }
    }
}
```

### 3. 故障转移实现
```java
package com.example.orderservice.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;

@Service
public class FaultTolerantUserServiceClient {
    
    @Autowired
    private DiscoveryClient discoveryClient;
    
    @Autowired
    private RestTemplate restTemplate;
    
    public String getUserInfoWithFallback(String userId) {
        List<ServiceInstance> instances = discoveryClient.getInstances("user-service");
        
        if (instances.isEmpty()) {
            throw new RuntimeException("用户服务不可用");
        }
        
        // 尝试每个实例，直到成功
        for (ServiceInstance instance : instances) {
            try {
                String url = String.format("http://%s:%s/user/info/%s", 
                                         instance.getHost(), instance.getPort(), userId);
                return restTemplate.getForObject(url, String.class);
            } catch (Exception e) {
                System.err.println("实例 " + instance.getInstanceId() + " 调用失败: " + e.getMessage());
                // 继续尝试下一个实例
            }
        }
        
        throw new RuntimeException("所有用户服务实例都不可用");
    }
}
```

## 📊 负载均衡监控

### 1. 监控指标
```java
package com.example.orderservice.metrics;

import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import org.springframework.stereotype.Component;

@Component
public class LoadBalancerMetrics {
    
    private final Counter totalRequestsCounter;
    private final Counter successRequestsCounter;
    private final Counter failureRequestsCounter;
    
    public LoadBalancerMetrics(MeterRegistry meterRegistry) {
        this.totalRequestsCounter = Counter.builder("loadbalancer_requests_total")
                .description("负载均衡总请求数")
                .register(meterRegistry);
        
        this.successRequestsCounter = Counter.builder("loadbalancer_success_total")
                .description("负载均衡成功请求数")
                .register(meterRegistry);
        
        this.failureRequestsCounter = Counter.builder("loadbalancer_failure_total")
                .description("负载均衡失败请求数")
                .register(meterRegistry);
    }
    
    public void incrementTotalRequests() {
        totalRequestsCounter.increment();
    }
    
    public void incrementSuccessRequests() {
        successRequestsCounter.increment();
    }
    
    public void incrementFailureRequests() {
        failureRequestsCounter.increment();
    }
}
```

### 2. 监控端点
```yaml
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    health:
      show-details: always
  metrics:
    export:
      prometheus:
        enabled: true
```

## 🚨 常见问题和解决方案

### 1. 负载不均衡
**问题：** 请求没有均匀分布到各个实例
**解决方案：**
```yaml
# 检查负载均衡策略配置
spring:
  cloud:
    loadbalancer:
      configurations:
        default:
          load-balancer-class-name: org.springframework.cloud.loadbalancer.core.RoundRobinLoadBalancer
```

### 2. 实例选择失败
**问题：** 无法选择到可用的服务实例
**解决方案：**
```java
// 检查服务发现状态
List<ServiceInstance> instances = discoveryClient.getInstances("user-service");
if (instances.isEmpty()) {
    // 记录日志，发送告警
    System.err.println("用户服务没有可用实例");
}

// 实现重试机制
@Retryable(value = Exception.class, maxAttempts = 3)
public String getUserInfo(String userId) {
    // 业务逻辑
}
```

### 3. 性能问题
**问题：** 负载均衡器成为性能瓶颈
**解决方案：**
```java
// 使用缓存减少服务发现调用
@Service
public class CachedLoadBalancer {
    
    private final Cache<String, List<ServiceInstance>> instanceCache = Caffeine.newBuilder()
            .maximumSize(100)
            .expireAfterWrite(30, TimeUnit.SECONDS)
            .build();
    
    public ServiceInstance choose(String serviceId) {
        List<ServiceInstance> instances = instanceCache.get(serviceId, k -> 
            discoveryClient.getInstances(serviceId));
        
        if (instances.isEmpty()) {
            return null;
        }
        
        // 实现负载均衡算法
        return instances.get(0);
    }
}
```

## 💡 最佳实践

### 1. 负载均衡策略选择
```
✅ 推荐策略：
- 轮询：实例性能相近，请求处理时间相近
- 加权轮询：实例性能差异较大
- 最少连接：长连接场景
- 响应时间：对响应时间敏感的场景

❌ 避免策略：
- 随机：生产环境不推荐
- 固定：无法实现负载均衡
```

### 2. 健康检查配置
```yaml
# 合理的健康检查配置
spring:
  cloud:
    loadbalancer:
      health-check:
        initial-delay: 10s      # 启动延迟
        interval: 30s           # 检查间隔
        timeout: 5s             # 超时时间
        retry-count: 2          # 重试次数
```

### 3. 监控告警
```java
// 监控关键指标
@Component
public class LoadBalancerMonitor {
    
    @EventListener
    public void handleInstanceChange(InstanceRegisteredEvent event) {
        // 记录实例注册事件
        System.out.println("实例注册: " + event.getInstanceId());
    }
    
    @EventListener
    public void handleInstanceChange(InstanceDeregisteredEvent event) {
        // 记录实例注销事件
        System.out.println("实例注销: " + event.getInstanceId());
    }
}
```

## 🔗 下一步学习

- [服务调用](./07.服务调用.md) - 学习服务间调用
- [熔断器](./08.熔断器.md) - 学习熔断降级
- [分布式事务](./09.分布式事务.md) - 学习事务管理

---

**记住：负载均衡是微服务高可用的基础，掌握它就能实现系统的弹性扩展！** 🎯
