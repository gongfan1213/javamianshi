# 服务网关

## 🎯 什么是服务网关？

服务网关是微服务架构中的统一入口，它负责路由、认证、限流、监控等横切关注点。

### 1. 基本概念
```
服务网关 = 统一入口 + 路由转发 + 横切关注点处理 + 流量控制
```

**简单理解：**
- 就像公司的前台，所有访客都要先经过前台
- 统一处理认证、限流、日志等公共逻辑
- 根据规则将请求转发到对应的服务
- 保护内部服务，提供统一的API接口

### 2. 为什么需要服务网关？

#### 没有服务网关的问题
```
❌ 问题场景：
客户端需要知道所有服务的地址
每个服务都要实现认证、限流、日志
服务地址变化时，客户端需要修改
无法统一管理API接口
```

#### 有了服务网关的好处
```
✅ 解决方案：
1. 客户端只需要知道网关地址
2. 统一处理认证、限流、日志等
3. 服务地址变化对客户端透明
4. 统一管理API接口和文档
5. 提供统一的监控和告警
```

## 🏗️ 服务网关架构

### 1. 整体架构
```
┌─────────────────────────────────────────────────────────────┐
│                       客户端                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │    Web      │  │   Mobile    │  │   Third     │        │
│  │   Client    │  │   Client    │  │   Party     │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│                    服务网关                                  │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │   路由      │  │   认证      │  │   限流      │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │   日志      │  │   监控      │  │   熔断      │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────┬───────────────────────────────────────┘
                      │
        ┌─────────────┼─────────────┐
        ▼             ▼             ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│  用户服务   │ │  订单服务   │ │  商品服务   │
│  端口:8081  │ │  端口:8082  │ │  端口:8083  │
└─────────────┘ └─────────────┘ └─────────────┘
```

### 2. 工作流程
```
1. 客户端请求 → 到达网关
2. 网关处理 → 认证、限流、日志
3. 路由转发 → 根据规则转发到目标服务
4. 服务处理 → 业务逻辑处理
5. 响应返回 → 网关返回响应给客户端
```

## 🔧 主流网关对比

### 1. 功能对比表
| 特性 | Spring Cloud Gateway | Zuul | Kong | Nginx |
|------|---------------------|------|------|-------|
| 性能 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 功能丰富度 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| 易用性 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ |
| Spring集成 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐ |
| 社区活跃度 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

### 2. 选择建议
- **Spring Cloud Gateway**：Spring Cloud官方，性能好，功能丰富
- **Zuul**：Netflix开源，简单易用（已停止维护）
- **Kong**：功能最丰富，适合复杂场景
- **Nginx**：性能最好，但功能相对简单

## 🚀 Spring Cloud Gateway

### 1. 为什么选择Spring Cloud Gateway？
- **性能优秀**：基于WebFlux，支持异步非阻塞
- **功能丰富**：路由、过滤、限流、熔断等
- **Spring集成**：与Spring Cloud生态完美集成
- **扩展性强**：支持自定义过滤器

### 2. Maven依赖配置
```xml
<!-- 父POM中的依赖管理 -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>2021.0.8</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<!-- 网关模块中的依赖 -->
<dependencies>
    <!-- Spring Cloud Gateway -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    
    <!-- Nacos服务发现 -->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    
    <!-- Spring Boot Actuator -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
</dependencies>
```

## 💻 网关基础配置

### 1. 启动类配置
```java
package com.example.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class GatewayApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(GatewayApplication.class, args);
    }
}
```

### 2. 基础配置文件
```yaml
# application.yml
server:
  port: 8080

spring:
  application:
    name: gateway-service
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true  # 启用服务发现
          lower-case-service-id: true  # 服务名转小写
      routes:
        # 用户服务路由
        - id: user-service
          uri: lb://user-service  # lb://表示负载均衡
          predicates:
            - Path=/user/**
          filters:
            - StripPrefix=1  # 去掉路径前缀
            - name: RequestRateLimiter  # 限流过滤器
              args:
                redis-rate-limiter.replenishRate: 10  # 每秒允许处理的请求数量
                redis-rate-limiter.burstCapacity: 20  # 每秒最大处理的请求数量
                key-resolver: "#{@userKeyResolver}"  # 限流策略，对应策略Bean
        
        # 订单服务路由
        - id: order-service
          uri: lb://order-service
          predicates:
            - Path=/order/**
          filters:
            - StripPrefix=1
        
        # 商品服务路由
        - id: product-service
          uri: lb://product-service
          predicates:
            - Path=/product/**
          filters:
            - StripPrefix=1

# Nacos配置
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        namespace: public
        group: DEFAULT_GROUP

# 监控端点
management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    gateway:
      enabled: true
```

## 🛣️ 路由配置详解

### 1. 路由配置方式

#### 方式1：配置文件配置
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service-route
          uri: lb://user-service
          predicates:
            - Path=/user/**
            - Method=GET
            - Header=X-Request-Id, \d+
            - Query=name, .+
            - After=2023-01-01T00:00:00+08:00[Asia/Shanghai]
          filters:
            - StripPrefix=1
            - AddRequestHeader=X-Response-Time, ${timestamp}
            - AddResponseHeader=X-Response-Time, ${timestamp}
```

#### 方式2：Java代码配置
```java
package com.example.gateway.config;

import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GatewayConfig {
    
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
                .route("user-service-route", r -> r
                        .path("/user/**")
                        .filters(f -> f
                                .stripPrefix(1)
                                .addRequestHeader("X-Response-Time", String.valueOf(System.currentTimeMillis()))
                                .addResponseHeader("X-Response-Time", String.valueOf(System.currentTimeMillis())))
                        .uri("lb://user-service"))
                .route("order-service-route", r -> r
                        .path("/order/**")
                        .filters(f -> f.stripPrefix(1))
                        .uri("lb://order-service"))
                .build();
    }
}
```

### 2. 断言（Predicates）详解

#### 路径断言
```yaml
predicates:
  - Path=/user/**        # 路径匹配
  - Path=/user/{segment} # 路径变量
  - Path=/user/{segment}/** # 路径变量 + 通配符
```

#### 时间断言
```yaml
predicates:
  - After=2023-01-01T00:00:00+08:00[Asia/Shanghai]  # 指定时间之后
  - Before=2023-12-31T23:59:59+08:00[Asia/Shanghai] # 指定时间之前
  - Between=2023-01-01T00:00:00+08:00[Asia/Shanghai], 2023-12-31T23:59:59+08:00[Asia/Shanghai] # 时间范围
```

#### 请求方法断言
```yaml
predicates:
  - Method=GET           # GET请求
  - Method=GET,POST      # GET或POST请求
  - Method=GET,POST,PUT  # GET、POST或PUT请求
```

#### 请求头断言
```yaml
predicates:
  - Header=X-Request-Id, \d+     # 请求头存在且匹配正则
  - Header=X-Request-Id          # 请求头存在
  - Header=!X-Request-Id         # 请求头不存在
```

#### 查询参数断言
```yaml
predicates:
  - Query=name, .+               # 查询参数存在且匹配正则
  - Query=name                   # 查询参数存在
  - Query=!name                  # 查询参数不存在
```

#### 远程地址断言
```yaml
predicates:
  - RemoteAddr=192.168.1.1/24    # 远程地址匹配
  - RemoteAddr=192.168.1.1       # 远程地址匹配
```

### 3. 过滤器（Filters）详解

#### 内置过滤器
```yaml
filters:
  # 路径过滤器
  - StripPrefix=1                # 去掉路径前缀
  - PrefixPath=/api              # 添加路径前缀
  
  # 请求头过滤器
  - AddRequestHeader=X-Request-Id, ${uuid}
  - AddRequestHeader=X-Response-Time, ${timestamp}
  - RemoveRequestHeader=X-Request-Id
  
  # 响应头过滤器
  - AddResponseHeader=X-Response-Time, ${timestamp}
  - RemoveResponseHeader=X-Response-Time
  
  # 请求参数过滤器
  - AddRequestParameter=name, value
  - RemoveRequestParameter=name
  
  # 状态码过滤器
  - SetStatus=401
  
  # 重定向过滤器
  - RedirectTo=302, https://example.com
```

#### 自定义过滤器
```java
package com.example.gateway.filter;

import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.stereotype.Component;

@Component
public class CustomFilter extends AbstractGatewayFilterFactory<CustomFilter.Config> {
    
    public CustomFilter() {
        super(Config.class);
    }
    
    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            // 前置处理
            System.out.println("请求开始时间: " + System.currentTimeMillis());
            
            return chain.filter(exchange)
                    .then(Mono.fromRunnable(() -> {
                        // 后置处理
                        System.out.println("请求结束时间: " + System.currentTimeMillis());
                    }));
        };
    }
    
    public static class Config {
        // 配置属性
        private String name;
        
        public String getName() {
            return name;
        }
        
        public void setName(String name) {
            this.name = name;
        }
    }
}
```

## 🔐 认证授权

### 1. JWT认证过滤器
```java
package com.example.gateway.filter;

import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Component
public class JwtAuthFilter implements GlobalFilter, Ordered {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String path = request.getPath().value();
        
        // 跳过不需要认证的路径
        if (isSkipAuth(path)) {
            return chain.filter(exchange);
        }
        
        // 获取JWT Token
        String token = getToken(request);
        if (!StringUtils.hasText(token)) {
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }
        
        // 验证JWT Token
        if (!validateToken(token)) {
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }
        
        // 添加用户信息到请求头
        ServerHttpRequest modifiedRequest = request.mutate()
                .header("X-User-Id", getUserIdFromToken(token))
                .build();
        
        return chain.filter(exchange.mutate().request(modifiedRequest).build());
    }
    
    @Override
    public int getOrder() {
        return -100; // 优先级，越小越高
    }
    
    private boolean isSkipAuth(String path) {
        return path.startsWith("/auth/") || 
               path.startsWith("/public/") || 
               path.equals("/health");
    }
    
    private String getToken(ServerHttpRequest request) {
        String bearerToken = request.getHeaders().getFirst("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
    
    private boolean validateToken(String token) {
        // 实现JWT Token验证逻辑
        try {
            // 这里应该调用JWT工具类验证Token
            return true;
        } catch (Exception e) {
            return false;
        }
    }
    
    private String getUserIdFromToken(String token) {
        // 从Token中提取用户ID
        // 这里应该调用JWT工具类解析Token
        return "user123";
    }
}
```

### 2. 认证配置
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: auth-service
          uri: lb://auth-service
          predicates:
            - Path=/auth/**
          filters:
            - StripPrefix=1
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/user/**
          filters:
            - StripPrefix=1
            - name: JwtAuth  # 自定义认证过滤器
```

## 🚦 限流熔断

### 1. 限流配置
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/user/**
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10  # 每秒允许处理的请求数量
                redis-rate-limiter.burstCapacity: 20  # 每秒最大处理的请求数量
                key-resolver: "#{@userKeyResolver}"  # 限流策略
```

### 2. 限流策略
```java
package com.example.gateway.config;

import org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import reactor.core.publisher.Mono;

@Configuration
public class RateLimiterConfig {
    
    @Bean
    public KeyResolver userKeyResolver() {
        return exchange -> {
            // 根据用户ID限流
            String userId = exchange.getRequest().getHeaders().getFirst("X-User-Id");
            if (userId != null) {
                return Mono.just(userId);
            }
            // 根据IP限流
            String ip = exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();
            return Mono.just(ip);
        };
    }
    
    @Bean
    public KeyResolver ipKeyResolver() {
        return exchange -> {
            String ip = exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();
            return Mono.just(ip);
        };
    }
}
```

### 3. 熔断配置
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/user/**
          filters:
            - name: CircuitBreaker
              args:
                name: user-service-circuit-breaker
                fallbackUri: forward:/fallback/user-service
```

### 4. 熔断回退
```java
package com.example.gateway.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/fallback")
public class FallbackController {
    
    @GetMapping("/user-service")
    public String userServiceFallback() {
        return "用户服务暂时不可用，请稍后重试";
    }
    
    @GetMapping("/order-service")
    public String orderServiceFallback() {
        return "订单服务暂时不可用，请稍后重试";
    }
}
```

## 📊 监控日志

### 1. 访问日志过滤器
```java
package com.example.gateway.filter;

import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Component
public class AccessLogFilter implements GlobalFilter, Ordered {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        long startTime = System.currentTimeMillis();
        String path = exchange.getRequest().getPath().value();
        String method = exchange.getRequest().getMethod().name();
        String remoteAddr = exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();
        
        return chain.filter(exchange)
                .then(Mono.fromRunnable(() -> {
                    long endTime = System.currentTimeMillis();
                    long duration = endTime - startTime;
                    int status = exchange.getResponse().getStatusCode().value();
                    
                    System.out.printf("访问日志: %s %s %s %d %dms%n", 
                                    remoteAddr, method, path, status, duration);
                }));
    }
    
    @Override
    public int getOrder() {
        return Ordered.LOWEST_PRECEDENCE; // 最低优先级，最后执行
    }
}
```

### 2. 监控端点配置
```yaml
management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    gateway:
      enabled: true
    health:
      show-details: always
  metrics:
    export:
      prometheus:
        enabled: true
```

### 3. 自定义监控指标
```java
package com.example.gateway.metrics;

import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import org.springframework.stereotype.Component;

@Component
public class GatewayMetrics {
    
    private final Counter requestCounter;
    private final Counter errorCounter;
    
    public GatewayMetrics(MeterRegistry meterRegistry) {
        this.requestCounter = Counter.builder("gateway_requests_total")
                .description("网关总请求数")
                .register(meterRegistry);
        
        this.errorCounter = Counter.builder("gateway_errors_total")
                .description("网关错误请求数")
                .register(meterRegistry);
    }
    
    public void incrementRequestCount() {
        requestCounter.increment();
    }
    
    public void incrementErrorCount() {
        errorCounter.increment();
    }
}
```

## 🚨 常见问题和解决方案

### 1. 路由不生效
**问题：** 配置的路由无法正常转发
**解决方案：**
```yaml
# 检查路由配置
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service  # 确保服务名正确
          predicates:
            - Path=/user/**        # 确保路径匹配正确
          filters:
            - StripPrefix=1

# 检查服务发现
spring:
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true
```

### 2. 过滤器不执行
**问题：** 自定义过滤器没有执行
**解决方案：**
```java
// 确保过滤器实现了正确的接口
@Component
public class CustomFilter implements GlobalFilter, Ordered {
    
    @Override
    public int getOrder() {
        return -100; // 设置合适的优先级
    }
}

// 检查过滤器是否被Spring扫描到
@SpringBootApplication
@ComponentScan(basePackages = "com.example.gateway")
public class GatewayApplication {
    // ...
}
```

### 3. 限流不生效
**问题：** 配置的限流没有生效
**解决方案：**
```yaml
# 检查限流配置
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10
                redis-rate-limiter.burstCapacity: 20
                key-resolver: "#{@userKeyResolver}"

# 确保Redis可用
spring:
  redis:
    host: localhost
    port: 6379
```

## 💡 最佳实践

### 1. 路由设计原则
```
✅ 推荐设计：
- 按业务模块划分路由
- 使用RESTful风格的路径
- 统一路径前缀管理
- 合理的路径层级

❌ 避免设计：
- 路径过于复杂
- 硬编码服务地址
- 缺少路径前缀
```

### 2. 过滤器使用原则
```
✅ 推荐使用：
- 全局过滤器处理通用逻辑
- 路由过滤器处理特定逻辑
- 合理的过滤器执行顺序
- 避免过滤器间的循环依赖

❌ 避免使用：
- 过滤器逻辑过于复杂
- 过滤器执行顺序混乱
- 过滤器抛出异常
```

### 3. 性能优化
```java
// 使用异步处理
@Component
public class AsyncFilter implements GlobalFilter, Ordered {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        return Mono.defer(() -> {
            // 异步处理逻辑
            return chain.filter(exchange);
        });
    }
}

// 使用缓存
@Component
public class CacheFilter implements GlobalFilter, Ordered {
    
    private final Cache<String, String> cache = Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(1, TimeUnit.HOURS)
            .build();
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String key = exchange.getRequest().getPath().value();
        String cached = cache.getIfPresent(key);
        
        if (cached != null) {
            exchange.getResponse().setStatusCode(HttpStatus.OK);
            return exchange.getResponse().writeWith(
                Mono.just(exchange.getResponse().bufferFactory().wrap(cached.getBytes()))
            );
        }
        
        return chain.filter(exchange);
    }
}
```

## 🔗 下一步学习

- [负载均衡](./06.负载均衡.md) - 学习负载均衡
- [服务调用](./07.服务调用.md) - 学习服务间调用
- [熔断器](./08.熔断器.md) - 学习熔断降级

---

**记住：服务网关是微服务的统一入口，掌握它就能实现统一的流量控制！** 🎯
