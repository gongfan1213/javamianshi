
# 服务调用

## 🎯 什么是服务调用？

服务调用是微服务架构中服务间通信的方式，它解决了"服务如何调用"的问题。

### 基本概念
```
服务调用 = 服务发现 + 负载均衡 + 网络通信 + 错误处理
```

**简单理解：**
- 一个服务需要调用另一个服务的功能
- 通过HTTP、RPC等方式进行通信
- 处理网络延迟、超时、错误等异常情况

## 🔧 主流服务调用方式

### 功能对比表
| 特性 | RestTemplate | OpenFeign | gRPC | WebClient |
|------|--------------|-----------|------|-----------|
| 易用性 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| 性能 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| Spring集成 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

### 选择建议
- **RestTemplate**：简单场景，同步调用
- **OpenFeign**：声明式调用，代码简洁
- **gRPC**：高性能，跨语言
- **WebClient**：异步调用，响应式编程

## 🚀 RestTemplate 使用

### 基本配置
```java
@Configuration
public class RestTemplateConfig {
    
    @Bean
    @LoadBalanced  // 启用负载均衡
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

### 基础使用
```java
@Service
public class UserServiceClient {
    
    @Autowired
    private RestTemplate restTemplate;
    
    public String getUserInfo(String userId) {
        String url = "http://user-service/user/info/" + userId;
        return restTemplate.getForObject(url, String.class);
    }
}
```

## 🚀 OpenFeign 使用

### 基本配置
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

### 启动类配置
```java
@SpringBootApplication
@EnableFeignClients  // 启用Feign客户端
public class OrderServiceApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
}
```

### 接口定义
```java
@FeignClient(name = "user-service")
public interface UserFeignClient {
    
    @GetMapping("/user/info/{id}")
    String getUserInfo(@PathVariable("id") String id);
    
    @PostMapping("/user/create")
    String createUser(@RequestBody UserCreateRequest request);
}
```

## 🚦 错误处理

### 异常处理
```java
@Service
public class ErrorHandlingService {
    
    public String getUserInfoWithErrorHandling(String userId) {
        try {
            String url = "http://user-service/user/info/" + userId;
            return restTemplate.getForObject(url, String.class);
        } catch (Exception e) {
            return "用户服务异常: " + e.getMessage();
        }
    }
}
```

### 重试机制
```java
@Service
public class RetryService {
    
    @Retryable(value = {Exception.class}, maxAttempts = 3)
    public String getUserInfoWithRetry(String userId) {
        String url = "http://user-service/user/info/" + userId;
        return restTemplate.getForObject(url, String.class);
    }
}
```

## 📊 性能优化

### 超时配置
```yaml
spring:
  cloud:
    openfeign:
      client:
        config:
          default:
            connectTimeout: 5000
            readTimeout: 5000
```

### 缓存机制
```java
@Service
public class CachedUserServiceClient {
    
    @Cacheable(value = "userCache", key = "#userId")
    public String getUserInfoWithCache(String userId) {
        String url = "http://user-service/user/info/" + userId;
        return restTemplate.getForObject(url, String.class);
    }
}
```

## 🚨 常见问题

### 1. 服务调用超时
**解决方案：** 配置合理的超时时间

### 2. 负载均衡不生效
**解决方案：** 使用@LoadBalanced注解和服务名调用

### 3. 序列化问题
**解决方案：** 配置Jackson序列化器

## 💡 最佳实践

### 1. 服务调用选择
- RestTemplate：简单场景，同步调用
- OpenFeign：声明式调用，代码简洁
- WebClient：异步调用，响应式编程

### 2. 错误处理策略
- 统一异常处理
- 重试机制
- 熔断降级
- 超时控制

## 🔗 下一步学习

- [熔断器](./08.熔断器.md) - 学习熔断降级
- [分布式事务](./09.分布式事务.md) - 学习事务管理
- [消息队列](./10.消息队列.md) - 学习异步通信

---

**记住：服务调用是微服务通信的基础，掌握它就能实现服务间的协作！** 🎯