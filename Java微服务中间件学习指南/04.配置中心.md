# 配置中心

## 🎯 什么是配置中心？

配置中心是微服务架构中集中管理配置信息的组件，它解决了"配置在哪里"和"配置如何更新"的问题。

### 1. 基本概念
```
配置中心 = 配置存储 + 配置分发 + 配置更新 + 配置版本管理
```

**简单理解：**
- 就像公司的规章制度，统一管理，统一发布
- 所有服务的配置都集中存储
- 配置更新时，所有服务自动感知
- 支持不同环境的配置隔离

### 2. 为什么需要配置中心？

#### 没有配置中心的问题
```
❌ 问题场景：
用户服务配置：数据库连接、Redis配置、业务参数
订单服务配置：数据库连接、Redis配置、业务参数
商品服务配置：数据库连接、Redis配置、业务参数

如果数据库地址变了，需要：
1. 修改每个服务的配置文件
2. 重新打包每个服务
3. 重启每个服务
4. 容易遗漏，容易出错
```

#### 有了配置中心的好处
```
✅ 解决方案：
1. 所有配置集中在配置中心
2. 配置更新时自动推送给所有服务
3. 无需重启，无需重新打包
4. 支持配置版本管理，可以回滚
5. 支持环境隔离，不同环境不同配置
```

## 🏗️ 配置中心架构

### 1. 整体架构
```
┌─────────────────────────────────────────────────────────────┐
│                    配置中心                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ 用户服务配置│  │ 订单服务配置│  │ 商品服务配置│        │
│  │ 环境:dev    │  │ 环境:dev    │  │ 环境:dev    │        │
│  │ 版本:v1.0   │  │ 版本:v1.0   │  │ 版本:v1.0   │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────┬───────────────────────────────────────┘
                      │
        ┌─────────────┼─────────────┐
        ▼             ▼             ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│  用户服务   │ │  订单服务   │ │  商品服务   │
│  拉取配置   │ │  拉取配置   │ │  拉取配置   │
│  监听变化   │ │  监听变化   │ │  监听变化   │
└─────────────┘ └─────────────┘ └─────────────┘
```

### 2. 工作流程
```
1. 服务启动 → 从配置中心拉取配置 → 应用配置
2. 配置更新 → 配置中心推送通知 → 服务接收通知
3. 配置更新 → 服务重新拉取配置 → 应用新配置
4. 配置回滚 → 选择历史版本 → 服务应用回滚配置
```

## 🔧 主流配置中心对比

### 1. 功能对比表
| 特性 | Spring Cloud Config | Nacos Config | Apollo | Consul KV |
|------|-------------------|--------------|--------|-----------|
| 配置存储 | Git/SVN | 内置存储 | 内置存储 | 内置存储 |
| 配置推送 | 手动刷新 | 自动推送 | 自动推送 | 手动刷新 |
| 版本管理 | Git版本 | 内置版本 | 内置版本 | 内置版本 |
| 环境隔离 | Profile | Namespace | Environment | Datacenter |
| 配置加密 | 支持 | 支持 | 支持 | 支持 |
| 易用性 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |

### 2. 选择建议
- **Spring Cloud Config**：Spring Cloud官方，Git集成好
- **Nacos Config**：阿里巴巴开源，功能全面，易用性好
- **Apollo**：携程开源，功能丰富，配置推送及时
- **Consul KV**：Consul的键值存储，功能相对简单

## 🚀 Nacos 配置中心

### 1. 为什么选择Nacos？
- **功能全面**：配置管理、服务注册、动态DNS
- **易用性好**：提供Web控制台，操作简单
- **性能优秀**：支持大规模配置管理
- **生态丰富**：Spring Cloud Alibaba集成

### 2. Maven依赖配置
```xml
<!-- 父POM中的依赖管理 -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-alibaba-dependencies</artifactId>
            <version>2021.0.5.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<!-- 服务模块中的依赖 -->
<dependencies>
    <!-- Nacos配置中心 -->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    </dependency>
    
    <!-- Nacos服务发现（可选） -->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
</dependencies>
```

## 💻 配置中心使用

### 1. 配置文件结构
```
bootstrap.yml (启动配置)
├── 配置中心地址
├── 命名空间
├── 分组
└── 文件扩展名

application.yml (应用配置)
├── 应用名称
├── 服务端口
└── 其他配置
```

### 2. 启动配置 (bootstrap.yml)
```yaml
spring:
  application:
    name: user-service
  cloud:
    nacos:
      config:
        server-addr: localhost:8848      # Nacos服务器地址
        namespace: public                # 命名空间
        group: DEFAULT_GROUP             # 分组
        file-extension: yaml             # 配置文件扩展名
        username: nacos                  # 用户名
        password: nacos                  # 密码
        # 可选配置
        enabled: true                    # 启用配置中心
        refresh-enabled: true            # 启用配置刷新
        shared-configs:                  # 共享配置
          - data-id: common-config.yaml
            group: DEFAULT_GROUP
            refresh: true
        extension-configs:               # 扩展配置
          - data-id: ${spring.application.name}-${spring.profiles.active}.yaml
            group: DEFAULT_GROUP
            refresh: true
```

### 3. 应用配置 (application.yml)
```yaml
server:
  port: 8081

spring:
  profiles:
    active: dev  # 激活的环境

# 数据库配置
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/user_db
    username: root
    password: password
    driver-class-name: com.mysql.cj.jdbc.Driver

# Redis配置
spring:
  redis:
    host: localhost
    port: 6379
    password: 
    database: 0

# 业务配置
app:
  user:
    default-avatar: /images/default-avatar.png
    max-login-attempts: 5
    session-timeout: 3600
```

### 4. 启动类配置
```java
package com.example.userservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.context.config.annotation.RefreshScope;

@SpringBootApplication
@RefreshScope  // 启用配置刷新
public class UserServiceApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}
```

### 5. 配置使用示例
```java
package com.example.userservice.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/user")
@RefreshScope  // 启用配置刷新
public class UserController {
    
    @Value("${app.user.default-avatar}")
    private String defaultAvatar;
    
    @Value("${app.user.max-login-attempts}")
    private Integer maxLoginAttempts;
    
    @Value("${app.user.session-timeout}")
    private Integer sessionTimeout;
    
    @GetMapping("/config")
    public String getConfig() {
        return String.format("默认头像: %s, 最大登录尝试次数: %d, 会话超时: %d秒", 
                           defaultAvatar, maxLoginAttempts, sessionTimeout);
    }
    
    @GetMapping("/avatar/{userId}")
    public String getUserAvatar(@PathVariable String userId) {
        // 使用配置的默认头像
        return String.format("用户 %s 的头像: %s", userId, defaultAvatar);
    }
}
```

### 6. 配置监听器
```java
package com.example.userservice.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.context.annotation.Configuration;

import javax.annotation.PostConstruct;

@Configuration
@RefreshScope
public class AppConfig {
    
    @Value("${app.user.default-avatar}")
    private String defaultAvatar;
    
    @Value("${app.user.max-login-attempts}")
    private Integer maxLoginAttempts;
    
    @PostConstruct
    public void init() {
        System.out.println("应用配置初始化完成");
        System.out.println("默认头像: " + defaultAvatar);
        System.out.println("最大登录尝试次数: " + maxLoginAttempts);
    }
    
    // Getter方法
    public String getDefaultAvatar() {
        return defaultAvatar;
    }
    
    public Integer getMaxLoginAttempts() {
        return maxLoginAttempts;
    }
}
```

## 🔄 配置动态更新

### 1. 自动配置刷新
```java
package com.example.userservice.service;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.stereotype.Service;

@Service
@RefreshScope
public class UserService {
    
    @Value("${app.user.session-timeout}")
    private Integer sessionTimeout;
    
    @Value("${app.user.max-login-attempts}")
    private Integer maxLoginAttempts;
    
    public boolean validateLoginAttempts(int attempts) {
        return attempts < maxLoginAttempts;
    }
    
    public int getSessionTimeout() {
        return sessionTimeout;
    }
    
    public void setSessionTimeout(int sessionTimeout) {
        this.sessionTimeout = sessionTimeout;
    }
}
```

### 2. 手动配置刷新
```java
package com.example.userservice.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.context.refresh.ContextRefresher;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/config")
public class ConfigController {
    
    @Autowired
    private ContextRefresher contextRefresher;
    
    @PostMapping("/refresh")
    public String refreshConfig() {
        // 手动刷新配置
        contextRefresher.refresh();
        return "配置刷新成功";
    }
}
```

### 3. 配置变更监听
```java
package com.example.userservice.listener;

import com.alibaba.nacos.api.config.annotation.NacosConfigListener;
import org.springframework.stereotype.Component;

@Component
public class ConfigChangeListener {
    
    @NacosConfigListener(dataId = "user-service.yaml", groupId = "DEFAULT_GROUP")
    public void onConfigChange(String newConfig) {
        System.out.println("配置发生变更: " + newConfig);
        // 处理配置变更逻辑
    }
}
```

## 🔐 配置加密

### 1. 敏感信息加密
```yaml
# 数据库密码加密
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/user_db
    username: root
    password: ENC(encrypted_password_here)
    driver-class-name: com.mysql.cj.jdbc.Driver
```

### 2. 加密工具类
```java
package com.example.userservice.util;

import org.springframework.util.StringUtils;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

public class ConfigEncryptUtil {
    
    private static final String ALGORITHM = "AES";
    private static final String SECRET_KEY = "your-secret-key-16"; // 16位密钥
    
    public static String encrypt(String value) {
        try {
            SecretKeySpec key = new SecretKeySpec(SECRET_KEY.getBytes(), ALGORITHM);
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] encryptedBytes = cipher.doFinal(value.getBytes());
            return Base64.getEncoder().encodeToString(encryptedBytes);
        } catch (Exception e) {
            throw new RuntimeException("加密失败", e);
        }
    }
    
    public static String decrypt(String encryptedValue) {
        try {
            SecretKeySpec key = new SecretKeySpec(SECRET_KEY.getBytes(), ALGORITHM);
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, key);
            byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(encryptedValue));
            return new String(decryptedBytes);
        } catch (Exception e) {
            throw new RuntimeException("解密失败", e);
        }
    }
    
    public static boolean isEncrypted(String value) {
        return StringUtils.hasText(value) && value.startsWith("ENC(") && value.endsWith(")");
    }
    
    public static String resolveEncryptedValue(String value) {
        if (isEncrypted(value)) {
            String encryptedContent = value.substring(4, value.length() - 1);
            return decrypt(encryptedContent);
        }
        return value;
    }
}
```

## 🌍 环境隔离

### 1. 命名空间隔离
```yaml
# 开发环境
spring:
  cloud:
    nacos:
      config:
        namespace: dev
        group: DEFAULT_GROUP

# 测试环境
spring:
  cloud:
    nacos:
      config:
        namespace: test
        group: DEFAULT_GROUP

# 生产环境
spring:
  cloud:
    nacos:
      config:
        namespace: prod
        group: DEFAULT_GROUP
```

### 2. 分组隔离
```yaml
# 业务A组
spring:
  cloud:
    nacos:
      config:
        namespace: public
        group: business-a

# 业务B组
spring:
  cloud:
    nacos:
      config:
        namespace: public
        group: business-b
```

### 3. 配置文件命名规范
```
# 开发环境
user-service-dev.yaml

# 测试环境
user-service-test.yaml

# 生产环境
user-service-prod.yaml

# 公共配置
common-config.yaml

# 业务配置
business-config.yaml
```

## 📊 配置版本管理

### 1. 版本回滚
```java
package com.example.userservice.controller;

import com.alibaba.nacos.api.config.ConfigService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/config")
public class ConfigVersionController {
    
    @Autowired
    private ConfigService configService;
    
    @PostMapping("/rollback/{version}")
    public String rollbackConfig(@PathVariable String version) {
        try {
            // 回滚到指定版本
            boolean success = configService.publishConfig(
                "user-service.yaml", 
                "DEFAULT_GROUP", 
                getConfigByVersion(version)
            );
            return success ? "配置回滚成功" : "配置回滚失败";
        } catch (Exception e) {
            return "配置回滚异常: " + e.getMessage();
        }
    }
    
    private String getConfigByVersion(String version) {
        // 根据版本获取配置内容
        // 这里需要实现具体的版本管理逻辑
        return "配置内容";
    }
}
```

### 2. 配置历史记录
```java
package com.example.userservice.service;

import com.alibaba.nacos.api.config.ConfigService;
import com.alibaba.nacos.api.config.listener.Listener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.concurrent.Executor;

@Service
public class ConfigHistoryService {
    
    @Autowired
    private ConfigService configService;
    
    public void addConfigChangeListener() {
        try {
            configService.addListener("user-service.yaml", "DEFAULT_GROUP", new Listener() {
                @Override
                public void receiveConfigInfo(String configInfo) {
                    System.out.println("配置变更: " + configInfo);
                    // 记录配置变更历史
                    saveConfigHistory(configInfo);
                }
                
                @Override
                public Executor getExecutor() {
                    return null;
                }
            });
        } catch (Exception e) {
            System.err.println("添加配置监听器失败: " + e.getMessage());
        }
    }
    
    private void saveConfigHistory(String configInfo) {
        // 保存配置变更历史到数据库或文件
        System.out.println("保存配置历史: " + configInfo);
    }
}
```

## 🚨 常见问题和解决方案

### 1. 配置无法刷新
**问题：** 配置更新后服务无法感知
**解决方案：**
```java
// 1. 确保使用@RefreshScope注解
@RefreshScope
public class UserController {
    // ...
}

// 2. 检查配置推送是否启用
spring:
  cloud:
    nacos:
      config:
        refresh-enabled: true

// 3. 手动刷新配置
@PostMapping("/refresh")
public String refresh() {
    contextRefresher.refresh();
    return "刷新成功";
}
```

### 2. 配置加载失败
**问题：** 服务启动时无法加载配置
**解决方案：**
```yaml
# 检查配置中心地址
spring:
  cloud:
    nacos:
      config:
        server-addr: localhost:8848

# 检查命名空间和分组
spring:
  cloud:
    nacos:
      config:
        namespace: public
        group: DEFAULT_GROUP

# 检查文件扩展名
spring:
  cloud:
    nacos:
      config:
        file-extension: yaml
```

### 3. 配置冲突
**问题：** 多个配置文件存在冲突
**解决方案：**
```yaml
# 使用优先级配置
spring:
  cloud:
    nacos:
      config:
        shared-configs:
          - data-id: common-config.yaml
            group: DEFAULT_GROUP
            refresh: true
            priority: 1
          - data-id: business-config.yaml
            group: DEFAULT_GROUP
            refresh: true
            priority: 2
```

## 💡 最佳实践

### 1. 配置文件组织
```
配置中心/
├── 公共配置/
│   ├── common-config.yaml
│   ├── database-config.yaml
│   └── redis-config.yaml
├── 业务配置/
│   ├── user-service.yaml
│   ├── order-service.yaml
│   └── product-service.yaml
└── 环境配置/
    ├── dev/
    ├── test/
    └── prod/
```

### 2. 配置命名规范
```
✅ 推荐命名：
- user-service-dev.yaml
- common-config.yaml
- database-config.yaml

❌ 避免命名：
- userService-dev.yaml
- user_service_dev.yaml
- config.yaml
```

### 3. 配置更新策略
- **关键配置**：使用@RefreshScope，支持热更新
- **启动配置**：放在bootstrap.yml，启动时加载
- **业务配置**：放在application.yml，支持动态更新
- **敏感配置**：使用加密，避免明文存储

### 4. 配置监控
```java
// 监控配置变更
@Component
public class ConfigMonitor {
    
    @EventListener
    public void handleConfigChange(RefreshScopeRefreshedEvent event) {
        System.out.println("配置已刷新: " + event.getSource());
        // 记录配置变更日志
        // 发送配置变更通知
        // 更新监控指标
    }
}
```

## 🔗 下一步学习

- [服务网关](./05.服务网关.md) - 学习网关服务
- [负载均衡](./06.负载均衡.md) - 学习负载均衡
- [服务调用](./07.服务调用.md) - 学习服务间调用

---

**记住：配置中心让配置管理变得简单，支持动态更新和版本管理！** 🎯
