### 这个文件是做什么的
`apis/recovery_routes_simple.py` 提供“断线重连/回放恢复”的最小实现，围绕 Loomi/Nova3 的流式输出做三件事：
- 心跳上报：记录用户活跃，判断是否掉线。
- 智能流式回放：根据会话状态，自动选择“无需回放/纯回放/回放→实时流”的模式，把丢失的事件重新推送给前端。
- 调试诊断：暴露状态查询接口，定位断线与回放逻辑。

### 路由与基础
- 路由前缀：`/api/loomi`
- 日志：`BluePlanLogger("RecoveryRoutes")`
- 数据模型：`HeartbeatRequest(user_id, session_id)`

### 核心接口
- 心跳接口（前端每 5 秒调用）
```25:33:apis/recovery_routes_simple.py
@recovery_router.post("/heartbeat")
async def user_heartbeat(request: HeartbeatRequest):
    """
    用户活跃状态心跳接口
    - 前端每5秒调用一次
    - 后端记录用户最后活跃时间
    - 用于判断用户何时断网
    """
```
作用：调用 `persistence_manager.stream_storage.update_user_heartbeat` 更新心跳并返回是否成功和时间戳。

- 智能回放接口（页面加载/重连时调用）
```57:66:apis/recovery_routes_simple.py
@recovery_router.get("/stream/{user_id}/{session_id}")
async def smart_stream_output(user_id: str, session_id: str):
    """
    智能流式输出接口（增强版：支持混合模式）
    - 前端页面加载时调用
    - 后端自动判断是否需要回放断点后的事件
    - 🎯 新增：支持"回放+实时流"混合模式
    - 如果任务已完成：纯回放模式
    - 如果任务进行中：回放历史 → 切换到实时接收
    """
```
决策流程：
1) `check_need_replay(session_id)` 判断是否有未回放事件  
2) `check_task_status(session_id)` 判断任务是否仍在进行  
- 无需回放：
  - 若任务进行中 → 进入实时流 `_start_realtime_stream`
  - 若任务已完成 → 简单返回 `no_replay` 并发送标准结束信号 `[DONE]`
- 需要回放：
  - 若任务进行中 → 混合模式 `_start_hybrid_stream`（先回放历史，再切实时）
  - 若任务已完成 → 纯回放 `_start_replay_only_stream`

### 调试接口
- `/debug/status/{session_id}`：查看 `recovery_info`
- `/debug/disconnect/{session_id}`：断网事件诊断
- `/debug/completion/{session_id}`：会话完成状态诊断 + 任务状态

### 三种流模式的内部实现（SSE）
所有模式都通过 `StreamingResponse` 逐条 `yield`，并在完成或异常时输出标准结束信号 `[DONE]`，headers 设置了 `Cache-Control: no-cache` 与 `Connection: keep-alive`。

- 实时流 `_start_realtime_stream`
  - 启动前再次确认任务仍在运行，否则直接 `[DONE]`
  - 轮询新事件 `get_events_after_timestamp(session_id, last_check)`
  - 动态轮询间隔：基础 2s，逐步回退到最多 10s；超时 600s 保护
  - 每批新事件立即“标记为已回放”（防止重复）：`mark_specific_events_replayed`
  - 连续错误上限 5 次触发停止，异常也会发送 `[DONE]`
  - 结束条件：`check_task_status` 返回不在运行 → 发送 `task_complete` + `[DONE]`

- 混合流 `_start_hybrid_stream`
  - Phase 1（回放历史）：按顺序回放 `recovery_info['events']`，为每条事件补充元数据：
    - `is_replay: True`、`replay_progress: "i/total"`、`is_after_disconnect`、`hybrid_phase: "replay"`
  - 回放完成后：`mark_events_replayed(session_id)`
  - Phase 2（实时流）：转入与实时流相同的轮询逻辑，并追加 `hybrid_phase: "realtime"`

- 纯回放 `_start_replay_only_stream`
  - 顺序回放所有历史事件，补充 `is_replay: True`、`replay_progress`、`is_after_disconnect`
  - 完成后 `mark_events_replayed` 并输出 `replay_complete` + `[DONE]`

### 事件格式（与 `apis/schemas.py` 对齐）
每条输出事件被构造成统一结构，前端可直接按 `StreamEvent` 解析：
```340:356:apis/recovery_routes_simple.py
stream_event = {
    "event_type": event['event_type'],
    "agent_source": event['agent_source'],
    "timestamp": event['created_at'],
    "payload": {
        "id": event.get('id') or event.get('event_id'),
        "content_type": event['content_type'],
        "data": event_data,            # 可能是字符串或结构化列表
        "metadata": {
            **event_metadata,
            "is_replay": True/False,
            "is_realtime": True/False,
            "hybrid_phase": "replay"/"realtime",
            ...
        }
    }
}
```
- `event_data`/`event_metadata` 若为字符串会尝试 JSON 解析，失败则透传字符串。
- 统一补充标志位，便于前端渲染与统计。

### 与持久化层的交互
- 心跳：`update_user_heartbeat`、`get_last_heartbeat`
- 回放判定：`check_need_replay`
- 任务状态：`check_task_status`
- 拉取事件：`get_events_after_timestamp`
- 回放标记：`mark_events_replayed`、`mark_specific_events_replayed`
- 诊断：`diagnose_disconnect_events`、`diagnose_session_completion`

### 关键边界与鲁棒性
- 时区一致性：心跳检测强制使用 UTC naive 时间做比较，避免时区误判（120s 无心跳视为不活跃）。
- 资源保护：实时/混合实时阶段 10 分钟超时上限；动态退避、连续错误熔断。
- 完整结束信号：所有分支（含异常）都会输出 `[DONE]`，避免前端流悬挂。

### 前端使用建议
- 每 5s 调用 `/api/loomi/heartbeat`；断线重连或页面恢复可调用 `/api/loomi/stream/{user_id}/{session_id}`。
- 处理事件时识别 `payload.metadata.is_replay/is_realtime/hybrid_phase`，并在收到 `[DONE]` 后关闭 SSE。

- 小结
  - 通过“智能判定 + 回放标记 + 动态轮询”，该文件保证了断线后用户能补齐丢失的流式事件，并平滑切换到实时接收，且具备可观测性与超时/熔断保护。
