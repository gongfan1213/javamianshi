# 1
# 2
视频讲述了分布式基础中从单体到集群架构的相关内容，具体如下：
- **单体架构部署流程**：以商城应用为例，单体架构是将所有功能模块集成在一个项目中。部署时先打包Spring Boot应用为可执行JAR包，然后购买两台服务器，一台部署应用，一台部署数据库，确保两者互联互通。为方便用户访问，需购买公网IP和域名，并将域名与服务器IP绑定。
- **单体架构核心概念**：包括域名（IP的好记名字）、IP（互联网设备访问的依据）、节点（专业名词，即服务器），服务器节点可部署应用、数据库、缓存等组件。
- **单体架构优缺点**：优点是开发和部署简单；缺点是无法应对高并发，服务器性能有限，如每秒只能处理200请求时，若有5000请求涌入则无法处理。
- **集群架构解决高并发问题**：通过增加服务器副本解决高并发问题，多个服务器构成集群。用户访问域名，域名指向网关服务器（如Nginx），网关作为请求入口，利用负载均衡算法将请求均摊给各服务器，如一台服务器每秒处理200请求，三台可处理600请求。此外，数据库也可通过复制副本构成集群以解决瓶颈问题。
- **集群架构中的扩缩容概念**：当并发流量增大时，可增加服务器副本进行扩容；当大并发访问过后，释放多余服务器以节省资源，即缩容，扩缩容根据请求和业务量决定。
- **进阶分布式架构的原因**：一是模块化升级时，单体架构中一个功能升级需重新打包整个项目并下线所有服务器重新部署，牵一发而动全身；二是引入新功能如直播时，若使用其他语言（如C++）开发，会面临多语言团队分工协作和交互的问题。

  ![image](https://github.com/user-attachments/assets/807ea69f-ddfb-4e43-bd95-7ebc1efbbf93)

![image](https://github.com/user-attachments/assets/fa82ca08-022c-4877-b249-8066e9332c3c)

网关请求路由，不能转给一个服务器，负载均衡，一个服务器并发处理200的花，网关请求流浪的入口的

数据库可能会产生瓶颈的

数据库多复制几个副本节点的

扩容和缩容

解决大并发

订单功能经常升级的

单体架构当中的，模块化升级，迁移法动全身的

直播的，流媒体服务器的

C++直播媒体的调用的

服务器自治的


# p3
视频讲述了分布式基础相关内容，从集群到分布式架构的演进，具体如下：
- **分布式架构产生的原因及微服务概念**：为解决模块化升级、多语言团队协作等问题，将完整商城应用按业务功能模块拆分为独立部署的小应用，即微服务，如商品、订单、支付等模块。
- **数据库拆分及微服务特性**：按业务边界拆分数据库，如商品数据放商品库，订单数据放订单库，实现微服务数据隔离，且微服务语言无关，可自治管理。
- **微服务部署及副本思想**：每台服务器部署拆分后的微服务，为应对高并发可部署多个副本，但要避免单点故障，遵循分布式消除单点故障的金标准。
- **远程调用及相关机制**：微服务间通过远程调用（如HTTP请求）获取数据，依赖服务注册与发现机制，注册中心记录微服务IP清单，调用前通过注册中心发现服务位置，还可结合负载均衡技术。
- **注册中心的功能**：提供服务注册与发现功能，微服务上线、下线需告知注册中心，注册中心维持服务IP列表；同时作为配置中心，统一管理微服务配置，支持配置修改并主动推送，实现微服务不下线实时更新配置。
- **服务雪崩问题及解决办法**：某微服务卡顿会导致调用链卡顿，高并发下引发服务雪崩，引入服务熔断机制，设置如五秒内50%请求卡顿则后续请求快速失败，释放资源避免服务器资源耗尽。
- **分布式的定义及与集群的区别**：分布式是将大型应用拆分为小应用分布部署在各机器，各机器部署内容不同；集群是一堆机器，即使部署同一个应用也属于集群，是物理形态，分布式是架构方式。
- **网关的作用**：用户通过域名访问，域名绑定网关服务器，网关根据请求规则（如以order开头的请求）路由到对应微服务，路由前需询问注册中心微服务位置。
- **分布式事务问题**：涉及多个数据库的业务（如下订单和给用户加积分）需保证事务一致性，分布式环境下需解决分布式事务问题。
- **分布式系统相关技术组件**：使用Spring Boot创建微服务项目，Spring Cloud Alibaba的Nacos作注册中心和配置中心，Spring Cloud Gateway实现网关，OpenFeign处理远程调用，Sentinel实现服务熔断，Seata解决分布式事务问题。

![image](https://github.com/user-attachments/assets/61bc3ab6-1b08-4d5b-bfa6-c5db0456ca0c)





![image](https://github.com/user-attachments/assets/0868a690-f903-4828-9c10-6818c834709e)



![image](https://github.com/user-attachments/assets/08464391-d6ea-43fc-802b-b3663d60ccc6)




熔断快速失败机制


# 4
视频讲述了分布式基础中创建微服务项目的相关内容，具体如下：
- **单体架构部署及概念**：以商城应用为例，单体架构是将所有功能模块放在一个项目中，打包成Spring Boot可执行jar包后上传到服务器启动，数据库单独部署在另一台服务器，通过公网IP和域名实现用户访问。此架构中涉及域名、IP、节点等概念，优点是开发和部署简单，缺点是无法应对高并发。
- **集群架构解决高并发问题**：通过复制多台服务器形成集群，引入副本概念，利用网关（如engines）作为请求入口，结合负载均衡算法将流量均摊到各服务器，提升并发处理能力。同时，数据库也可构建集群应对瓶颈，还可根据业务量进行服务器的扩容和缩容。
- **分布式架构进阶原因**：集群架构虽能解决高并发，但在模块化升级时会牵一发而动全身，且当引入如直播等需要其他语言（如C++）开发的功能模块时，存在多语言团队协作和交互的问题，因此需要进阶到分布式架构。
![image](https://github.com/user-attachments/assets/c984046c-6e3d-4c1f-9764-35e1e7df9dce)


# 5
视频讲述了Nacos安装相关内容，具体如下：
- **注册中心功能回顾**：启动Nacos注册中心后，微服务如订单服务、商品服务启动后可连上注册中心并注册自己，若微服务集群化启动，多台机器上的服务也应注册到注册中心，注册中心会保存微服务及其所在机器清单列表，当订单服务调用商品服务时，先询问注册中心商品服务所在机器，注册中心返回后，订单服务可挑选机器发起远程调用，这就是服务注册和服务发现，是注册中心的两个核心功能。
- **Nacos介绍**：Nacos是Spring Cloud阿里巴巴生态里提供的软件平台，能实现服务注册、服务发现和配置管理功能，此次安装的是2.4.3版本。
- **Nacos下载**：Nacos官网、GitHub有下载页面，Docker安装可用相关镜像，Windows下可下载zip压缩包，也可在语雀文档获取该版本软件包。
- **Nacos安装步骤**：将下载的Nacos server 2.4.3压缩包解压到非中文无空格目录，进入解压后的Nacos文件夹下的bin目录，在该目录输入CMD，使用“startup.cmd -m standalone”命令以单机模式启动Nacos，集群模式暂不考虑。
- **Nacos启动验证**：Nacos启动成功后，可访问8848端口，在浏览器输入“localhost:8848/nacos”，进入Nacos页面，其重要功能有作为配置中心的配置管理和作为注册中心的服务管理，集群管理等页面相关设置可先不用管，此次Nacos启动成功。
# 6
视频讲述了Nacos注册中心服务注册的测试流程与操作，具体如下：
- **服务注册核心步骤**：先启动微服务，引入spring cloud start和阿里巴巴纳克斯的discovery依赖，配置纳克斯地址，微服务启动后即可连上Nacos并注册，之后可在Nacos注册中心查看服务注册效果。
- **订单服务注册操作**：以service order订单服务为例，其为spring boot的web应用，因项目已继承spring boot，在微服务中导入web依赖即可开发web项目，且之前创建项目时在services里已公共导入阿里巴巴nacos discovery依赖，故无需再导。编写主程序order my application，添加@SpringBootApplication注解，通过SpringApplication.run启动。编写application.properties配置文件，设置spring应用名字、端口（如8000）及spring cloud nacos server地址（默认127.0.0.1:8848），启动项目后在注册中心服务管理服务列表可看到service order已注册且健康。
- **商品服务注册操作**：对service product商品服务，先引入web开发依赖，编写主程序product manapplication并标注@SpringBootApplication注解，通过SpringApplication.run启动。编写application.properties配置文件，复制订单服务相关配置，修改应用名字（此名字为注册中心中服务的名字），设置端口（如9000）及Nacos服务器地址，启动后可在注册中心看到service product已注册。
- **注册中心注册内容**：在注册中心中，注册的是微服务的名字、所在IP和端口，如service order及本机IP地址和端口号，每个微服务都如此注册，实例数显示启动数量，且实例健康。
- **模拟集群测试**：在本机通过启动不同端口模拟集群，如复制订单主程序配置，修改program arguments中的端口为8001，启动两个订单服务；对商品服务同理，添加程序参数设置端口为9001、9002，启动三个商品服务。全部启动后在注册中心查询，可见商品实例数为三，订单实例数为二，且都健康，详情中注册中心保存的是微服务名字和IP端口号列表。
- **服务注册总结**：只要项目引入nacos discovery依赖，配置nacos地址，启动后就会自动注册到注册中心，注册中心保存微服务所有可访问的IP和端口号列表，测试期间CMD窗口不能关闭，否则Nacos服务停止运行。
# 7
视频讲述了Nacos注册中心服务发现的测试过程，具体如下：
- **开启服务发现功能**：使用`@EnableDiscoveryClient`注解开启服务发现功能，该注解的作用是让微服务能够在注册中心中发现其他服务。
- **导入测试依赖**：在项目中导入`spring-boot-starter-test`测试依赖，且将`scope`设置为`test`，使依赖仅在测试范围生效，之后刷新项目。
- **编写测试类**：创建与主程序包名相同的测试类`DiscoveryTest`，在类上标注`@SpringBootTest`注解，用于进行Spring Boot单元测试。
- **使用DiscoveryClient获取服务信息**：自动注入`DiscoveryClient`组件，通过其`getServices()`方法获取注册中心中所有微服务的名字，如`service-order`和`service-product`；再通过`getInstances()`方法传入微服务ID，获取每个微服务的实例信息，包括IP和端口号，如`service-order`对应的端口为200181000和20018001。
- **使用NacosServiceDiscovery获取服务信息**：自动注入`NacosServiceDiscovery`组件，其获取服务信息的方法与`DiscoveryClient`类似，如`getServices()`获取微服务名字，`getInstances()`获取实例的IP和端口号，结果与前者一致。
- **服务发现的实际应用**：获取到注册中心中微服务的IP地址和端口列表后，可用于远程调用连接服务器。在实际开发中，服务发现会被封装为自动化过程，无需手动调用底层代码，但每个微服务都需标注`@EnableDiscoveryClient`注解，以支持微服务之间的互相调用。

- # 8
视频讲述了在Nacos注册中心下编写微服务API的相关内容，具体如下：
- **微服务远程调用基本流程**：订单服务调用商品服务时，先从注册中心获取商品服务地址列表，选取一个地址发送请求，商品服务处理业务后返回数据。
- **下单场景设计**：用户向订单服务发起下单请求，订单服务需远程查询商品服务获取商品数据，再生成订单返回给用户，涉及订单和商品两个实体模型，订单包含商品列表等信息，商品包含价格、名称等信息。
- **商品服务编码实现**：编写ProductController，通过RestController注解接收请求，按商品id查询商品；编写Product实体类，包含id、价格等属性，使用Lombok的Data注解；编写ProductService接口及实现类，模拟查询商品数据并返回假数据。
- **订单服务编码实现**：编写OrderController，通过RestController注解处理创建订单请求；编写Order实体类，包含订单id、总金额等属性及商品列表；编写OrderService接口及实现类，接收用户id和商品id，模拟生成订单，总金额和商品列表等数据需远程获取。
- **服务测试**：启动商品服务和订单服务，测试商品服务能否返回商品数据，测试订单服务能否创建订单，远程查询功能待后续实现。


![image](https://github.com/user-attachments/assets/e7ae21fe-59a6-45ab-9f7e-b7e8f865c3b1)



# 9
视频讲述了在SpringCloud中使用Nacos实现订单服务远程调用商品服务的基本过程，具体如下：
- **创建model层**：由于微服务间调用需共享数据模型，故在cloud demo下创建model层，将订单和商品的Java Bean复制到该层对应的包中，删除原微服务中的相关Bean，让各微服务依赖model层，实现模型共享。
- **远程调用准备**：远程调用分两步，第一步通过引入Spring Cloud的DiscoveryClient组件，获取商品服务实例的IP和端口，拼接成URL；第二步使用RestTemplate发送请求，为此在配置类中注入RestTemplate实例，以便后续自动装配使用。
- **实现远程调用**：通过RestTemplate的getForObject方法发送GET请求，将远程返回的JSON数据自动转为Product对象，同时记录日志，调用该方法可根据商品id获取商品数据，进而计算订单总金额等信息。
- **测试与问题**：重启订单和商品服务后，若订单启动报错，可能是RestTemplate配置类位置错误，需在订单服务中正确配置。测试下单时，订单会发起远程调用，获取商品数据并计算总额，若商品服务实例宕机，注册中心会剔除该实例，订单自动调用其他实例。
- **现有方案缺点**：当前远程调用每次都固定请求第一个实例，未实现负载均衡，后续需改造方法，使请求能按顺序分发到不同商品服务实例，如9000、9001、9002等。
  
# 10-负载均衡

视频讲述了在Nacos注册中心中进行负载均衡API测试的相关内容，具体如下：
- **负载均衡功能实现介绍**：在已实现订单远程调用商品的基础上，要完成对商品负载均衡的调用。Spring Cloud提供了load balancer场景，引入后会有load balancer client组件，可实现负载均衡获取对方微服务地址。
- **负载均衡测试准备**：在订单服务中引入spring cloud load balancer依赖，然后进行单元测试，引入Spring boot starter test包并调整scope为test，测试类包名要与订单服务主程序包名一致，编写load balancer test测试类。
- **负载均衡测试实现**：导入load balancer client并自动装配，使用其choose方法选择微服务地址，该方法返回单个实例，而之前的discovery client获取的是所有实例且需自己写负载均衡算法。通过多次调用choose方法并打印host和端口，可测试负载均衡效果。
- **测试结果与负载均衡原理**：多次调用choose方法后，得到如9002、9001等不同端口，呈现轮询规则的负载均衡，说明load balancer client自带负载均衡算法。
- **订单逻辑改造**：注入load balancer client，改造订单中获取微服务地址的逻辑，将原来发现所有地址改为用choose选择一个地址，这样订单对商品的调用就实现了负载均衡，不再是固定调用某一个，而是会轮询不同实例。
- **改造后效果验证**：启动订单服务后，多次访问订单，查看控制台远程请求记录，会交替出现不同的端口，如9001、9002等，实现了负载均衡的远程调用，这是远程调用的进阶版本，增加了负载均衡功能。

loadBalacnerClient
9901

9002

9000

# 11

视频讲述了Nacos注册中心中@LoadBalanced注解式负载均衡的使用方法及测试过程，具体如下：
- **@LoadBalanced注解的作用**：Spring提供的@LoadBalanced注解可标注在RestTemplate上，使RestTemplate具备负载均衡功能，实现注解式负载均衡。
- **基于注解的负载均衡的代码改造**：无需再写指定IP和端口号的代码，远程调用的URL只需写微服务名字加上商品id，RestTemplate会在发请求前动态将微服务名字负载均衡地替换为IP地址。
- **负载均衡的测试过程**：启动多个商品服务实例，创建订单调用商品服务，通过在商品服务控制台打印信息，观察到不同实例的控制台轮流打印，证明实现了负载均衡。
- **注解式负载均衡的总结**：远程调用时，将负载均衡的RestTemplate放入容器，URL写对方微服务名字，RestTemplate会负载均衡地发送请求并转换JSON数据，其他方式可作为了解。

- 注解式负载均衡的

# 12

![image](https://github.com/user-attachments/assets/a2a38368-1213-4a62-9d7c-c91ee39f5f12)

视频讲述了注册中心宕机时远程调用是否能成功的问题，具体如下：
- **远程调用流程**：订单调用商品服务时，RestTemplate先从URL获取微服务名字，再到注册中心获取该微服务所有访问地址列表，然后利用负载均衡算法选择一个可访问地址发起请求。
- **引入实例缓存的原因**：若每次远程调用都先请求注册中心获取实例列表会很浪费性能，因为微服务实例上线后通常比较稳定，所以首次调用获取实例列表后可将其缓存，后续直接从缓存中选取地址调用，缓存会与注册中心实时同步，以便更新实例状态。
- **注册中心宕机对远程调用的影响**：若之前调用过目标服务，缓存中有实例信息，即便注册中心宕机，只要缓存中选取的IP和端口对应的服务器在线，远程调用就能成功；若为第一次调用，因需要先从注册中心获取实例列表，此时注册中心宕机则远程调用失败。
- **验证过程**：先调用商品服务，再关闭注册中心，发现仍能远程调用成功，验证了调用过的情况下注册中心宕机不影响远程调用；重新启动注册中心并上线微服务后，在未发起任何远程调用时关闭注册中心，首次调用出现500异常，提示无可用实例，验证了第一次调用时注册中心宕机远程调用失败。

- 请求注册中心获取微服务地址列表，给对方服务的某个地址发送请求的

- 注册中心实时的列表的

- 商品服务

- ![image](https://github.com/user-attachments/assets/a001d711-f17b-4794-b171-baf7f590e2df)

- 注册中心实例缓存，调用一次就知道在哪里，实时更新的，

- 第一种，调用过的，缓存的存在

- 调用过，远程调用不在依赖注册中心，可以通过，

- startup.md

- 不发起远程调用的，

- 不发起远程调用的时候，创建订单的，

 ![image](https://github.com/user-attachments/assets/996d9129-a74e-42d0-9682-d3eb577c2110)

# 13-p配置中心

![image](https://github.com/user-attachments/assets/a4d67a8e-19b6-42d0-bba2-1e8d1a02d974)


更新配置，打包部署的，下线，再上线的
集中式配置管理的

![image](https://github.com/user-attachments/assets/47f97d11-01da-4074-ba42-818e20529c2a)



