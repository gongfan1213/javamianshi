# 内存溢出异常
# Java会存在内存泄漏吗？请简单描述
内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。

但是，即使这样，Java也还是存在着内存泄漏的情况，Java导致内存泄漏的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。

# 什么情况下会发生栈内存溢出。
**思路**：描述栈定义，再描述为什么会溢出，再说明一下相关配置参数，OK的话可以给面试官手写是一个栈溢出的demo。

**参考答案**:

- 栈是线程私有的，它的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型
- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常，方法递归调用产生这种结果。
- 如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将抛出一个OutOfMemory异常。(线程启动过多)
- 参数 -Xss 去调整JVM栈的大小 

# 垃圾收集器
# 简述Java垃圾回收机制
在Java中，程序员是不需要显式的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

# GC是什么？为什么要GC
GC是垃圾收集的意思（Garbage Collection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存

回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动

回收内存的目的，Java语言没有提供释放已分配内存的显式操作方法。

# 垃圾回收的优点和原理。并考虑2种回收机制
Java语言最显著的特点就是引入了垃圾回收机制，它使Java程序员在编写程序时不再考虑内存管理的问题。

由于有这个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。

垃圾回收机制有效的防止了内存泄漏，可以有效的使用可使用的内存。

垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。

程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。

垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。

# 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。

通常，GC采用有向图的方式记录和管理堆（heap）中的所有对象。通过这种方式确定哪些对象是“可达的”，哪些对象是“不可达的”。当GC确定一些对象为“不可达”时，GC就有责任回收这些内存空间。

可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。
# 你能保证 GC 执行吗？
不能，虽然你可以调用System.gc()或者Runtime.gc()，但是没有办法保证GC的执行。

# Java 中都有哪些引用类型？
- 强引用：发生gc的时候不会被回收。
- 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。
- 弱引用：有用但不是必须的对象，在下一次GC时会被回收。
- 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用PhantomReference实现虚引用，虚引用的用途是在gc时返回一个通知。
# 介绍一下强引用、软引用、弱引用、虚引用的区别？
思路：先说一下四种引用的定义，可以结合代码讲一下，也可以扩展谈到ThreadLocalMap里弱引用用处。

参考答案:

1) 强引用  

我们平时new了一个对象就是强引用，例如 Object obj = new Object();即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。  

2) 软引用  

如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。  

```java
SoftReference<String> softRef = new SoftReference<String>(str); // 软引用
```

用处：软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。

(1) 如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建

(2) 如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出

如下代码:

```
Browser prev = new Browser();                     // 获取页面进行浏览
SoftReference sr = new SoftReference(prev);  // 浏览完毕后置为软引用
if(sr.get()!=null){
    rev = (Browser) sr.get();                     // 还没有被回收器回收，直接获取
}else {
    prev = new Browser();                         // 由于内存吃紧，所以软引用的对象被回收了
    sr = new SoftReference(prev);                 // 重新构建
}
```

3) 弱引用

具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

```
String str=new String("abc");
WeakReference<String> abcWeakRef = new WeakReference<String>(str);
str=null;
等价于
str = null;
System.gc();
```

4) 虚引用

如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。

# 怎么判断对象是否可以被回收?
垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。
一般有两种方法来判断:
- 引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；
- 可达性分析法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。

# 在Java中，对象什么时候可以被垃圾回收
当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。

垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收（Full GC）。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。

# JVM 运行时堆内存如何分代?

Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代。

参考图1:

<img width="524" height="178" alt="image" src="https://github.com/user-attachments/assets/c296c9e4-ead6-40f3-ad9b-bf3348022482" />



参考图2:

<img width="594" height="251" alt="image" src="https://github.com/user-attachments/assets/48e2174f-ca65-4e93-8536-06efab2877d0" />


从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。

默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定
)，

即：**新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。**

其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为
from 和 to，以示区分

默认的，Eden: from : to = 8 :1 : 1 ( 可以通过参数–XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的
新生代空间大小，from = to = 1/10 的新生代空间大小。

JVM **每次只会使用 Eden 和其中的一块 Survivor 区域**来为对象服务，所以无论什么时候，总是有一块
Survivor区域是空闲着的。


因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。


## 新生代

是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC
进行垃圾回收。新生代又分为 Eden区、 ServivorFrom、 ServivorTo 三个区。

### Eden 区
Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够
的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。
### Servivor from 区
上一次 GC 的幸存者，作为这一次 GC 的被扫描者。
### Servivor to 区
保留了一次 MinorGC 过程中的幸存者。

**MinorGC 的过程（复制->清空->互换）**

MinorGC 采用复制算法。

1. eden、 servicorFrom 复制到 ServicorTo，年龄+1

首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以
及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位
置了就放到老年区）；

2. 清空 eden、 servicorFrom

然后，清空 Eden 和 ServicorFrom 中的对象；

3. ServicorTo 和 ServicorFrom 互换

最后， ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区


## 老年代

主要存放应用程序中生命周期长的内存对象。

老年代的对象比较稳定，所以 MajorGC （常常称之为 FULL GC）不会频繁执行。在进行 FULL GC前一
般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法
找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空
间。

 
 FULL GC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对
象。 ajorGC 的耗时比较长，因为要扫描再回收。 FULL GC 会产生内存碎片，为了减少内存损耗，我
们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出
OOM（Out of Memory）异常。

## 永久代 （或者 jdk1.8元空间）
指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久
区域， 它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久
代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。

# JVM内存为什么要分成新生代，老年代，永久代。新生代中为什么要分为Eden和Survivor。
**思路**： 先讲一下JAVA堆，新生代的划分，再谈谈它们之间的转化，相互之间一些参数的配置（如： –
XX:NewRatio，–XX:SurvivorRatio等），再解释为什么要这样划分，最好加一点自己的理解。

**参考答案：**

这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。

1）共享内存区划分
- 共享内存区 = 永久代 + 堆
- 永久代 = 方法区 + 其他
- Java堆 = 老年代 + 新生代
- 新生代 = Eden + S0 + S1

2）一些参数的配置
- 默认的，新生代（Young）与老年代（Old）的比例的值为 1:2，可以通过参数 -XX:NewRatio 配置。
- 默认的，Eden: from: to = 8:1:1（可以通过参数 -XX:SurvivorRatio 来设定）
- Survivor 区中的对象被复制次数为 15（对应虚拟机参数 -XX:MaxTenuringThreshold）

3）为什么要分为 eden 和 survivor？为什么要设置两个 survivor 区？
- 如果没有 Survivor，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发 Major GC。老年代的内存空间远大于新生代，进行一次 Full GC 消耗的时间比 Minor GC 长得多，所以需要分为 Eden 和 Survivor。
- Survivor 的存在意义，就是减少被送到老年代的对象，进而减少 Full GC 的发生，Survivor 的预筛选保证，只有经历 16 次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。
- 设置两个 Survivor 区最大的好处就是解决了碎片化，刚刚新建的对象在 Eden 中，经历一次 Minor GC，Eden 中的存活对象就会被移动到第一块 survivor space S0，Eden 被清空；等 Eden 区再满了，就再触发一次 Minor GC，Eden 和 S0 中的存活对象又会被复制送入第二块 survivor space S1（这个过程非常重要，因为这种复制算法保证了 S1 中来自 S0 和 Eden 两部分的存活对象占用连续的内存空间，避免了碎片化的发生）

# JVM 中一次完整的 GC 流程是怎样的，对象如何晋升到老年代
**思路**：先描述一下 Java 堆内存划分，再解释 Minor GC，Major GC，full GC，描述它们之间转化流程。

**我的答案:**

- Java 堆 = 老年代 + 新生代
- 新生代 = Eden + S0 + S1
- 当 Eden 区的空间满了，Java 虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor。
- **大对象**（需要大量连续内存空间的 Java 对象，如那种很长的字符串）**直接进入老年态**；
- 如果对象在 Eden 出生，并经过第一次 Minor GC 后仍然存活，并且被 Survivor 容纳的话，年龄设为 1，每熬过一次 Minor GC，年龄 +1，**若年龄超过一定限制（15），则被晋升到老年代，即长期存活的对象进入老年态**。
- 老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行 Full GC，Full GC 清理整个内存堆 - 包括年轻代和老年代。
- Major GC 发生在老年代的 GC，清理老年代，经常会伴随至少一次 Minor GC，比 Minor GC 慢 10 倍以上。

# 聊聊：什么是分代，分代的必要性
Java 虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代（对 HotSpot 虚拟机而言），这就是 
JVM 的内存分代策略。

JDK 1.7 之前，Java 虚拟机将堆内存划分为新生代、老年代和永久代（或者元空间），

永久代是 HotSpot 虚拟机特有的概念（JDK1.8 之后为 metaspace 元空间替代永久代），它采用永久代的方式来实现方法区，其他的虚拟机实现没有这一概念，


而且 HotSpot 也有去永久代的趋势，在 JDK 1.7 中 HotSpot 已经开始了“去永久代化”，把原本放在永久代的字符串常量池移出。永久代主要存放常量、类信息、静态变量等数据，与垃圾回收关系不大，新生代和老年代是垃圾回收的主要区域。

堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中。

给堆内存分代，是为了**提高对象内存分配和垃圾回收的效率。**

试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾收集，而每次回收都要遍历所有的对象，遍历这些对象所花费的时间代价是巨大的，会严重影响我们的 GC 效率。

有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放在老年代中。


**静态属性、类信息**等存放在永久代（或者元空间）中，

新生代中的对象存活时间短，只需要在新生代区域中频繁进行 GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收。

永久代（或者元空间）中回收效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾收集算法。

分代收集大大提升了收集效率，这些都是内存分代带来的好处。

# JVM中的永久代中会发生垃圾回收吗
垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收（Full GC）。


如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。

这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。

# JAVA8 与元数据
在 Java8 中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。

元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。

因此，默认情况下，元空间的大小仅受本地内存限制。

类的元数据放入 native memory，字符串池和类的静态变量放入 Java 堆中，这样可以加载多少类的元数据就不再由 MaxPermSize 控制，而由系统的实际可用空间来控制。

# 如何判断对象可以被回收？
判断对象是否存活一般有两种方式：
- **引用计数**：  
每个对象有一个引用计数属性，新增一个引用时计数加 1，引用释放时计数减 1，计数为 0 时可以回收。  
此方法简单，无法解决对象相互循环引用的问题。  

- **可达性分析（Reachability Analysis）**：

从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。

## 引用计数法
在Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用，即他们的引用计数都不为0，则说明该对象不太可能再被用到，那么这个对象就是可回收对象。

## 可达性分析
为了解决引用计数法的循环引用问题，Java使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。

# Minor GC与Full GC分别在什么时候发生？
新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC 

# 垃圾收集算法有哪些类型？
GC最基础的算法有三类：标记-清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。

标记-清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。

复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活者的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法 



# 说一下JVM有哪些垃圾回收算法？
- 标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。 
- 复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。 
- 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
- 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。

### (1) 标记-清除算法
该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收所有没有被标记的对象。适用场合：存活对象较多的情况、适用于老年代。

标记清除算法（Mark - Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：
- 标记阶段：标记出可以回收的对象。
- 清除阶段：回收被标记的对象所占用的空间。

标记-清除算法的执行的过程如下图所示 

<img width="612" height="322" alt="image" src="https://github.com/user-attachments/assets/dfa2b494-aad6-4da9-9f74-150069f29154" />


优点：实现简单，不需要对对象进行移动。

缺点：

1. 空间问题，易产生内存碎片，当为一个大对象分配空间时可能会提前触发垃圾回收（例如，对象的大小大于空闲列表中的每一块儿大小但是小于其中两块儿的和）。

2. 效率问题，扫描了整个空间两次（第一次：标记存活对象；第二次：清除没有标记的对象）。标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。


总之：

标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。

### (2) 标记-复制算法
为了解决标记-清除算法的效率不高的问题，产生了标记-复制算法。

它把内存空间划为两个相等的区域，每次只使用其中一个区域。

垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收。

优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。

缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。

复制算法的执行过程如下图所示 

<img width="763" height="386" alt="image" src="https://github.com/user-attachments/assets/8b29bc3d-8cbd-4878-b5ec-81d0e855620c" />


### (3) 标记-整理算法
在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。

标记-清除算法可以应用在老年代中，但是效率不高，在内存回收后容易产生大量内存碎片。

因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。

回收后，已用和未用的内存都各自一边。

优点：解决了标记-清理算法存在的内存碎片问题。

缺点：仍需要进行局部对象移动，一定程度上降低了效率。

标记-整理算法的执行过程如下图所示

<img width="726" height="393" alt="image" src="https://github.com/user-attachments/assets/30c5148f-81af-4dd0-a711-840a34a8b429" />

标记-整理算法适用场合：存活对象较少的情况下比较高效、用于年轻代（即新生代）。

### （4）分代收集算法
分代收集算法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将GC堆划分为老年代（Tenured/Old Generation）和新生代（Young Generation）。

老年代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。

当前商业虚拟机都采用**分代收集**的垃圾收集算法。分代收集算法，顾名思义是根据对象的存活周期将内存划分为几块。一般包括年轻代、老年代和永久代，如图所示：

<img width="781" height="220" alt="image" src="https://github.com/user-attachments/assets/19f2b8a1-b2d9-4fc1-9f0d-4435a616f7af" />


当前主流VM垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法会根据对象存活周期的不同将内存划分为几块，如JVM中的新生代、老年代、永久代，这样就可以根据各年代特点分别采用最适当的GC算法 

# 新生代与复制算法
每次垃圾收集都能发现大批对象已死，只有少量存活，因此选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集 

目前大部分JVM的GC对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。

一般将新生代划分为一块较大的Eden空间和两个较小的Survivor空间（from Space, To Space），每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中。 

<img width="803" height="146" alt="image" src="https://github.com/user-attachments/assets/640e83f8-b36a-4a0d-afa0-76dcc87f6a94" />


# 老年代与标记复制算法
因为老年代对象存活率高，没有额外空间对它进行分配担保，就必须采用“标记-清理”或“标记-整理”算法来进行回收，不必进行内存复制，且直接腾出空闲内存。因而采用Mark-Compact算法。 


1. JAVA 虚拟机提到过的处于方法区的永生代（Permanent Generation），它用来存储 class 类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。

2. 对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space（Survivor 目前存放对象的那一块），少数情况会直接分配到老生代。

3. 当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，EdenSpace 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 FromSpace 进行清理。

4. 如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。

5. 在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。

6. 当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被移到老生代中。


# GC 垃圾收集器
Java 堆内存被划分为新生代和老年代两部分，新生代主要使用复制和标记-清除垃圾回收算法；年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟机中针对新生代和年老代分别提供了多种不同的垃圾收集器，JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下： 

<img width="739" height="416" alt="image" src="https://github.com/user-attachments/assets/f174772f-f936-40e7-b36d-e0ca8d69cd84" />




# 说一下 JVM 有哪些垃圾回收器？
如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括 Serial、ParNew、Parallel Scavenge，回收老年代的收集器包括 Serial Old、Parallel Old、CMS，还有用于回收整个 Java 堆的 G1 收集器。不同收集器之间的连线表示它们可以搭配使用。 

<img width="708" height="468" alt="image" src="https://github.com/user-attachments/assets/a1006d07-99ea-4f7c-9b3f-3fa1d834fd1a" />

- Serial收集器（复制算法）：新生代单线程收集器，标记和清理都是单线程，优点是简单高效；
- ParNew收集器（复制算法）：新生代并行收集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；
- Parallel Scavenge收集器（复制算法）：新生代并行收集器，追求高吞吐量，高效利用CPU，吞吐量=用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；
- Serial Old收集器（标记-整理算法）：老年代单线程收集器，Serial收集器的老年代版本；
- Parallel Old收集器（标记-整理算法）： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；
- CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。
- G1(Garbage First)收集器（标记-整理算法）： java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或者老年代。

# Serial 与 Parallel GC 之间的不同之处？
Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而 parallel 收集器使用多个 GC 线程来执行。

# 类似的问题：你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms和G1，包括原理，流程，优缺点。
思路：一定要记住典型的垃圾收集器，尤其cms和G1，它们的原理与区别，涉及的垃圾回收算法。

参考答案:

1) 几种垃圾收集器:
- Serial收集器: 单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。
- ParNew收集器: Serial收集器的多线程版本，也需要stop the world，复制算法。
- Parallel Scavenge收集器: 新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控制的吞吐量。如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，吞吐量就是99%。
- Serial Old收集器: 是Serial收集器的老年代版本，单线程收集器，使用标记整理算法。
- Parallel Old收集器: 是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。
- CMS(Concurrent Mark Sweep)收集器: 是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片。
- G1收集器: 标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选标记。不会产生空间碎片，可以精确地控制停顿。

2) CMS收集器和G1收集器的区别:
- CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；
- G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；
- CMS收集器以最小的停顿时间为目标的收集器；
- G1收集器可预测垃圾回收的停顿时间
- CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
- G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

# 详细介绍一下 CMS 垃圾回收器？
CMS 是英文 Concurrent Mark - Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。

CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。

# Serial 垃圾收集器（单线程、复制算法）
Serial（英文连续）是最基本垃圾收集器，使用复制算法，曾经是 JDK1.3.1 之前新生代唯一的垃圾收集器。Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。

Serial 垃圾收集器虽然在收集过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial 垃圾收集器依然是 Java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。

# ParNew 垃圾收集器（Serial+多线程）
ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。

ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过 -XX:ParallelGCThreads 参数来限制垃圾收集器的线程数。【Parallel：平行的】


ParNew虽然是除了多线程外和Serial收集器几乎完全一样，但是ParNew垃圾收集器是很多Java虚拟机运行在Server模式下新生代的默认垃圾收集器。

# Parallel Scavenge收集器（多线程复制算法、高效）
Parallel Scavenge收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量（Throughput，CPU用于运行用户代码的时间/CPU总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间) ），高吞吐量可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别。

- **新生代**：Parallel Scavenge收集器也是一个新生代垃圾收集器；
- **复制算法**：Parallel Scavenge收集器同样使用复制算法；
- **多线程**：Parallel Scavenge收集器也是一个多线程的垃圾收集器；
- **高吞吐量**：Parallel Scavenge重点关注的是程序达到一个可控制的吞吐量（Throughput，吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）），高吞吐量可以最高效率地利用CPU时间，尽快地完成程序的运算任务；
- **适用场景**：主要适用于在后台运算而不需要太多交互的任务。自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别。

新生代Parallel Scavenge收集器与ParNew收集器工作原理类似：

1. 都是多线程的收集器；

2. 都使用的是复制算法；

3. 在垃圾收集过程中都需要暂停所有的工作线程。

# Serial Old收集器（单线程标记整理算法 ）
Serial Old是Serial垃圾收集器老年代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的 

- **老年代**：Serial Old是Serial垃圾收集器老年代的版本；
- **标记-整理算法**：Serial Old使用标记-整理算法；
- **单线程**：Serial Old与Serial一样是单线程收集器；
- **Client模式**：JVM运行在Client模式下，Serial Old是默认的老年代垃圾收集器；
- **Server模式**：JVM运行在Server模式下，Serial Old主要有两个用途：
    1. 在JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用；
    
    2. 作为老年代中使用CMS收集器的后备垃圾收集方案。

新生代Serial与老年代Serial Old搭配垃圾收集过程图:

<img width="756" height="328" alt="image" src="https://github.com/user-attachments/assets/d8a8988a-0920-4794-a92c-f88da3d934d5" />


新生代 Parallel Scavenge 收集器与 ParNew 收集器工作原理类似，都是多线程的收集器，都使用的是
复制算法，在垃圾收集过程中都需要暂停所有的工作线程。


# Parallel Old 收集器（多线程标记整理算法）

Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6才开始
提供。

在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证
新生代的吞吐量优先，无法保证整体的吞吐量，

在 JDK1.6才开始， Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器， 如果系统对吞
吐量要求比较高，可以优先考虑新生代Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。

- 老年代：Parallel Old 收集器是 Parallel Scavenge 的老年代版本；
- 标记-整理算法：Parallel Old 收集器使用标记-整理算法；
- 多线程：Parallel Old 收集器是多线程收集器；

- 高吞吐量：Parallel Old 是能够为老年代提供吞吐量优先的垃圾收集器；
- JDK1.6：Parallel Old 是 JDK1.6才开始提供的。

新生代 Parallel Scavenge 和年老代 Parallel Old 收集器搭配运行过程图

<img width="823" height="217" alt="image" src="https://github.com/user-attachments/assets/98e4c2b4-3b8a-4d54-bde9-4920313c1529" />

新生代 Parallel Scavenge 收集器，使用的是标记-复制算法，在垃圾收集过程中都需要暂停所有的工作
线程。

老生代 Parallel Old 收集器，使用的是标记-整理算法，在垃圾收集过程中都需要暂停所有的工作线程。

Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及
CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。


# CMS 收集器（多线程标记清除算法）
Concurrent mark sweep(CMS)收集器是一种老年代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他老年代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。

- **老年代**：CMS（Concurrent mark sweep）收集器是一种年老代垃圾收集器；
- **标记-清理算法**：和其他年老代使用标记-整理算法，CMS 使用标记-清除算法；
- **多线程**：CMS 采用的是多线程并发的标记-清除算法；
- **停顿时间端**：CMS 最主要目标是获取最短垃圾回收停顿时间，最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。

CMS 工作机制相比其他的垃圾收集器来说更复杂。整个过程分为以下 4 个阶段：

### 初始标记
只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。

### 并发标记
进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。

### 重新标记
为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。

### 并发清除
清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作， 所以总体上来看CMS 收集器的内存回
收和用户线程是一起并发地执行。

CMS 收集器工作过程

<img width="534" height="179" alt="image" src="https://github.com/user-attachments/assets/0c303efc-b2a4-4eef-aa35-e91928647e46" />


漂亮点的图

<img width="545" height="215" alt="image" src="https://github.com/user-attachments/assets/ce099d77-91d0-43d3-a22b-9cee46f616db" />


# G1 收集器

Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器， G1 收集器
两个最突出的改进是：
- 1.基于标记-整理算法，不产生内存碎片。
- 2.可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。
G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃
圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收垃圾最多的区
域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率


### G1特点
- 无分代：G1 将新生代，老年代的物理空间划分取消了。这样我们再也不用单独的空间对每个代进
行设置了，不用担心每个代内存是否足够；
- 标记-整理算法：G1 收集器采用标记-整理算法，无内存碎片产生；
- 分区回收：G1 虽然没有了新生代与老年代的物理限制，但是 G1 采取内存分区策略，将堆内存划
分为大小固定的几个独立区域。在分区中，同时存在新生代与老年代

#### 分区

<img width="558" height="206" alt="image" src="https://github.com/user-attachments/assets/c3b7f389-1fc8-4217-81ea-7ecf3474343d" />

新生代区域：G1 收集器中新世代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者 Survivor 空间；

老年代区域：G1 收集器通过将对象从一个区域复制到另外一个区域，以此来完成老年代的清理工作；

Humongous 区域：巨型对象区域。如果一个对象占用的空间超过了分区容量 50%以上，G1 收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放巨型对象。如果一个 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储。为了能找到连续的 H 区，有时候不得不启动 Full GC。

# 对象分配策略
说起大对象的分配，我们不得不谈谈对象的分配策略。


它分为 3 个阶段：

- 1. TLAB（Thread Local Allocation Buffer）线程本地分配缓冲区
- 2. Eden 区中分配
- 3. Humongous 区分配

TLAB 为线程本地分配缓冲区，它的目的为了使对象尽可能快的分配出来。

如果对象在一个共享的空间中分配，我们需要采用一些同步机制来管理这些空间内的空闲空间指针。

在 Eden 空间中，每一个线程都有一个固定的分区用于分配对象，即一个 TLAB。分配对象时，线程之间不再需要进行任何的同步。

对 TLAB 空间中无法分配的对象，JVM 会尝试在 Eden 空间中进行分配。

如果 Eden 空间无法容纳该对象，就只能在老年代中进行分配空间。

最后，G1 提供了两种 GC 模式，Young GC 和 Mixed GC，两种都是 Stop The World（STW）的。

下面我们将分别介绍一下这 2 种模式。

# G1 Young GC

Young GC 主要是对 Eden 区进行 GC，它在 Eden 空间耗尽时会被触发。在这种情况下，Eden 空间的数据移动到 Survivor 空间中，如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间。Survivor 区的数据移动到新的 Survivor 区中，也有部分数据晋升到老年代空间中。最终 Eden 空间的数据为空，GC 停止工作，应用线程继续执行。

### G1 Young GC 阶段:

1. 根扫描：静态和本地对象被扫描；


2. 更新 RS: 处理 Dirty Card 队列更新 RS（Remembered Set，作用是跟踪指向某个 Heap 区内的对象引用）；

3. 处理 RS: 检测从年轻代指向老年代的对象；

4. 对象拷贝：拷贝存活的对象到 Survivor/Old 区域；

5. 处理引用队列：软引用，弱引用，虚引用处理.

# G1 Mix GC
Mix GC 不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。

### G1 Mix GC 运行步骤:

1. 全局并发标记（global concurrent marking）

- 1.1. 初始标记（initial mark，STW）：在此阶段，G1 GC 对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关；

- 1.2. 根区域扫描（root region scan）：G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下一次 STW 年轻代垃圾回收；

- 1.3. 并发标记（Concurrent Marking）：G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断；

- 1.4. 最终标记（Remark，STW）：该阶段是 STW 回收，帮助完成标记周期。G1 GC 清空 SATB 缓冲区，跟踪未被访问的存活对象，并执行引用处理；

- 1.5. 清除阶段（Cleanup，STW）：在这个最后阶段，G1 GC 执行统计和 Rset 净化的 STW 操作。在统计期间，G1 GC 会识别完全空闲的区域和可供进行混合垃圾回收的区域。清理阶段在将空白区域重置并返回到空闲列表时为部分并发。

2. 拷贝存活对象（evacuation）

G1 收集器与 CMS 收集器相比，G1 收集器两个最突出的改进是:

1. 基于标记-整理算法，不产生内存碎片；

2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。

```
// G1 收集器参数设置
-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200
// -XX:+UseG1GC  —— 为开启G1垃圾收集器。
// -Xmx32g  —— 设计堆内存的最大内存为32G，
// -XX:MaxGC
```

# 新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别?
- 新生代回收器：Serial、ParNew、Parallel Scavenge
- 老年代回收器：Serial Old、Parallel Old、CMS
- 整堆回收器：G1
新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。

# 简述分代垃圾回收器是怎么工作的？
分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老年代的默认占比是 2/3。

新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：
- 把 Eden + From Survivor 存活的对象放入 To Survivor 区；
- 清空 Eden 和 From Survivor 分区；
- From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。

每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。

老生代当空间占用到达某个值之后就会触发全局垃圾回收，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。

# 什么时候会触发 Full GC？
除直接调用 System.gc 外，触发 Full GC 执行的情况有如下四种。

### 1. 旧生代空间不足
老生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行 Full GC 后空间仍然不足，则抛出如下错误：
java.lang.OutOfMemoryError: Java heap space 

为避免以上两种状况引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。

### 2. Permanet Generation 空间满
PermanentGeneration 中存放的为一些 class 的信息等，当系统中要加载的类、反射的类和调用的方法较多时，PermanentGeneration 可能会被占满，在未配置为采用 CMS GC 的情况下会执行 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出如下错误信息：
java.lang.OutOfMemoryError: PermGen space 

为避免 Perm Gen 占满造成 Full GC 现象，可采用的方法为增大 Perm Gen 空间或转为使用 CMS GC。

### 3. CMS GC 时出现 promotion failed 和 concurrent mode failure
对于采用 CMS 进行老年代 GC 的程序而言，尤其要注意 CMS 日志中是否有 promotion failed 和 concurrent mode failure 两种状况，当这两种状况出现时可能会触发 Full GC。

promotion failed 是在进行 Minor GC 时，survivor space 放不下、对象只能放入老生代，而此时老生代也放不下造成的；concurrent mode failure 是在执行 CMS GC 的过程中同时有对象要放入老生代，而此时老生代空间不足造成的。

应对措施：增大 Survivorspace、CMS 生代空间或调低触发 GC 的比率，但在 DK 5.0+、6.0+的版本中有可能会由于 JDK 的 bug 导致 CMS 在 remark 完毕后很久才触发 sweep 动作。对于这种状况，可通过设置 -XX:CMSMaxAbortablePrecleanTime=5（单位为 ms）来避免。

### 4. 统计得到的 Minor GC 晋升到旧生代的平均大小大于旧生代的剩余空间
这是一个较为复杂的触发情况，Hotspot 为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行 Minor GC 时，做了一个判断：如果之前统计所得的 Minor GC 晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发 Full GC。

例如程序第一次触发 Minor GC 后，有 6MB 的对象晋升到旧生代，那么当下一次 Minor GC 发生时，首先检查旧生代的剩余空间是否大于 6MB，如果小于 6MB，则执行 Full GC。

当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过 -java -Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc 


# 方法区的垃圾回收
《Java虚拟机规范》对方法区的的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集；

事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在，如JDK1.1时期的ZGC收集器就不支持类卸载。

一般来说，方法区的回收效果比较难令人满意，尤其是**类型的卸载，条件相当苛刻**。

但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的Hotspot虚拟机对此区域未完全回收而导致内存泄漏。

方法区的垃圾收集主要回收两部分内容：
- 运行时常量池中废弃的常量
- 不再使用的类型。

### A. 运行时常量池中废弃的常量
方法区内运行时常量池之中，主要存放的两大类常量：字面量和符号引用。

字面量比较接近java语言层次的常量概念，如文本字符串、被声明为final的常量值等；而符号引用则属于编译原理方面的概念，包括下面三类常量：1）类和接口的全限定名；2）字段的名称和描述符；3）方法的名称和描述符。

Hotspot虚拟机对运行时常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。

### B. 不再使用的类型
判定一个类型是否属于“不再被使用的类型”的条件比较苛刻，需要同时满足下面三个条件：
- 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
- 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

<img width="582" height="374" alt="image" src="https://github.com/user-attachments/assets/30279e7e-0e97-44cd-880e-f67b0b36bf05" />


Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。

在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 SPI 以及 OSGi 这类频繁自定义类加载器的场景中，通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

# 问：说是方法区和堆的区别？
逻辑上，方法区是属于堆的一部分，

但实现上，一些简单的 JVM 实现，可能不会对方法区选择进行垃圾收集或者进行压缩。

HotSpot 虚拟机的方法区还有一个别名，叫做 Non-Heap（非堆），目的就是要和堆分开。

所以，方法区看作是一块独立于 Java 堆的内存空间 。

- 方法区是各线程共享的内存区域。
- 方法区在 JVM 启动的时候被创建，它的实例的物理内存空间可以是不连续的。
- 方法区的大小，可以选择固定大小或者可扩展。如果方法区无法满足新的内存分配需求时，将抛出 OOM 异常。
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，会导致方法区溢出，虚拟机会抛出内存溢出错误：
```
java.lang.OutOfMemoryError: PermGen space
```
或者
```
java.lang.OutOfMemoryError: Metaspace
```

比如，以下情况:
- 加载大量的第三方的 jar 包；
- Tomcat 部署的工程过多（30 - 50 个）；

- 大量动态的生成反射类。
- 关闭JVM就会释放该区域的内存。

方法区是虚拟机规范中提出的，不同的虚拟机可以有不同的实现，在HotSpot不同版本中方法区的演进如下：
- 在JDK7及以前，习惯上把方法区称为永久代（PermGen），从JDK8开始，使用元空间（Metaspace）作为方法区的实现。
  - In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.
- 本质上，方法区和永久代并不等价，这两个概念仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求，例如：BEA JRockit和IBMJ9中，就不存在永久代的概念。
  - 现在来看，当年使用永久代，不是好的idea，导致java程序更容易出现OOM（超过-XX:MaxPermSize上限）。
- 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。两者的最大区别是：元空间不在虚拟机设置的内存中，而是使用本地内存。 

<img width="801" height="358" alt="image" src="https://github.com/user-attachments/assets/87797724-3fc9-46ff-95c6-f384b4921151" />


# 问：如何解决方法区的OOM？
要解决OOM异常或heap space的异常，一般手段是通过内存映像分析工具（如 Eclipse Memory Analyzer）对dump出来的堆转储快照文件进行分析，

重点是确认内存中的对象是否还都是必要存活的，即要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。

- 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，就能找到泄漏对象是通过怎样的路径与 GC Roots相关联，并导致垃圾收集器无法自动回收它们的。掌握泄漏对象的类型信息，以及 GC Roots 引用链的信息后，就可以比较准确地定位出泄漏代码的位置。
- 如果不存在内存泄漏，即内存中的对象确实都还必须存活者，就应当根据机器物理内存，检查虚拟机的堆参数（-Xmx与-Xms），看是否还可以调大；从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况（其实也算内存泄漏），尝试减少程序运行期的内存消耗。

# 问：如何设置方法区内存的大小

方法区的大小不是固定的，JVM可以根据应用的需要进行动态调整。

### JDK7及之前：
- 通过 `-XX:Permsize` 来设置永久代的初始分配空间，默认值是20.75M。
- 通过 `-XX:MaxPermsize` 来设置永久代的最大可分配空间，32位机器默认是64M，64位机器模式是82M。
- 当JVM加载的类信息容量超过最大值，会报异常 `OutOfMemoryError: PermGen space`。

### JDK8及之后：
- 通过设置参数 `-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize` 来设置元空间的初始分配空间和最大可分配空间。
- 上述参数的默认值依赖于平台，Windows系统下，`-XX:MetaspaceSize` 是21M，`-XX:MaxMetaspaceSize` 的值是-1，即没有限制。
- 如果不指定元空间大小，使用默认值，方法区可能耗尽所有的可用系统内存。如果元空间发生溢出，虚拟机会抛出异常 `OutOfMemoryError: Metaspace`。
- 通过 `-XX:MetaspaceSize` 设置的初始元空间大小是一个初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载不再使用的类，然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间，如果释放的空间不足，那么在不超过 `MaxMetaspaceSize` 时，适当提高该值。如果释放空间过多，则适当降低该值。所以，如果初始化的高水位线设置过低，高水位线调整情况会发生很多次，通过垃圾回收器的日志，可以观察到Full GC多次调用。为了避免频繁Full GC，建议将 `-XX:MetaspaceSize` 设置为一个相对较高的值。











