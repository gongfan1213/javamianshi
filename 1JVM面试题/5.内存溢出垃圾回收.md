# 内存溢出异常
# Java会存在内存泄漏吗？请简单描述
内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。

但是，即使这样，Java也还是存在着内存泄漏的情况，Java导致内存泄漏的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。

# 什么情况下会发生栈内存溢出。
**思路**：描述栈定义，再描述为什么会溢出，再说明一下相关配置参数，OK的话可以给面试官手写是一个栈溢出的demo。

**参考答案**:

- 栈是线程私有的，它的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型
- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常，方法递归调用产生这种结果。
- 如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将抛出一个OutOfMemory异常。(线程启动过多)
- 参数 -Xss 去调整JVM栈的大小 

# 垃圾收集器
# 简述Java垃圾回收机制
在Java中，程序员是不需要显式的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

# GC是什么？为什么要GC
GC是垃圾收集的意思（Garbage Collection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存

回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动

回收内存的目的，Java语言没有提供释放已分配内存的显式操作方法。

# 垃圾回收的优点和原理。并考虑2种回收机制
Java语言最显著的特点就是引入了垃圾回收机制，它使Java程序员在编写程序时不再考虑内存管理的问题。

由于有这个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。

垃圾回收机制有效的防止了内存泄漏，可以有效的使用可使用的内存。

垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。

程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。

垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。

# 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。

通常，GC采用有向图的方式记录和管理堆（heap）中的所有对象。通过这种方式确定哪些对象是“可达的”，哪些对象是“不可达的”。当GC确定一些对象为“不可达”时，GC就有责任回收这些内存空间。

可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。
# 你能保证 GC 执行吗？
不能，虽然你可以调用System.gc()或者Runtime.gc()，但是没有办法保证GC的执行。

# Java 中都有哪些引用类型？
- 强引用：发生gc的时候不会被回收。
- 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。
- 弱引用：有用但不是必须的对象，在下一次GC时会被回收。
- 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用PhantomReference实现虚引用，虚引用的用途是在gc时返回一个通知。
# 介绍一下强引用、软引用、弱引用、虚引用的区别？
思路：先说一下四种引用的定义，可以结合代码讲一下，也可以扩展谈到ThreadLocalMap里弱引用用处。

参考答案:

1) 强引用  

我们平时new了一个对象就是强引用，例如 Object obj = new Object();即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。  

2) 软引用  

如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。  

```java
SoftReference<String> softRef = new SoftReference<String>(str); // 软引用
```

用处：软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。

(1) 如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建

(2) 如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出

如下代码:

```
Browser prev = new Browser();                     // 获取页面进行浏览
SoftReference sr = new SoftReference(prev);  // 浏览完毕后置为软引用
if(sr.get()!=null){
    rev = (Browser) sr.get();                     // 还没有被回收器回收，直接获取
}else {
    prev = new Browser();                         // 由于内存吃紧，所以软引用的对象被回收了
    sr = new SoftReference(prev);                 // 重新构建
}
```

3) 弱引用

具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

```
String str=new String("abc");
WeakReference<String> abcWeakRef = new WeakReference<String>(str);
str=null;
等价于
str = null;
System.gc();
```

4) 虚引用

如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。

# 怎么判断对象是否可以被回收?
垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。
一般有两种方法来判断:
- 引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；
- 可达性分析法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。

# 在Java中，对象什么时候可以被垃圾回收
当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。

垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收（Full GC）。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。

# JVM 运行时堆内存如何分代?

Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代。

参考图1:

<img width="524" height="178" alt="image" src="https://github.com/user-attachments/assets/c296c9e4-ead6-40f3-ad9b-bf3348022482" />



参考图2:

<img width="594" height="251" alt="image" src="https://github.com/user-attachments/assets/48e2174f-ca65-4e93-8536-06efab2877d0" />


从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。

默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定
)，

即：**新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。**

其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为
from 和 to，以示区分

默认的，Eden: from : to = 8 :1 : 1 ( 可以通过参数–XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的
新生代空间大小，from = to = 1/10 的新生代空间大小。

JVM **每次只会使用 Eden 和其中的一块 Survivor 区域**来为对象服务，所以无论什么时候，总是有一块
Survivor区域是空闲着的。


因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。


## 新生代

是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC
进行垃圾回收。新生代又分为 Eden区、 ServivorFrom、 ServivorTo 三个区。

### Eden 区
Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够
的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。
### Servivor from 区
上一次 GC 的幸存者，作为这一次 GC 的被扫描者。
### Servivor to 区
保留了一次 MinorGC 过程中的幸存者。

**MinorGC 的过程（复制->清空->互换）**

MinorGC 采用复制算法。

1. eden、 servicorFrom 复制到 ServicorTo，年龄+1

首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以
及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位
置了就放到老年区）；

2. 清空 eden、 servicorFrom

然后，清空 Eden 和 ServicorFrom 中的对象；

3. ServicorTo 和 ServicorFrom 互换

最后， ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区


## 老年代

主要存放应用程序中生命周期长的内存对象。

老年代的对象比较稳定，所以 MajorGC （常常称之为 FULL GC）不会频繁执行。在进行 FULL GC前一
般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法
找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空
间。

 
 FULL GC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对
象。 ajorGC 的耗时比较长，因为要扫描再回收。 FULL GC 会产生内存碎片，为了减少内存损耗，我
们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出
OOM（Out of Memory）异常。

## 永久代 （或者 jdk1.8元空间）
指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久
区域， 它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久
代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。

# JVM内存为什么要分成新生代，老年代，永久代。新生代中为什么要分为Eden和Survivor。
**思路**： 先讲一下JAVA堆，新生代的划分，再谈谈它们之间的转化，相互之间一些参数的配置（如： –
XX:NewRatio，–XX:SurvivorRatio等），再解释为什么要这样划分，最好加一点自己的理解。

**参考答案：**

这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。

1）共享内存区划分
- 共享内存区 = 永久代 + 堆
- 永久代 = 方法区 + 其他
- Java堆 = 老年代 + 新生代
- 新生代 = Eden + S0 + S1

2）一些参数的配置
- 默认的，新生代（Young）与老年代（Old）的比例的值为 1:2，可以通过参数 -XX:NewRatio 配置。
- 默认的，Eden: from: to = 8:1:1（可以通过参数 -XX:SurvivorRatio 来设定）
- Survivor 区中的对象被复制次数为 15（对应虚拟机参数 -XX:MaxTenuringThreshold）

3）为什么要分为 eden 和 survivor？为什么要设置两个 survivor 区？
- 如果没有 Survivor，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发 Major GC。老年代的内存空间远大于新生代，进行一次 Full GC 消耗的时间比 Minor GC 长得多，所以需要分为 Eden 和 Survivor。
- Survivor 的存在意义，就是减少被送到老年代的对象，进而减少 Full GC 的发生，Survivor 的预筛选保证，只有经历 16 次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。
- 设置两个 Survivor 区最大的好处就是解决了碎片化，刚刚新建的对象在 Eden 中，经历一次 Minor GC，Eden 中的存活对象就会被移动到第一块 survivor space S0，Eden 被清空；等 Eden 区再满了，就再触发一次 Minor GC，Eden 和 S0 中的存活对象又会被复制送入第二块 survivor space S1（这个过程非常重要，因为这种复制算法保证了 S1 中来自 S0 和 Eden 两部分的存活对象占用连续的内存空间，避免了碎片化的发生）

# JVM 中一次完整的 GC 流程是怎样的，对象如何晋升到老年代
**思路**：先描述一下 Java 堆内存划分，再解释 Minor GC，Major GC，full GC，描述它们之间转化流程。

**我的答案:**

- Java 堆 = 老年代 + 新生代
- 新生代 = Eden + S0 + S1
- 当 Eden 区的空间满了，Java 虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor。
- **大对象**（需要大量连续内存空间的 Java 对象，如那种很长的字符串）**直接进入老年态**；
- 如果对象在 Eden 出生，并经过第一次 Minor GC 后仍然存活，并且被 Survivor 容纳的话，年龄设为 1，每熬过一次 Minor GC，年龄 +1，**若年龄超过一定限制（15），则被晋升到老年代，即长期存活的对象进入老年态**。
- 老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行 Full GC，Full GC 清理整个内存堆 - 包括年轻代和老年代。
- Major GC 发生在老年代的 GC，清理老年代，经常会伴随至少一次 Minor GC，比 Minor GC 慢 10 倍以上。

# 聊聊：什么是分代，分代的必要性
Java 虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代（对 HotSpot 虚拟机而言），这就是 
JVM 的内存分代策略。

JDK 1.7 之前，Java 虚拟机将堆内存划分为新生代、老年代和永久代（或者元空间），

永久代是 HotSpot 虚拟机特有的概念（JDK1.8 之后为 metaspace 元空间替代永久代），它采用永久代的方式来实现方法区，其他的虚拟机实现没有这一概念，


而且 HotSpot 也有去永久代的趋势，在 JDK 1.7 中 HotSpot 已经开始了“去永久代化”，把原本放在永久代的字符串常量池移出。永久代主要存放常量、类信息、静态变量等数据，与垃圾回收关系不大，新生代和老年代是垃圾回收的主要区域。

堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中。

给堆内存分代，是为了**提高对象内存分配和垃圾回收的效率。**

试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾收集，而每次回收都要遍历所有的对象，遍历这些对象所花费的时间代价是巨大的，会严重影响我们的 GC 效率。

有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放在老年代中。


**静态属性、类信息**等存放在永久代（或者元空间）中，

新生代中的对象存活时间短，只需要在新生代区域中频繁进行 GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收。

永久代（或者元空间）中回收效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾收集算法。

分代收集大大提升了收集效率，这些都是内存分代带来的好处。

# JVM中的永久代中会发生垃圾回收吗
垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收（Full GC）。


如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。

这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。

# JAVA8 与元数据
在 Java8 中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。

元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。

因此，默认情况下，元空间的大小仅受本地内存限制。

类的元数据放入 native memory，字符串池和类的静态变量放入 Java 堆中，这样可以加载多少类的元数据就不再由 MaxPermSize 控制，而由系统的实际可用空间来控制。

# 如何判断对象可以被回收？
判断对象是否存活一般有两种方式：
- **引用计数**：  
每个对象有一个引用计数属性，新增一个引用时计数加 1，引用释放时计数减 1，计数为 0 时可以回收。  
此方法简单，无法解决对象相互循环引用的问题。  

- **可达性分析（Reachability Analysis）**：

从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。

## 引用计数法
在Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用，即他们的引用计数都不为0，则说明该对象不太可能再被用到，那么这个对象就是可回收对象。

## 可达性分析
为了解决引用计数法的循环引用问题，Java使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。

# Minor GC与Full GC分别在什么时候发生？
新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC 

# 垃圾收集算法有哪些类型？
GC最基础的算法有三类：标记-清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。

标记-清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。

复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活者的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法 



# 说一下JVM有哪些垃圾回收算法？
- 标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。 
- 复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。 
- 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
