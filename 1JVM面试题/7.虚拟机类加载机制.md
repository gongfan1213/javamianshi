# 虚拟机类加载机制
# 简述java类加载机制？
虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的 java 类型。

# 描述一下JVM加载Class文件的原理机制
Java 中的所有类，都需要由类加载器装载到 VM 中才能运行，类加载器本身也是一个类，而它的工作就是把 class 文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。

类装载方式，有两种：

1. 隐式装载，程序在运行过程中当碰到通过 new 等方式生成对象时，隐式调用类装载器加载对应的类到 jvm 中，

2. 显式装载，通过 class.forname()等方法，显式加载需要的类 

Java 类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类（像是基类完全加载到 jvm 中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。

# 描述一下JVM加载class文件的原理机制
JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。

由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class 文件中的数据读入到内存中，通常是创建一个字节数组读入.class 文件，然后产生与所加载类对应的 Class 对象。

加载完成后，Class 对象还不完整，所以此时的类还不可用。当类加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后 JVM 对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。

类的加载器是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader 的子类）。


从 Java 2（JDK 1.2）开始，类加载过程采取了父类委托机制（PDM）。PDM 更好的保证了 Java 平台的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类加载器的说明：

1. Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）；

2. Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap；

3. System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者应用属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。

# JVM类加载机制
JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。

<img width="600" height="202" alt="image" src="https://github.com/user-attachments/assets/742fcec2-9968-49fc-9ae9-663a6f402d4e" />


### 加载
加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。

### 验证
这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

### 准备

准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内
存空间。注意这里所说的初始值概念，比如一个类变量定义为：

实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080， 将 v 赋值为 8080 的 put static 指令是程序
被编译后， 存放于类构造器方法之中

但是注意如果声明为：public static final int v = 8080;
在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值
为 8080。

#### 解析
解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：

```java
public static int v = 8080;
```
实际上变量 `v` 在准备阶段过后的初始值为 `0` 而不是 `8080`，将 `v` 赋值为 `8080` 的 `put static` 指令是程序被编译后，存放于类构造器方法之中。但是注意如果声明为：

在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v
赋值为 8080。解析

解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：

```java
public static final int v = 8080;
```
在编译阶段会为 `v` 生成 `ConstantValue` 属性，在准备阶段虚拟机会根据 `ConstantValue` 属性将 `v` 赋值为 `8080`。

### 解析
解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：
```java
public static final int v = 8080;
```
实际上变量 `v` 在准备阶段过后的初始值为 `0` 而不是 `8080`，将 `v` 赋值为 `8080` 的 `put static` 指令是程序被编译后，存放于类构造器方法之中。但是注意如果声明为：
```java
public static final int v = 8080;
```
在编译阶段会为 `v` 生成 `ConstantValue` 属性，在准备阶段虚拟机会根据 `ConstantValue` 属性将 `v` 赋值为 `8080`。

解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：
```java
public static final int v = 8080;
```
在编译阶段会为 `v` 生成 `ConstantValue` 属性，在准备阶段虚拟机会根据 `ConstantValue` 属性将 `v` 赋值为 `8080`。

解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：

1. `CONSTANT_Class_info`

2. `CONSTANT_Field_info`

3. `CONSTANT_Method_info`  

等类型的常量。

#### 符号引用
符号引用与虚拟机实现的布局无关， 引用的目标并不一定要已经加载到内存中。 各种虚拟机实现的内
存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义
在 Java 虚拟机规范的 Class 文件格式中。
#### 直接引用
直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，
那引用的目标必定已经在内存中存在
### 初始化
初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。

#### 类构造器
初始化阶段是执行类构造器方法的过程，方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子方法执行之前，父类的方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成方法。注意以下几种情况不会执行类初始化：

1. 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。

2. 定义对象数组，不会触发该类的初始化。

3. 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。

4. 通过类名获取 Class 对象，不会触发类的初始化。

5. 通过 `Class.forName` 加载指定类时，如果指定参数 `initialize` 为 `false` 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。

6. 通过 `ClassLoader` 默认的 `loadClass` 方法，也不会触发初始化动作。

# 什么是类加载器，类加载器有哪些?

实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。

主要有一下四种类加载器:

1. 启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。

2. 扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一
个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。

3. 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java
类。一般来说，Java 应用的类都是由它来完成加载的。可以通过

ClassLoader.getSystemClassLoader()来获取它。

4. 用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。


# 说一下类装载的执行过程？

类装载分为以下 5 个步骤：

加载：根据查找路径找到相应的 class 文件然后导入；

验证：检查加载的 class 文件的正确性；

准备：给类中的静态变量分配内存空间；

解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直
接引用直接指向内存中的地址；

初始化：对静态变量和静态代码块执行初始化工作。

# 什么是双亲委派模型？

在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身
一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全
限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。

<img width="428" height="403" alt="image" src="https://github.com/user-attachments/assets/3179fe55-33be-4bc6-a7cc-e21ead873306" />

类加载器分类：
- 启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目
录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；
- 其他类加载器：
- 扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的
路径中的所有类库；
- 应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类
库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加
载器。

双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请
求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启
动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会
尝试去加载类。

当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果
此时父类不能加载，反馈给子类，由子类去完成类的加载

# 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。

思路： 先说明一下什么是类加载器，可以给面试官画个图，再说一下类加载器存在的意义，说一下双亲
委派模型，最后阐述怎么打破双亲委派模型。

参考的答案：

1) 什么是类加载器？

类加载器就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。

- **启动类加载器（Bootstrap ClassLoader）**：由C++语言实现（针对HotSpot）,负责将存放在`<JAVA_HOME>\lib`目录或`-Xbootclasspath`参数指定的路径中的类库加载到内存中。
- **其他类加载器**：由Java语言实现，继承自抽象类`ClassLoader`。如：
  - **扩展类加载器（Extension ClassLoader）**：负责加载`<JAVA_HOME>\lib\ext`目录或`java.ext.dirs`系统变量指定的路径中的所有类库。
  - **应用程序类加载器（Application ClassLoader）**：负责加载用户类路径（`classpath`）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

2）双亲委派模型
### 双亲委派模型工作过程是：
如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即`ClassNotFoundException`），子加载器才会尝试自己去加载。

### 双亲委派模型图: 

<img width="610" height="478" alt="image" src="https://github.com/user-attachments/assets/66d5ee9b-d031-427a-a98a-1cc1f1b78a9b" />


### 3）为什么需要双亲委派模型？
在这里，先想一下，如果没有双亲委派，那么用户是不是可以自定义一个`java.lang.Object`的同名类，`java.lang.String`的同名类，并把它放到`ClassPath`中，那么类之间的比较结果及类的唯一性将无法保证，因此，为什么需要双亲委派模型？**防止内存中出现多份同样的字节码** 

### 4）怎么打破双亲委派模型？
打破双亲委派机制则不仅要继承`ClassLoader`类，还要重写`loadClass`和`findClass`方法。

# 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节
码文件。 Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或
者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的 指令长度和其他特性。

# 场景题：说说JVM相关的类的加载、链接和初始化的问题？
一个Java类从字节代码到能够在JVM中被使用，需要经过加载、链接和初始化这三个步骤。

这三个步骤中，对开发人员直接可见的是Java类的加 载，通过使用Java类加载器（class loader）可以
在运行时刻动态的加载一个Java类；

链接和初始化对开发人员直接可见 不直接可见，因为：链接和初始化是在使用Java类之前会发生的动
作

## Java的类加载机制
我们知道一个Java类要想运行，必须由jvm将其装载到内存中才能运行，装载的目的就是把Java字节代
码转换成JVM中的java.lang.Class类的对象。

这样Java就可以对该对象进行一系列操作，装载过程有两个比较重要的特征：层次组织结构和代理模
式。

层次组织结构指的是每个类加载器都有一个父类加载器，通过getParent()方法可以获取到。

类加载器通过这种父亲-后代的方式组织在一起，形成树状层次结构。

代理模式则 指的是一个类加载器既可以自己完成Java类的定义工作，也可以代理给其它的类加载器来完
成。

由于代理模式的存在，启动一个类的加载过程的类加载器和最终 定义这个类的类加载器可能并不是一
个。

ClassLoader的加载类过程主要使用loadClass方法，该方法中封装了中加载机制：双亲委派模式。

一般来说，父类优先的策略就足够好了。

在某些情况下，可能需要采取相反的策略，即先尝试自己加载，找不到的时候再代理给父类加载
器。

这种做法在Java的Web容器中比较常见，也是Servlet规范推荐的做法。比如，Apache Tomcat为
每个Web应用都提供一个独立的类加载器，使用的就是自己优先加载的策略。

IBM WebSphere Application Server则允许Web应用选择类加载器使用的策略。

类加载器的一个重要用途是在JVM中为相同名称的Java类创建隔离空间。

在JVM中，判断两个类是否相同，不仅是根据该类的二进制名称，还需要根据两个类的定义类加
载器。

只有两者完全一样，才认为两个类的是相同的。因此，即便是同样的Java字节代码，被两个不同
的类加载器定义之后，所得到的Java类也是不同的。

如果试图在两个类的对象之间进行赋值操作，会抛出java.lang.ClassCastException。这个特性为
同样名称的Java类在JVM中共存创造了条件。

在实际的应用中，可能会要求同一名称的Java类的不同版本在JVM中可以同时存在。通过类加载器
就可以满足这种需求。这种技术在OSGi中得到了广泛的应用

### Java类的加载过程：

1.通过类的全名产生对应类的二进制数据流。（如果没找到对应类文件，只有在类实际使用时才抛出错
误。）

2.分析并将这些二进制数据流转换为方法区特定的数据结构（这些数据结构是实现有关的，不同 JVM 有
不同实现）。这里处理了部分检验，比如类文件的魔数的验证，检查文件是否过长或者过短，确定是否
有父类（除了 Obecjt 类）。

3.创建对应类的 java.lang.Class 实例（注意，有了对应的 Class 实例，并不意味着这个类已经完成了加
载链链接！）。

# Java类的链接

Java类的链接指的是将Java类的二进制代码合并到JVM的运行状态之中的过程。

在链接之前，这个类必须被成功加载。

链接的过程比加载过程要复杂很多，这是实现java的动态性的重要一步！

分为三部分：verification （检测）， preparation（准备） 和 resolution（解析）

### 1.verification（检测）：

验证是用来确保Java类的二进制表示在结构上是完全正确的。如果验证过程出现错误的话，会抛出
java.lang.VerifyError错误。

linking的resolve会把类中成员方法、成员变量、类和接口的符号引用替换为直接引用，而在这之前，
需要检测被引用的类型正确性和接入属 性是否正确（就是public ,private的的问题）诸如，检查final
class 没有被继承，检查静态变量的正确性等等。

验证是用来确保Java类的二进制表示在结构上是完全正确的。如果验证过程出现错误的话，会抛出
java.lang.VerifyError错误。

### 2.preparation（准备）：

准备过程则是创建Java类中的静态域，并将这些域的值设为默认值。'准备过程并不会执行代码。

在一个Java类中会包含对其它类或接口的形式引用，包括它的父类、所实现的接口、方法的形式参数和
返回值的Java类等。

对类的成员变量分配空间。

虽然有初始值，但这个时候不会对他们进行初始化（因为这里不会执行任何 Java 代码）。

具体如下：

所有原始类型的值都为 0。如 float: 0f, int: 0, boolean: 0(注意 boolean 底层实现大多使用 int)，

引用类型则为 null。

值得注意的是，JVM 可能会在这个时期给一些有助于程序运行效率提高的数据结构分配空间

### 3.resolution（解析）：

解析的过程就是确保这些被引用的类能被正确的找到。解析的过程可能会导致其它的Java类被加载。

为类、接口、方法、成员变量的符号引用定位直接引用，完成内存结构的布局。

这一步是可选的。可以在符号引用第一次被使用时完成，即所谓的延迟解析(late resolution)。

但对用户而言，这一步永远是延迟解析的，即使运行时会执行 early resolution，但程序不会显示的在
第一次判断出错误时抛出错误，而会在对应的类第一次主动使用的时候抛出错误！

另外，这一步与之后的类初始化是不冲突的，并非一定要所有的解析结束以后才执行类的初始化。

不同的 JVM 实现不同。

看下面一段代码：
```
public class LinkTest {
  public static void main(String[] args) {
    ToBeLinked toBeLinked = null;
    System.out.println("Test link.");
  }
}
```
类 LinkTest引用了类ToBeLinked，但是并没有真正使用它，只是声明了一个变量，并没有创建该类的
实例或是访问其中的静态域。

如果把编译好的ToBeLinked的Java字节代码删除之后，再运行LinkTest，程序不会抛出错误。
这是因为ToBeLinked类没有被真正用到。

链接策略使得ToBeLinked类不会被加载，因此也不会发现ToBeLinked的Java字节代码实际上是不存在
的。

如果把代码改成ToBeLinked toBeLinked = new ToBeLinked();之后，再按照相同的方法运行，就会抛
出异常了。

因为这个时候ToBeLinked这个类被真正使用到了，会需要加载这个类。

# Java类的初始化
开发 Java 时，接触最多的是对象的初始化。实际上类也是有初始化的。相比对象初始化，类的初始化机制要简单不少。

类的初始化也是延迟的，直到类第一次被主动使用（active use），JVM 才会初始化类。

当一个 Java 类第一次被真正使用到的时候，JVM 会进行该类的初始化操作。初始化过程的主要操作是执行静态代码块和初始化静态域。在一个类被初始化之前，它的直接父类也需要被初始化。

但是，一个接口的初始化，不会引起其父接口的初始化。在初始化的时候，会按照源代码中从上到下的顺序依次执行静态代码块和初始化静态域。

```java
public class StaticTest {
    public static int x = 10;
    public static void main(String[] args) {
        System.out.println(Y); //输出60
    }
    static {
        x = 30;
    }
    public static int Y = x * 2;
}
```

在上面的代码中，在初始化的时候，静态域的初始化和静态代码块的执行会从上到下依次执行。因此变量 x 的值首先初始化成 10，后来又被赋值成 30；而变量 Y 的值则被初始化成 60。

在上面的代码中，在初始化的时候，静态域的初始化和静态代码块的执行会从上到下依次执行。因此变量x的值首先初始化成10，后来又被赋值成30；而变量Y的值则被初始化成60。

类的初始化分两步：

1. 如果基类没有被初始化，初始化基类。

2. 有类构造函数，则执行类构造函数。


类构造函数是由 Java 编译器完成的。

它把类成员变量的初始化和 static 区间的代码提取，放到一个方法中。


这个方法不能被一般的方法访问（注意，static final 成员变量不会在此执行初始化，它一般被编译器生成 constant 值）。

同时，中是不会显示的调用基类的，因为 1 中已经执行了基类的初始化。该初始化过程是由 Jvm 保证线程安全的。 

Java 类和接口的初始化只有在特定的时机才会发生，这些时机包括:

- 创建一个 Java 类的实例。如
```java
MyClass obj = new MyClass()
```
- 调用一个 Java 类中的静态方法。如
```java
MyClass.sayHello()
```
- 给 Java 类或接口中声明的静态域赋值。如
```java
MyClass.value = 10
```
- 访问 Java 类或接口中声明的静态域，并且该域不是常值变量。如
```java
int value = MyClass.value
```
- 在顶层 Java 类中执行 assert 语句。

通过 Java 反射 API 也可能造成类和接口的初始化。需要注意的是，当访问一个 Java 类或接口中的静态域的时候，只有真正声明这个域的类或接口才会被初始化。考虑下面的代码:
```java
class B {
    static int value = 100;
    static {
        System.out.println("Class B is initialized."); //输出
    }
}
class A extends B {
    static {
        System.out.println("Class A is initialized."); //不会输出
    }
}
public class InitTest {
    public static void main(String[] args) {
        System.out.println(A.value); //输出100
    }
}
```

在上述代码中，类InitTest通过A.value引用了类B中声明的静态域value。由于value是在类B中声明的，
只有类B会被初始化，而类A则不会被初始化。
