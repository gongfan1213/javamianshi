# JVM调优连环炮：常用的JVM启动参数有哪些？
JVM可配置参数已经达到1000多个，其中GC和内存配置相关的JVM参数就有600多个。

但在绝大部分业务场景下，常用的JVM配置参数也就10来个。

```
# JVM启动参数不换行
# 设置堆内存
-Xmx4g -Xms4g
# 指定GC算法
-XX:+UseG1GC -XX:MaxGCPauseMillis=50
# 指定GC并行线程数
-XX:ParallelGCThreads=4
# 打印GC日志
-XX:+PrintGCDetails -XX:+PrintGCDateStamps
# 指定GC日志文件
-Xloggc:gc.log
# 指定Meta区的最大值
-XX:MaxMetaspaceSize=2g
# 设置单个线程栈的大小
-Xss1m
# 指定内存溢出时自动进行Dump
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/usr/local/

# 指定默认的连接超时时间
-Dsun.net.client.defaultConnectTimeout=2000

-Dsun.net.client.defaultReadTimeout=2000
# 指定时区
-Duser.timezone=GMT+08
# 设置默认的文件编码为UTF-8
-Dfile.encoding=UTF-8
# 指定随机数熵源(entropy source)
-Djava.security.egd=file:/dev/./urandom
```

# 附带：JVM上的随机数与熵池策略
在apache-tomcat官方文档提到了一些启动时的优化项，其中一项是关于随机数生成时，采用的“熵源”（entropy source）的策略。

他提到tomcat7的session id的生成主要通过`java.security.SecureRandom`生成随机数来实现，随机数算法使用的是“SHA1PRNG”
```java
private String secureRandomAlgorithm = "SHA1PRNG";
```

在Sun/oracle的Jdk里，这个算法的提供者在底层依赖到操作系统提供的随机数据，

在linux下，与之相关的是 `/dev/random`和`/dev/urandom`，对于这两个设备的的描述以前也见过讨论随机数的文章，wiki中有比较详细的描述，摘抄过来，先看 `/dev/random`：

在读取时，/dev/random设备会返回小于熵池噪声总数的随机字节。

/dev/random可生成高随机性的公钥或一次性密码本。

若熵池空了，对/dev/random的读操作将会被阻塞，直到收集到了足够的环境噪声为止

而 `/dev/urandom` 则是一个非阻塞的发生器:

dev/random的一个副本是/dev/urandom（“unlocked”，非阻塞的随机数发生器），

它会重复使用熵池中的数据以产生伪随机数据。

这表示对/dev/urandom的读取操作不会产生阻塞，但其输出的熵可能小于/dev/random的。

它可以作为生成较低强度密码的伪随机数生成器，不建议用于生成高强度长期密码。

另外wiki里也提到了为什么linux内核里的随机数生成器采用SHA1散列算法而非加密算法，是为了避开法律风险(密码出口限制)。

回到tomcat文档里的建议，采用非阻塞的熵源(entropy source)，通过java系统属性来设置：
```
-Djava.security.egd=file:/dev/./urandom
```

这个系统属性egd表示熵收集守护进程(entropy gathering daemon)，但这里值为何要在dev和random之间加一个点呢？

是因为一个jdk的bug，在这个bug的连接里有人反馈及时对 securerandom.source 设置为 /dev/urandom

它也仍然使用的 /dev/random ，有人提供了变通的解决方法，其中一个变通的做法是对 securerandom.source设置为 /dev/./urandom 才行。

也有人评论说这个不是bug，是有意为之。

# 举例：常用的JVM调优的参数都有哪些？
- `-Xms2g`：初始化堆大小为2g；
- `-Xmx2g`：堆最大内存为2g；
- `-XX:NewRatio=4`：设置年轻的和老年代的内存比例为1:4；
- `-XX:SurvivorRatio=8`：设置新生代 Eden 和 Survivor 比例为8:2；
- `-XX:+UseParNewGC`：指定使用 ParNew + Serial Old 垃圾收集器组合；
- `-XX:+UseParallelOldGC`：指定使用 ParNew + ParNew Old 垃圾回收器组合；
- `-XX:+UseConcMarkSweepGC`：指定使用 CMS + Serial Old 垃圾回收器组合；

- XX:+PrintGC：开启打印 gc 信息；
- XX:+PrintGCDetails：打印 gc 详细信息

# 说说：你知道的几种主要的JVM参数
思路：可以说一下堆栈配置相关的，垃圾收集器相关的，还有一下辅助信息相关的。

### 参考答案:
#### 1) 堆栈配置相关
```
java -xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:MaxPermSize=16m -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxTenuringThreshold=0
```

- `-Xmx3550m`：最大堆大小为3550m。
- `-Xms3550m`：设置初始堆大小为3550m。
- `-Xmn2g`：设置年轻代大小为2g。
- `-Xss128k`：每个线程的堆栈大小为128k。
- `-XX:MaxPermSize`：设置永久代大小为16m 
- `-XX:NewRatio=4`：设置年轻代（包括Eden和两个Survivor区）与老年代的比值（除去永久代）。
- `-XX:SurvivorRatio=4`：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6 
- `-XX:MaxTenuringThreshold=0`：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。

#### 2) 垃圾收集器相关
```
-XX:+UseParallelGC-XX:ParallelGCThreads=20-XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5-XX:+UseCMSCompactAtFullCollection:
```

- `-XX:+UseParallelGC`：选择垃圾收集器为并行收集器。
- `-XX:ParallelGCThreads=20`：配置并行收集器的线程数 
- `-XX:+UseConcMarkSweepGC`：设置年老代为并发收集。
- `-XX:CMSFullGCsBeforeCompaction`：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。 
- `-XX:+UseCMSCompactAtFullCollection`：打开对年老代的压缩。可能会影响性能，但是可以消除碎片 

#### 3) 辅助信息相关
```
-XX:+PrintGC-XX:+PrintGCDetails
```

- `-XX:+PrintGC` 输出形式:

```
[GC 118250K->113543K(130112K), 0.0094143 secs] [Full GC 121376K->10414K(130112K),
0.0650971 secs]
-XX:+PrintGCDetails 输出形式:
[GC [DefNew: 8614K->781K(9088K), 0.0123035 secs] 118250K->113543K(130112K), 0.0124633
secs] [GC [DefNew: 8614K->8614K(9088K), 0.0000665 secs][Tenured: 112761K->10414K(121024K),
0.0433488 secs] 121376K->10414K(130112K), 0.0432662 secs
```

# 说一下JVM 调优的工具？
JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。
- **jconsole**：用于对 JVM 中的内存、线程和类等进行监控；
- **jvisualvm**：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。

# JVM调优连环炮：调优命令有哪些？
Sun JDK 监控和故障处理命令有 jps、jstat、jmap、jhat、jstack、jinfo 
1. **jps**，JVM Process Status Tool，显示指定系统内所有的 HotSpot 虚拟机进程。 
2. **jstat**，JVM statistics Monitoring，是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程的类装载、内存、垃圾收集、JIT 编译等运行数据。 
3. **jmap**，JVM Memory Map，命令用于生成 heap dump 文件 
4. **jhat**，JVM Heap Analysis Tool，命令是与 jmap 搭配使用，用来分析 jmap 生成的 dump，jhat 内置了一个微型的 HTTP/HTML 服务器，生成 dump 的分析结果后，可以在浏览器中查看 
5. **jstack**，用于生成 java 虚拟机当前时刻的线程快照。 
6. **jinfo**，JVM Configuration info，这个命令作用是实时查看和调整虚拟机运行参数 

### 调优工具
常用调优工具分为两类：jdk 自带监控工具：jconsole 和 jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。 
1. **jconsole**，Java Monitoring and Management Console，是从 Java5 开始，在 JDK 中自带的 java 监控和管理控制台，用于对 JVM 中内存，线程和类等的监控 
2. **jvisualvm**，jdk 自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC 变化等。 
3. **MAT**，Memory Analyzer Tool，一个基于 Eclipse 的内存分析工具，是一个快速、功能丰富的 Java heap 分析工具，它可以帮助我们查找内存泄漏和减少内存消耗 
4. **GChisto**，一款专业分析 gc 日志的工具 

### JVM调优连环炮：设置堆内存XMX应该考虑哪些因素？
