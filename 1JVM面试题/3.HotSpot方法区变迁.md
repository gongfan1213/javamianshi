# HotSpot 方法区变迁
| 版本 | 演进细节 |
| ---- | ---- |
| JDK6及之前 | 方法区的实现为永久代，静态变量存放在永久代中，字符串常量池（StringTable）位于运行时常量池中。 |
| JDK7 | 方法区的实现为永久代，但已经逐步“去永久代”，静态变量、字符串常量池移除，保存在堆中 |
| JDK8 | 方法区的实现为本地内存的元空间，字符串常量池、静态变量仍在堆中 |

### JDK1.2 ~ JDK6
在JDK1.2 ~ JDK6的实现中，HotSpot使用永久代（永久代）实现方法区；

HotSpot使用GC分代实现方法区带来了很大便利；

### JDK7
由于GC分代技术的影响，使之许多优秀的内存调试工具无法在Oracle HotSpot之上运行，必须单独处理；

并且Oracle同时收购了BEA和Sun公司，同时拥有JRockit和HotSpot，在将JRockit许多优秀特性移植到HotSpot时，由于GC分代技术遇到了种种困难，所以从JDK8开始Oracle HotSpot开始移除永久代。


JDK7中符号表被移动到 Native Heap中，字符串常量和类引用被移动到Java NON_HEAP中。

### JDK8
在JDK8中，永久代已完全被元空间（Metaspace）所取代。

<img width="554" height="436" alt="image" src="https://github.com/user-attachments/assets/c9927cff-0dae-4ebf-b3b9-e7a5b40cadb0" />

<img width="553" height="248" alt="image" src="https://github.com/user-attachments/assets/c46ffdab-7308-4c77-bf5e-243d8075168c" />

# 问：为什么用元空间替换永久代？
为永久代设置最大空间大小是难以确定的。
- 在某些场景下，如果动态加载类过多，容易产生Perm区的OOM：比如某个实际Web工程中，因
为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误；而元空间和永久代
之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存，因此，默认情况下，元空间的
最大大小仅受本地内存限制。
- 对永久代进行调优是很困难的。

# 问：为什么调整字符串常量池的位置？
JDK7中将字符串常量池放到了堆空间中：因为永久代的回收效率很低，在Full GC时才会触发，而Full

GC在老年代的空间不足、永久代不足时才会触发，这就导致字符串常量池回收效率不高；

而我们开发中会有大量的字符串被创建，回收效率低会导致永久代内存不足。

将字符串常量池放到堆里，能及时回收内存。
# 问：几种不同的变量引用存放在哪里？

```java
public class StaticObjTest {
    static class Test {
        // 静态变量
        // 一个java.lang.Class类型的对象实例引用了此变量
        static ObjectHolder staticObj = new ObjectHolder();
        // 实例变量
        ObjectHolder instanceObj = new ObjectHolder();

        void foo() {
            // 局部变量
            ObjectHolder localObj = new ObjectHolder();
            System.out.println("done");
        }
    }

    private static class ObjectHolder {
    }

    public static void main(String[] args) {
        Test test = new StaticObjTest.Test();
        test.foo();
    }
}
```

以上代码中，静态变量`staticObj`随着`Test`的类型信息存放在方法区，

实例变量`instanceObj`随着`Test`的对象实例存放在堆区，

局部变量localObj则是存放在foo()方法栈帧的局部变量表中。

三个变量引用对应的对象实体都是在堆空间。

# 问： 什么是执行引擎？
执行引擎是 java 虚拟机的最核心组件之一，它负责执行虚拟机的字节码，有即时编译和解释执行，通
常采用解释执行方式。解释执行是指解释器通过每次解释并执行一小段代码来完成.class程序的所有操
作。即时编译则是将.class文件翻译成机器码在执行（比如：经常多次访问的代码可以全部编译）

垃圾回收系统是 java 虚拟机的重要组成部分，垃圾回收器可以对 栈 堆进行回收。其中， java 堆是垃圾
收集器的工作重点。有三类：增量垃圾回收，分代复制垃圾回收，标记垃圾回收

和 C/C++不同， java 中所有的对象空间释放都是隐式的，也就是说， java 中没有类似 free()或者
delete()这样的函数释放指定的内存区域。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工
作，默默查找、标识并释放垃圾对象，完成包括 java 堆、方法区和直接内存中的全自动化管理。
