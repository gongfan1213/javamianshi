# HotSpot 方法区变迁
| 版本 | 演进细节 |
| ---- | ---- |
| JDK6及之前 | 方法区的实现为永久代，静态变量存放在永久代中，字符串常量池（StringTable）位于运行时常量池中。 |
| JDK7 | 方法区的实现为永久代，但已经逐步“去永久代”，静态变量、字符串常量池移除，保存在堆中 |
| JDK8 | 方法区的实现为本地内存的元空间，字符串常量池、静态变量仍在堆中 |

### JDK1.2 ~ JDK6
在JDK1.2 ~ JDK6的实现中，HotSpot使用永久代（永久代）实现方法区；

HotSpot使用GC分代实现方法区带来了很大便利；

### JDK7
由于GC分代技术的影响，使之许多优秀的内存调试工具无法在Oracle HotSpot之上运行，必须单独处理；

并且Oracle同时收购了BEA和Sun公司，同时拥有JRockit和HotSpot，在将JRockit许多优秀特性移植到HotSpot时，由于GC分代技术遇到了种种困难，所以从JDK8开始Oracle HotSpot开始移除永久代。


JDK7中符号表被移动到 Native Heap中，字符串常量和类引用被移动到Java NON_HEAP中。

### JDK8
在JDK8中，永久代已完全被元空间（Metaspace）所取代。

<img width="554" height="436" alt="image" src="https://github.com/user-attachments/assets/c9927cff-0dae-4ebf-b3b9-e7a5b40cadb0" />

<img width="553" height="248" alt="image" src="https://github.com/user-attachments/assets/c46ffdab-7308-4c77-bf5e-243d8075168c" />

# 问：为什么用元空间替换永久代？
为永久代设置最大空间大小是难以确定的。
- 在某些场景下，如果动态加载类过多，容易产生Perm区的OOM：比如某个实际Web工程中，因
为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误；而元空间和永久代
之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存，因此，默认情况下，元空间的
最大大小仅受本地内存限制。
- 对永久代进行调优是很困难的。

# 问：为什么调整字符串常量池的位置？
JDK7中将字符串常量池放到了堆空间中：因为永久代的回收效率很低，在Full GC时才会触发，而Full

GC在老年代的空间不足、永久代不足时才会触发，这就导致字符串常量池回收效率不高；

而我们开发中会有大量的字符串被创建，回收效率低会导致永久代内存不足。

将字符串常量池放到堆里，能及时回收内存。
# 问：几种不同的变量引用存放在哪里？

```java
public class StaticObjTest {
    static class Test {
        // 静态变量
        // 一个java.lang.Class类型的对象实例引用了此变量
        static ObjectHolder staticObj = new ObjectHolder();
        // 实例变量
        ObjectHolder instanceObj = new ObjectHolder();

        void foo() {
            // 局部变量
            ObjectHolder localObj = new ObjectHolder();
            System.out.println("done");
        }
    }

    private static class ObjectHolder {
    }

    public static void main(String[] args) {
        Test test = new StaticObjTest.Test();
        test.foo();
    }
}
```

以上代码中，静态变量`staticObj`随着`Test`的类型信息存放在方法区，

实例变量`instanceObj`随着`Test`的对象实例存放在堆区，

局部变量localObj则是存放在foo()方法栈帧的局部变量表中。

三个变量引用对应的对象实体都是在堆空间。

# 问： 什么是执行引擎？
执行引擎是 java 虚拟机的最核心组件之一，它负责执行虚拟机的字节码，有即时编译和解释执行，通
常采用解释执行方式。解释执行是指解释器通过每次解释并执行一小段代码来完成.class程序的所有操
作。即时编译则是将.class文件翻译成机器码在执行（比如：经常多次访问的代码可以全部编译）

垃圾回收系统是 java 虚拟机的重要组成部分，垃圾回收器可以对 栈 堆进行回收。其中， java 堆是垃圾
收集器的工作重点。有三类：增量垃圾回收，分代复制垃圾回收，标记垃圾回收

和 C/C++不同， java 中所有的对象空间释放都是隐式的，也就是说， java 中没有类似 free()或者
delete()这样的函数释放指定的内存区域。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工
作，默默查找、标识并释放垃圾对象，完成包括 java 堆、方法区和直接内存中的全自动化管理。
# 问题：成员变量、局部变量、类变量分别存储在内存的什么地方？
### 类变量

类变量是用static修饰符修饰，定义在方法外的变量，随着java进程产生和销毁


在java8之前把静态变量存放于方法区，在java8时存放在堆中

**成员变量**

成员变量是定义在类中，但是没有static修饰符修饰的变量，随着类的实例产生和销毁，是类实例
的一部分

由于是实例的一部分，在类初始化的时候，从运行时常量池取出直接引用或者值，与初始化的对象
一起放入堆中

**局部变量**

局部变量是定义在类的方法中的变量

在所在方法被调用时放入虚拟机栈的栈帧中，方法执行结束后从虚拟机栈中弹出，所以存放在虚拟
机栈中


# 类常量池、运行时常量池、字符串常量池有什么关系？有什么区别？

类常量池与运行时常量池都存储在方法区，而字符串常量池在jdk7时就已经从方法区迁移到了java堆
中。

在类编译过程中，会把类元信息放到方法区，类元信息的其中一部分便是类常量池，主要存放字面量和
符号引用，而字面量的一部分便是文本字符，在类加载时将字面量和符号引用解析为直接引用存储在运
行时常量池；

对于文本字符来说，它们会在解析时查找字符串常量池，查出这个文本字符对应的字符串对象的直接引
用，将直接引用存储在运行时常量池；字符串常量池存储的是字符串对象的引用，而不是字符串本身。

# 使用堆外内存的优点

减少了垃圾回收

因为垃圾回收会暂停其他的工作。

加快了复制的速度

堆内在flush到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略
掉了这个工作。

# 深拷贝和浅拷贝
浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，


深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，

使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。

浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么复制出来的对象也会相应的改变。

深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。

# 说一下堆栈的区别？
### 物理地址

堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）

栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。

内存分别

堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。

栈是连续的，所以分配的内存大小要在**编译期**就确认，大小是固定的。

存放的内容

堆存放的是对象的实例和数组。因此该区更关注的是数据的存储

栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。

PS：

1. 静态变量放在方法区

2. 静态的对象还是放在堆。


程序的可见度

堆对于整个应用程序都是共享、可见的。

栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。
# Java中堆和栈有什么区别？
JVM中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个JVM的所有线程共享。
# 队列和栈是什么？有什么区别？
队列和栈都是被用来预存储数据的。
- 操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。
- 可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。
- 操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。
# 虚拟机栈(线程私有)
是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

栈帧（Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、方法返回值和异常分派（Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。

<img width="276" height="257" alt="image" src="https://github.com/user-attachments/assets/0af5d7a9-81c0-4a32-9e0e-d098daca4575" />


# 程序计数器(线程私有)
一块较小的内存空间,是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。

正在执行java方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是Native方法，则为空。这个内存区域是唯一一个在虚拟机中没有规定任何OutOfMemoryError情况的区域。

# 什么是直接内存？

直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于
Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java堆和
Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。

<img width="407" height="267" alt="image" src="https://github.com/user-attachments/assets/640fb0e7-3dd0-485b-b20e-53718ce5bf73" />













