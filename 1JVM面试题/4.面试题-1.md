# 问题：成员变量、局部变量、类变量分别存储在内存的什么地方？
### 类变量

类变量是用static修饰符修饰，定义在方法外的变量，随着java进程产生和销毁


在java8之前把静态变量存放于方法区，在java8时存放在堆中

**成员变量**

成员变量是定义在类中，但是没有static修饰符修饰的变量，随着类的实例产生和销毁，是类实例
的一部分

由于是实例的一部分，在类初始化的时候，从运行时常量池取出直接引用或者值，与初始化的对象
一起放入堆中

**局部变量**

局部变量是定义在类的方法中的变量

在所在方法被调用时放入虚拟机栈的栈帧中，方法执行结束后从虚拟机栈中弹出，所以存放在虚拟
机栈中


# 类常量池、运行时常量池、字符串常量池有什么关系？有什么区别？

类常量池与运行时常量池都存储在方法区，而字符串常量池在jdk7时就已经从方法区迁移到了java堆
中。

在类编译过程中，会把类元信息放到方法区，类元信息的其中一部分便是类常量池，主要存放字面量和
符号引用，而字面量的一部分便是文本字符，在类加载时将字面量和符号引用解析为直接引用存储在运
行时常量池；

对于文本字符来说，它们会在解析时查找字符串常量池，查出这个文本字符对应的字符串对象的直接引
用，将直接引用存储在运行时常量池；字符串常量池存储的是字符串对象的引用，而不是字符串本身。

# 使用堆外内存的优点

减少了垃圾回收

因为垃圾回收会暂停其他的工作。

加快了复制的速度

堆内在flush到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略
掉了这个工作。

# 深拷贝和浅拷贝
浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，


深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，

使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。

浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么复制出来的对象也会相应的改变。

深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。

# 说一下堆栈的区别？
### 物理地址

堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）

栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。

内存分别

堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。

栈是连续的，所以分配的内存大小要在**编译期**就确认，大小是固定的。

存放的内容

堆存放的是对象的实例和数组。因此该区更关注的是数据的存储

栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。

PS：

1. 静态变量放在方法区

2. 静态的对象还是放在堆。


程序的可见度

堆对于整个应用程序都是共享、可见的。

栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。
# Java中堆和栈有什么区别？
JVM中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个JVM的所有线程共享。
# 队列和栈是什么？有什么区别？
队列和栈都是被用来预存储数据的。
- 操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。
- 可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。
- 操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。
# 虚拟机栈(线程私有)
是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

栈帧（Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、方法返回值和异常分派（Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。

<img width="276" height="257" alt="image" src="https://github.com/user-attachments/assets/0af5d7a9-81c0-4a32-9e0e-d098daca4575" />


# 程序计数器(线程私有)
一块较小的内存空间,是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。

正在执行java方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是Native方法，则为空。这个内存区域是唯一一个在虚拟机中没有规定任何OutOfMemoryError情况的区域。

# 什么是直接内存？

直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于
Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java堆和
Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。

<img width="407" height="267" alt="image" src="https://github.com/user-attachments/assets/640fb0e7-3dd0-485b-b20e-53718ce5bf73" />













